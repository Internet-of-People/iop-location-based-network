// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IopLocNet.proto

#ifndef PROTOBUF_IopLocNet_2eproto__INCLUDED
#define PROTOBUF_IopLocNet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_IopLocNet_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[36];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsServiceInfoImpl();
void InitDefaultsServiceInfo();
void InitDefaultsGpsLocationImpl();
void InitDefaultsGpsLocation();
void InitDefaultsNodeContactImpl();
void InitDefaultsNodeContact();
void InitDefaultsNodeInfoImpl();
void InitDefaultsNodeInfo();
void InitDefaultsMessageWithHeaderImpl();
void InitDefaultsMessageWithHeader();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsLocalServiceRequestImpl();
void InitDefaultsLocalServiceRequest();
void InitDefaultsLocalServiceResponseImpl();
void InitDefaultsLocalServiceResponse();
void InitDefaultsRegisterServiceRequestImpl();
void InitDefaultsRegisterServiceRequest();
void InitDefaultsRegisterServiceResponseImpl();
void InitDefaultsRegisterServiceResponse();
void InitDefaultsDeregisterServiceRequestImpl();
void InitDefaultsDeregisterServiceRequest();
void InitDefaultsDeregisterServiceResponseImpl();
void InitDefaultsDeregisterServiceResponse();
void InitDefaultsGetNeighbourNodesByDistanceLocalRequestImpl();
void InitDefaultsGetNeighbourNodesByDistanceLocalRequest();
void InitDefaultsGetNeighbourNodesByDistanceResponseImpl();
void InitDefaultsGetNeighbourNodesByDistanceResponse();
void InitDefaultsNeighbourhoodChangeImpl();
void InitDefaultsNeighbourhoodChange();
void InitDefaultsNeighbourhoodChangedNotificationRequestImpl();
void InitDefaultsNeighbourhoodChangedNotificationRequest();
void InitDefaultsNeighbourhoodChangedNotificationResponseImpl();
void InitDefaultsNeighbourhoodChangedNotificationResponse();
void InitDefaultsRemoteNodeRequestImpl();
void InitDefaultsRemoteNodeRequest();
void InitDefaultsRemoteNodeResponseImpl();
void InitDefaultsRemoteNodeResponse();
void InitDefaultsBuildNetworkRequestImpl();
void InitDefaultsBuildNetworkRequest();
void InitDefaultsBuildNetworkResponseImpl();
void InitDefaultsBuildNetworkResponse();
void InitDefaultsGetNodeCountRequestImpl();
void InitDefaultsGetNodeCountRequest();
void InitDefaultsGetNodeCountResponseImpl();
void InitDefaultsGetNodeCountResponse();
void InitDefaultsGetRandomNodesRequestImpl();
void InitDefaultsGetRandomNodesRequest();
void InitDefaultsGetRandomNodesResponseImpl();
void InitDefaultsGetRandomNodesResponse();
void InitDefaultsGetClosestNodesByDistanceRequestImpl();
void InitDefaultsGetClosestNodesByDistanceRequest();
void InitDefaultsGetClosestNodesByDistanceResponseImpl();
void InitDefaultsGetClosestNodesByDistanceResponse();
void InitDefaultsClientRequestImpl();
void InitDefaultsClientRequest();
void InitDefaultsClientResponseImpl();
void InitDefaultsClientResponse();
void InitDefaultsGetNodeInfoRequestImpl();
void InitDefaultsGetNodeInfoRequest();
void InitDefaultsGetNodeInfoResponseImpl();
void InitDefaultsGetNodeInfoResponse();
void InitDefaultsGetNeighbourNodesByDistanceClientRequestImpl();
void InitDefaultsGetNeighbourNodesByDistanceClientRequest();
void InitDefaultsExploreNetworkNodesByDistanceRequestImpl();
void InitDefaultsExploreNetworkNodesByDistanceRequest();
void InitDefaultsExploreNetworkNodesByDistanceResponseImpl();
void InitDefaultsExploreNetworkNodesByDistanceResponse();
inline void InitDefaults() {
  InitDefaultsServiceInfo();
  InitDefaultsGpsLocation();
  InitDefaultsNodeContact();
  InitDefaultsNodeInfo();
  InitDefaultsMessageWithHeader();
  InitDefaultsMessage();
  InitDefaultsRequest();
  InitDefaultsResponse();
  InitDefaultsLocalServiceRequest();
  InitDefaultsLocalServiceResponse();
  InitDefaultsRegisterServiceRequest();
  InitDefaultsRegisterServiceResponse();
  InitDefaultsDeregisterServiceRequest();
  InitDefaultsDeregisterServiceResponse();
  InitDefaultsGetNeighbourNodesByDistanceLocalRequest();
  InitDefaultsGetNeighbourNodesByDistanceResponse();
  InitDefaultsNeighbourhoodChange();
  InitDefaultsNeighbourhoodChangedNotificationRequest();
  InitDefaultsNeighbourhoodChangedNotificationResponse();
  InitDefaultsRemoteNodeRequest();
  InitDefaultsRemoteNodeResponse();
  InitDefaultsBuildNetworkRequest();
  InitDefaultsBuildNetworkResponse();
  InitDefaultsGetNodeCountRequest();
  InitDefaultsGetNodeCountResponse();
  InitDefaultsGetRandomNodesRequest();
  InitDefaultsGetRandomNodesResponse();
  InitDefaultsGetClosestNodesByDistanceRequest();
  InitDefaultsGetClosestNodesByDistanceResponse();
  InitDefaultsClientRequest();
  InitDefaultsClientResponse();
  InitDefaultsGetNodeInfoRequest();
  InitDefaultsGetNodeInfoResponse();
  InitDefaultsGetNeighbourNodesByDistanceClientRequest();
  InitDefaultsExploreNetworkNodesByDistanceRequest();
  InitDefaultsExploreNetworkNodesByDistanceResponse();
}
}  // namespace protobuf_IopLocNet_2eproto
namespace iop {
namespace locnet {
class BuildNetworkRequest;
class BuildNetworkRequestDefaultTypeInternal;
extern BuildNetworkRequestDefaultTypeInternal _BuildNetworkRequest_default_instance_;
class BuildNetworkResponse;
class BuildNetworkResponseDefaultTypeInternal;
extern BuildNetworkResponseDefaultTypeInternal _BuildNetworkResponse_default_instance_;
class ClientRequest;
class ClientRequestDefaultTypeInternal;
extern ClientRequestDefaultTypeInternal _ClientRequest_default_instance_;
class ClientResponse;
class ClientResponseDefaultTypeInternal;
extern ClientResponseDefaultTypeInternal _ClientResponse_default_instance_;
class DeregisterServiceRequest;
class DeregisterServiceRequestDefaultTypeInternal;
extern DeregisterServiceRequestDefaultTypeInternal _DeregisterServiceRequest_default_instance_;
class DeregisterServiceResponse;
class DeregisterServiceResponseDefaultTypeInternal;
extern DeregisterServiceResponseDefaultTypeInternal _DeregisterServiceResponse_default_instance_;
class ExploreNetworkNodesByDistanceRequest;
class ExploreNetworkNodesByDistanceRequestDefaultTypeInternal;
extern ExploreNetworkNodesByDistanceRequestDefaultTypeInternal _ExploreNetworkNodesByDistanceRequest_default_instance_;
class ExploreNetworkNodesByDistanceResponse;
class ExploreNetworkNodesByDistanceResponseDefaultTypeInternal;
extern ExploreNetworkNodesByDistanceResponseDefaultTypeInternal _ExploreNetworkNodesByDistanceResponse_default_instance_;
class GetClosestNodesByDistanceRequest;
class GetClosestNodesByDistanceRequestDefaultTypeInternal;
extern GetClosestNodesByDistanceRequestDefaultTypeInternal _GetClosestNodesByDistanceRequest_default_instance_;
class GetClosestNodesByDistanceResponse;
class GetClosestNodesByDistanceResponseDefaultTypeInternal;
extern GetClosestNodesByDistanceResponseDefaultTypeInternal _GetClosestNodesByDistanceResponse_default_instance_;
class GetNeighbourNodesByDistanceClientRequest;
class GetNeighbourNodesByDistanceClientRequestDefaultTypeInternal;
extern GetNeighbourNodesByDistanceClientRequestDefaultTypeInternal _GetNeighbourNodesByDistanceClientRequest_default_instance_;
class GetNeighbourNodesByDistanceLocalRequest;
class GetNeighbourNodesByDistanceLocalRequestDefaultTypeInternal;
extern GetNeighbourNodesByDistanceLocalRequestDefaultTypeInternal _GetNeighbourNodesByDistanceLocalRequest_default_instance_;
class GetNeighbourNodesByDistanceResponse;
class GetNeighbourNodesByDistanceResponseDefaultTypeInternal;
extern GetNeighbourNodesByDistanceResponseDefaultTypeInternal _GetNeighbourNodesByDistanceResponse_default_instance_;
class GetNodeCountRequest;
class GetNodeCountRequestDefaultTypeInternal;
extern GetNodeCountRequestDefaultTypeInternal _GetNodeCountRequest_default_instance_;
class GetNodeCountResponse;
class GetNodeCountResponseDefaultTypeInternal;
extern GetNodeCountResponseDefaultTypeInternal _GetNodeCountResponse_default_instance_;
class GetNodeInfoRequest;
class GetNodeInfoRequestDefaultTypeInternal;
extern GetNodeInfoRequestDefaultTypeInternal _GetNodeInfoRequest_default_instance_;
class GetNodeInfoResponse;
class GetNodeInfoResponseDefaultTypeInternal;
extern GetNodeInfoResponseDefaultTypeInternal _GetNodeInfoResponse_default_instance_;
class GetRandomNodesRequest;
class GetRandomNodesRequestDefaultTypeInternal;
extern GetRandomNodesRequestDefaultTypeInternal _GetRandomNodesRequest_default_instance_;
class GetRandomNodesResponse;
class GetRandomNodesResponseDefaultTypeInternal;
extern GetRandomNodesResponseDefaultTypeInternal _GetRandomNodesResponse_default_instance_;
class GpsLocation;
class GpsLocationDefaultTypeInternal;
extern GpsLocationDefaultTypeInternal _GpsLocation_default_instance_;
class LocalServiceRequest;
class LocalServiceRequestDefaultTypeInternal;
extern LocalServiceRequestDefaultTypeInternal _LocalServiceRequest_default_instance_;
class LocalServiceResponse;
class LocalServiceResponseDefaultTypeInternal;
extern LocalServiceResponseDefaultTypeInternal _LocalServiceResponse_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageWithHeader;
class MessageWithHeaderDefaultTypeInternal;
extern MessageWithHeaderDefaultTypeInternal _MessageWithHeader_default_instance_;
class NeighbourhoodChange;
class NeighbourhoodChangeDefaultTypeInternal;
extern NeighbourhoodChangeDefaultTypeInternal _NeighbourhoodChange_default_instance_;
class NeighbourhoodChangedNotificationRequest;
class NeighbourhoodChangedNotificationRequestDefaultTypeInternal;
extern NeighbourhoodChangedNotificationRequestDefaultTypeInternal _NeighbourhoodChangedNotificationRequest_default_instance_;
class NeighbourhoodChangedNotificationResponse;
class NeighbourhoodChangedNotificationResponseDefaultTypeInternal;
extern NeighbourhoodChangedNotificationResponseDefaultTypeInternal _NeighbourhoodChangedNotificationResponse_default_instance_;
class NodeContact;
class NodeContactDefaultTypeInternal;
extern NodeContactDefaultTypeInternal _NodeContact_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class RegisterServiceRequest;
class RegisterServiceRequestDefaultTypeInternal;
extern RegisterServiceRequestDefaultTypeInternal _RegisterServiceRequest_default_instance_;
class RegisterServiceResponse;
class RegisterServiceResponseDefaultTypeInternal;
extern RegisterServiceResponseDefaultTypeInternal _RegisterServiceResponse_default_instance_;
class RemoteNodeRequest;
class RemoteNodeRequestDefaultTypeInternal;
extern RemoteNodeRequestDefaultTypeInternal _RemoteNodeRequest_default_instance_;
class RemoteNodeResponse;
class RemoteNodeResponseDefaultTypeInternal;
extern RemoteNodeResponseDefaultTypeInternal _RemoteNodeResponse_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ServiceInfo;
class ServiceInfoDefaultTypeInternal;
extern ServiceInfoDefaultTypeInternal _ServiceInfo_default_instance_;
}  // namespace locnet
}  // namespace iop
namespace iop {
namespace locnet {

enum Status {
  STATUS_OK = 0,
  ERROR_PROTOCOL_VIOLATION = 1,
  ERROR_UNSUPPORTED = 2,
  ERROR_INTERNAL = 8,
  ERROR_INVALID_VALUE = 54,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Status_IsValid(int value);
const Status Status_MIN = STATUS_OK;
const Status Status_MAX = ERROR_INVALID_VALUE;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class ServiceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ServiceInfo) */ {
 public:
  ServiceInfo();
  virtual ~ServiceInfo();

  ServiceInfo(const ServiceInfo& from);

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceInfo(ServiceInfo&& from) noexcept
    : ServiceInfo() {
    *this = ::std::move(from);
  }

  inline ServiceInfo& operator=(ServiceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceInfo* internal_default_instance() {
    return reinterpret_cast<const ServiceInfo*>(
               &_ServiceInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ServiceInfo* other);
  friend void swap(ServiceInfo& a, ServiceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceInfo& from);
  void MergeFrom(const ServiceInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes service_data = 3;
  void clear_service_data();
  static const int kServiceDataFieldNumber = 3;
  const ::std::string& service_data() const;
  void set_service_data(const ::std::string& value);
  #if LANG_CXX11
  void set_service_data(::std::string&& value);
  #endif
  void set_service_data(const char* value);
  void set_service_data(const void* value, size_t size);
  ::std::string* mutable_service_data();
  ::std::string* release_service_data();
  void set_allocated_service_data(::std::string* service_data);

  // uint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.ServiceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr service_data_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsServiceInfoImpl();
};
// -------------------------------------------------------------------

class GpsLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GpsLocation) */ {
 public:
  GpsLocation();
  virtual ~GpsLocation();

  GpsLocation(const GpsLocation& from);

  inline GpsLocation& operator=(const GpsLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpsLocation(GpsLocation&& from) noexcept
    : GpsLocation() {
    *this = ::std::move(from);
  }

  inline GpsLocation& operator=(GpsLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpsLocation* internal_default_instance() {
    return reinterpret_cast<const GpsLocation*>(
               &_GpsLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GpsLocation* other);
  friend void swap(GpsLocation& a, GpsLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpsLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  GpsLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpsLocation& from);
  void MergeFrom(const GpsLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpsLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sfixed32 latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // sfixed32 longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GpsLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGpsLocationImpl();
};
// -------------------------------------------------------------------

class NodeContact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeContact) */ {
 public:
  NodeContact();
  virtual ~NodeContact();

  NodeContact(const NodeContact& from);

  inline NodeContact& operator=(const NodeContact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeContact(NodeContact&& from) noexcept
    : NodeContact() {
    *this = ::std::move(from);
  }

  inline NodeContact& operator=(NodeContact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeContact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeContact* internal_default_instance() {
    return reinterpret_cast<const NodeContact*>(
               &_NodeContact_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NodeContact* other);
  friend void swap(NodeContact& a, NodeContact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeContact* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeContact* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeContact& from);
  void MergeFrom(const NodeContact& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeContact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const void* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // uint32 node_port = 2;
  void clear_node_port();
  static const int kNodePortFieldNumber = 2;
  ::google::protobuf::uint32 node_port() const;
  void set_node_port(::google::protobuf::uint32 value);

  // uint32 client_port = 3;
  void clear_client_port();
  static const int kClientPortFieldNumber = 3;
  ::google::protobuf::uint32 client_port() const;
  void set_client_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeContact)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::uint32 node_port_;
  ::google::protobuf::uint32 client_port_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsNodeContactImpl();
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.ServiceInfo services = 32;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 32;
  const ::iop::locnet::ServiceInfo& services(int index) const;
  ::iop::locnet::ServiceInfo* mutable_services(int index);
  ::iop::locnet::ServiceInfo* add_services();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
      services() const;

  // bytes node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // .iop.locnet.NodeContact contact = 2;
  bool has_contact() const;
  void clear_contact();
  static const int kContactFieldNumber = 2;
  const ::iop::locnet::NodeContact& contact() const;
  ::iop::locnet::NodeContact* release_contact();
  ::iop::locnet::NodeContact* mutable_contact();
  void set_allocated_contact(::iop::locnet::NodeContact* contact);

  // .iop.locnet.GpsLocation location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* release_location();
  ::iop::locnet::GpsLocation* mutable_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo > services_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::iop::locnet::NodeContact* contact_;
  ::iop::locnet::GpsLocation* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsNodeInfoImpl();
};
// -------------------------------------------------------------------

class MessageWithHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.MessageWithHeader) */ {
 public:
  MessageWithHeader();
  virtual ~MessageWithHeader();

  MessageWithHeader(const MessageWithHeader& from);

  inline MessageWithHeader& operator=(const MessageWithHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageWithHeader(MessageWithHeader&& from) noexcept
    : MessageWithHeader() {
    *this = ::std::move(from);
  }

  inline MessageWithHeader& operator=(MessageWithHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWithHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageWithHeader* internal_default_instance() {
    return reinterpret_cast<const MessageWithHeader*>(
               &_MessageWithHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MessageWithHeader* other);
  friend void swap(MessageWithHeader& a, MessageWithHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageWithHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageWithHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageWithHeader& from);
  void MergeFrom(const MessageWithHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageWithHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.Message body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::iop::locnet::Message& body() const;
  ::iop::locnet::Message* release_body();
  ::iop::locnet::Message* mutable_body();
  void set_allocated_body(::iop::locnet::Message* body);

  // fixed32 header = 1;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  ::google::protobuf::uint32 header() const;
  void set_header(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.MessageWithHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::Message* body_;
  ::google::protobuf::uint32 header_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsMessageWithHeaderImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MessageTypeCase {
    kRequest = 2,
    kResponse = 3,
    MESSAGETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .iop.locnet.Request request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::iop::locnet::Request& request() const;
  ::iop::locnet::Request* release_request();
  ::iop::locnet::Request* mutable_request();
  void set_allocated_request(::iop::locnet::Request* request);

  // .iop.locnet.Response response = 3;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 3;
  const ::iop::locnet::Response& response() const;
  ::iop::locnet::Response* release_response();
  ::iop::locnet::Response* mutable_response();
  void set_allocated_response(::iop::locnet::Response* response);

  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Message)
 private:
  void set_has_request();
  void set_has_response();

  inline bool has_MessageType() const;
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  union MessageTypeUnion {
    MessageTypeUnion() {}
    ::iop::locnet::Request* request_;
    ::iop::locnet::Response* response_;
  } MessageType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsMessageImpl();
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestTypeCase {
    kLocalService = 2,
    kRemoteNode = 3,
    kClient = 4,
    REQUESTTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .iop.locnet.LocalServiceRequest local_service = 2;
  bool has_local_service() const;
  void clear_local_service();
  static const int kLocalServiceFieldNumber = 2;
  const ::iop::locnet::LocalServiceRequest& local_service() const;
  ::iop::locnet::LocalServiceRequest* release_local_service();
  ::iop::locnet::LocalServiceRequest* mutable_local_service();
  void set_allocated_local_service(::iop::locnet::LocalServiceRequest* local_service);

  // .iop.locnet.RemoteNodeRequest remote_node = 3;
  bool has_remote_node() const;
  void clear_remote_node();
  static const int kRemoteNodeFieldNumber = 3;
  const ::iop::locnet::RemoteNodeRequest& remote_node() const;
  ::iop::locnet::RemoteNodeRequest* release_remote_node();
  ::iop::locnet::RemoteNodeRequest* mutable_remote_node();
  void set_allocated_remote_node(::iop::locnet::RemoteNodeRequest* remote_node);

  // .iop.locnet.ClientRequest client = 4;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 4;
  const ::iop::locnet::ClientRequest& client() const;
  ::iop::locnet::ClientRequest* release_client();
  ::iop::locnet::ClientRequest* mutable_client();
  void set_allocated_client(::iop::locnet::ClientRequest* client);

  RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Request)
 private:
  void set_has_local_service();
  void set_has_remote_node();
  void set_has_client();

  inline bool has_RequestType() const;
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::iop::locnet::LocalServiceRequest* local_service_;
    ::iop::locnet::RemoteNodeRequest* remote_node_;
    ::iop::locnet::ClientRequest* client_;
  } RequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseTypeCase {
    kLocalService = 4,
    kRemoteNode = 5,
    kClient = 6,
    RESPONSETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string details = 3;
  void clear_details();
  static const int kDetailsFieldNumber = 3;
  const ::std::string& details() const;
  void set_details(const ::std::string& value);
  #if LANG_CXX11
  void set_details(::std::string&& value);
  #endif
  void set_details(const char* value);
  void set_details(const char* value, size_t size);
  ::std::string* mutable_details();
  ::std::string* release_details();
  void set_allocated_details(::std::string* details);

  // sint64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .iop.locnet.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::iop::locnet::Status status() const;
  void set_status(::iop::locnet::Status value);

  // .iop.locnet.LocalServiceResponse local_service = 4;
  bool has_local_service() const;
  void clear_local_service();
  static const int kLocalServiceFieldNumber = 4;
  const ::iop::locnet::LocalServiceResponse& local_service() const;
  ::iop::locnet::LocalServiceResponse* release_local_service();
  ::iop::locnet::LocalServiceResponse* mutable_local_service();
  void set_allocated_local_service(::iop::locnet::LocalServiceResponse* local_service);

  // .iop.locnet.RemoteNodeResponse remote_node = 5;
  bool has_remote_node() const;
  void clear_remote_node();
  static const int kRemoteNodeFieldNumber = 5;
  const ::iop::locnet::RemoteNodeResponse& remote_node() const;
  ::iop::locnet::RemoteNodeResponse* release_remote_node();
  ::iop::locnet::RemoteNodeResponse* mutable_remote_node();
  void set_allocated_remote_node(::iop::locnet::RemoteNodeResponse* remote_node);

  // .iop.locnet.ClientResponse client = 6;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 6;
  const ::iop::locnet::ClientResponse& client() const;
  ::iop::locnet::ClientResponse* release_client();
  ::iop::locnet::ClientResponse* mutable_client();
  void set_allocated_client(::iop::locnet::ClientResponse* client);

  ResponseTypeCase ResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Response)
 private:
  void set_has_local_service();
  void set_has_remote_node();
  void set_has_client();

  inline bool has_ResponseType() const;
  void clear_ResponseType();
  inline void clear_has_ResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr details_;
  ::google::protobuf::int64 timestamp_;
  int status_;
  union ResponseTypeUnion {
    ResponseTypeUnion() {}
    ::iop::locnet::LocalServiceResponse* local_service_;
    ::iop::locnet::RemoteNodeResponse* remote_node_;
    ::iop::locnet::ClientResponse* client_;
  } ResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class LocalServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceRequest) */ {
 public:
  LocalServiceRequest();
  virtual ~LocalServiceRequest();

  LocalServiceRequest(const LocalServiceRequest& from);

  inline LocalServiceRequest& operator=(const LocalServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalServiceRequest(LocalServiceRequest&& from) noexcept
    : LocalServiceRequest() {
    *this = ::std::move(from);
  }

  inline LocalServiceRequest& operator=(LocalServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceRequest& default_instance();

  enum LocalServiceRequestTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodChanged = 4,
    kGetNodeInfo = 5,
    LOCALSERVICEREQUESTTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalServiceRequest* internal_default_instance() {
    return reinterpret_cast<const LocalServiceRequest*>(
               &_LocalServiceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(LocalServiceRequest* other);
  friend void swap(LocalServiceRequest& a, LocalServiceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalServiceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalServiceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalServiceRequest& from);
  void MergeFrom(const LocalServiceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.RegisterServiceRequest register_service = 1;
  bool has_register_service() const;
  void clear_register_service();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceRequest& register_service() const;
  ::iop::locnet::RegisterServiceRequest* release_register_service();
  ::iop::locnet::RegisterServiceRequest* mutable_register_service();
  void set_allocated_register_service(::iop::locnet::RegisterServiceRequest* register_service);

  // .iop.locnet.DeregisterServiceRequest deregister_service = 2;
  bool has_deregister_service() const;
  void clear_deregister_service();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceRequest& deregister_service() const;
  ::iop::locnet::DeregisterServiceRequest* release_deregister_service();
  ::iop::locnet::DeregisterServiceRequest* mutable_deregister_service();
  void set_allocated_deregister_service(::iop::locnet::DeregisterServiceRequest* deregister_service);

  // .iop.locnet.GetNeighbourNodesByDistanceLocalRequest get_neighbour_nodes = 3;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* release_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* mutable_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* get_neighbour_nodes);

  // .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhood_changed = 4;
  bool has_neighbourhood_changed() const;
  void clear_neighbourhood_changed();
  static const int kNeighbourhoodChangedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationRequest& neighbourhood_changed() const;
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* release_neighbourhood_changed();
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* mutable_neighbourhood_changed();
  void set_allocated_neighbourhood_changed(::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhood_changed);

  // .iop.locnet.GetNodeInfoRequest get_node_info = 5;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 5;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  LocalServiceRequestTypeCase LocalServiceRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceRequest)
 private:
  void set_has_register_service();
  void set_has_deregister_service();
  void set_has_get_neighbour_nodes();
  void set_has_neighbourhood_changed();
  void set_has_get_node_info();

  inline bool has_LocalServiceRequestType() const;
  void clear_LocalServiceRequestType();
  inline void clear_has_LocalServiceRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union LocalServiceRequestTypeUnion {
    LocalServiceRequestTypeUnion() {}
    ::iop::locnet::RegisterServiceRequest* register_service_;
    ::iop::locnet::DeregisterServiceRequest* deregister_service_;
    ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* get_neighbour_nodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhood_changed_;
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
  } LocalServiceRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsLocalServiceRequestImpl();
};
// -------------------------------------------------------------------

class LocalServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceResponse) */ {
 public:
  LocalServiceResponse();
  virtual ~LocalServiceResponse();

  LocalServiceResponse(const LocalServiceResponse& from);

  inline LocalServiceResponse& operator=(const LocalServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalServiceResponse(LocalServiceResponse&& from) noexcept
    : LocalServiceResponse() {
    *this = ::std::move(from);
  }

  inline LocalServiceResponse& operator=(LocalServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceResponse& default_instance();

  enum LocalServiceResponseTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodUpdated = 4,
    kGetNodeInfo = 5,
    LOCALSERVICERESPONSETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalServiceResponse* internal_default_instance() {
    return reinterpret_cast<const LocalServiceResponse*>(
               &_LocalServiceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(LocalServiceResponse* other);
  friend void swap(LocalServiceResponse& a, LocalServiceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalServiceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalServiceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalServiceResponse& from);
  void MergeFrom(const LocalServiceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.RegisterServiceResponse register_service = 1;
  bool has_register_service() const;
  void clear_register_service();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceResponse& register_service() const;
  ::iop::locnet::RegisterServiceResponse* release_register_service();
  ::iop::locnet::RegisterServiceResponse* mutable_register_service();
  void set_allocated_register_service(::iop::locnet::RegisterServiceResponse* register_service);

  // .iop.locnet.DeregisterServiceResponse deregister_service = 2;
  bool has_deregister_service() const;
  void clear_deregister_service();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceResponse& deregister_service() const;
  ::iop::locnet::DeregisterServiceResponse* release_deregister_service();
  ::iop::locnet::DeregisterServiceResponse* mutable_deregister_service();
  void set_allocated_deregister_service(::iop::locnet::DeregisterServiceResponse* deregister_service);

  // .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 3;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes);

  // .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhood_updated = 4;
  bool has_neighbourhood_updated() const;
  void clear_neighbourhood_updated();
  static const int kNeighbourhoodUpdatedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationResponse& neighbourhood_updated() const;
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* release_neighbourhood_updated();
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* mutable_neighbourhood_updated();
  void set_allocated_neighbourhood_updated(::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhood_updated);

  // .iop.locnet.GetNodeInfoResponse get_node_info = 5;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 5;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  LocalServiceResponseTypeCase LocalServiceResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceResponse)
 private:
  void set_has_register_service();
  void set_has_deregister_service();
  void set_has_get_neighbour_nodes();
  void set_has_neighbourhood_updated();
  void set_has_get_node_info();

  inline bool has_LocalServiceResponseType() const;
  void clear_LocalServiceResponseType();
  inline void clear_has_LocalServiceResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union LocalServiceResponseTypeUnion {
    LocalServiceResponseTypeUnion() {}
    ::iop::locnet::RegisterServiceResponse* register_service_;
    ::iop::locnet::DeregisterServiceResponse* deregister_service_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhood_updated_;
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
  } LocalServiceResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsLocalServiceResponseImpl();
};
// -------------------------------------------------------------------

class RegisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceRequest) */ {
 public:
  RegisterServiceRequest();
  virtual ~RegisterServiceRequest();

  RegisterServiceRequest(const RegisterServiceRequest& from);

  inline RegisterServiceRequest& operator=(const RegisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterServiceRequest(RegisterServiceRequest&& from) noexcept
    : RegisterServiceRequest() {
    *this = ::std::move(from);
  }

  inline RegisterServiceRequest& operator=(RegisterServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterServiceRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterServiceRequest*>(
               &_RegisterServiceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RegisterServiceRequest* other);
  friend void swap(RegisterServiceRequest& a, RegisterServiceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterServiceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterServiceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterServiceRequest& from);
  void MergeFrom(const RegisterServiceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.ServiceInfo service = 1;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::iop::locnet::ServiceInfo& service() const;
  ::iop::locnet::ServiceInfo* release_service();
  ::iop::locnet::ServiceInfo* mutable_service();
  void set_allocated_service(::iop::locnet::ServiceInfo* service);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::ServiceInfo* service_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsRegisterServiceRequestImpl();
};
// -------------------------------------------------------------------

class RegisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceResponse) */ {
 public:
  RegisterServiceResponse();
  virtual ~RegisterServiceResponse();

  RegisterServiceResponse(const RegisterServiceResponse& from);

  inline RegisterServiceResponse& operator=(const RegisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterServiceResponse(RegisterServiceResponse&& from) noexcept
    : RegisterServiceResponse() {
    *this = ::std::move(from);
  }

  inline RegisterServiceResponse& operator=(RegisterServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterServiceResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterServiceResponse*>(
               &_RegisterServiceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RegisterServiceResponse* other);
  friend void swap(RegisterServiceResponse& a, RegisterServiceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterServiceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterServiceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterServiceResponse& from);
  void MergeFrom(const RegisterServiceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* release_location();
  ::iop::locnet::GpsLocation* mutable_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::GpsLocation* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsRegisterServiceResponseImpl();
};
// -------------------------------------------------------------------

class DeregisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceRequest) */ {
 public:
  DeregisterServiceRequest();
  virtual ~DeregisterServiceRequest();

  DeregisterServiceRequest(const DeregisterServiceRequest& from);

  inline DeregisterServiceRequest& operator=(const DeregisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeregisterServiceRequest(DeregisterServiceRequest&& from) noexcept
    : DeregisterServiceRequest() {
    *this = ::std::move(from);
  }

  inline DeregisterServiceRequest& operator=(DeregisterServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeregisterServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DeregisterServiceRequest*>(
               &_DeregisterServiceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DeregisterServiceRequest* other);
  friend void swap(DeregisterServiceRequest& a, DeregisterServiceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeregisterServiceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeregisterServiceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeregisterServiceRequest& from);
  void MergeFrom(const DeregisterServiceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeregisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_type = 1;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  const ::std::string& service_type() const;
  void set_service_type(const ::std::string& value);
  #if LANG_CXX11
  void set_service_type(::std::string&& value);
  #endif
  void set_service_type(const char* value);
  void set_service_type(const char* value, size_t size);
  ::std::string* mutable_service_type();
  ::std::string* release_service_type();
  void set_allocated_service_type(::std::string* service_type);

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsDeregisterServiceRequestImpl();
};
// -------------------------------------------------------------------

class DeregisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceResponse) */ {
 public:
  DeregisterServiceResponse();
  virtual ~DeregisterServiceResponse();

  DeregisterServiceResponse(const DeregisterServiceResponse& from);

  inline DeregisterServiceResponse& operator=(const DeregisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeregisterServiceResponse(DeregisterServiceResponse&& from) noexcept
    : DeregisterServiceResponse() {
    *this = ::std::move(from);
  }

  inline DeregisterServiceResponse& operator=(DeregisterServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeregisterServiceResponse* internal_default_instance() {
    return reinterpret_cast<const DeregisterServiceResponse*>(
               &_DeregisterServiceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DeregisterServiceResponse* other);
  friend void swap(DeregisterServiceResponse& a, DeregisterServiceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeregisterServiceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DeregisterServiceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeregisterServiceResponse& from);
  void MergeFrom(const DeregisterServiceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeregisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsDeregisterServiceResponseImpl();
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceLocalRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceLocalRequest) */ {
 public:
  GetNeighbourNodesByDistanceLocalRequest();
  virtual ~GetNeighbourNodesByDistanceLocalRequest();

  GetNeighbourNodesByDistanceLocalRequest(const GetNeighbourNodesByDistanceLocalRequest& from);

  inline GetNeighbourNodesByDistanceLocalRequest& operator=(const GetNeighbourNodesByDistanceLocalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNeighbourNodesByDistanceLocalRequest(GetNeighbourNodesByDistanceLocalRequest&& from) noexcept
    : GetNeighbourNodesByDistanceLocalRequest() {
    *this = ::std::move(from);
  }

  inline GetNeighbourNodesByDistanceLocalRequest& operator=(GetNeighbourNodesByDistanceLocalRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceLocalRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNeighbourNodesByDistanceLocalRequest* internal_default_instance() {
    return reinterpret_cast<const GetNeighbourNodesByDistanceLocalRequest*>(
               &_GetNeighbourNodesByDistanceLocalRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(GetNeighbourNodesByDistanceLocalRequest* other);
  friend void swap(GetNeighbourNodesByDistanceLocalRequest& a, GetNeighbourNodesByDistanceLocalRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceLocalRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNeighbourNodesByDistanceLocalRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNeighbourNodesByDistanceLocalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool keep_alive_and_send_updates = 1;
  void clear_keep_alive_and_send_updates();
  static const int kKeepAliveAndSendUpdatesFieldNumber = 1;
  bool keep_alive_and_send_updates() const;
  void set_keep_alive_and_send_updates(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceLocalRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool keep_alive_and_send_updates_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNeighbourNodesByDistanceLocalRequestImpl();
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceResponse) */ {
 public:
  GetNeighbourNodesByDistanceResponse();
  virtual ~GetNeighbourNodesByDistanceResponse();

  GetNeighbourNodesByDistanceResponse(const GetNeighbourNodesByDistanceResponse& from);

  inline GetNeighbourNodesByDistanceResponse& operator=(const GetNeighbourNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNeighbourNodesByDistanceResponse(GetNeighbourNodesByDistanceResponse&& from) noexcept
    : GetNeighbourNodesByDistanceResponse() {
    *this = ::std::move(from);
  }

  inline GetNeighbourNodesByDistanceResponse& operator=(GetNeighbourNodesByDistanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNeighbourNodesByDistanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetNeighbourNodesByDistanceResponse*>(
               &_GetNeighbourNodesByDistanceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GetNeighbourNodesByDistanceResponse* other);
  friend void swap(GetNeighbourNodesByDistanceResponse& a, GetNeighbourNodesByDistanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNeighbourNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNeighbourNodesByDistanceResponse& from);
  void MergeFrom(const GetNeighbourNodesByDistanceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNeighbourNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNeighbourNodesByDistanceResponseImpl();
};
// -------------------------------------------------------------------

class NeighbourhoodChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChange) */ {
 public:
  NeighbourhoodChange();
  virtual ~NeighbourhoodChange();

  NeighbourhoodChange(const NeighbourhoodChange& from);

  inline NeighbourhoodChange& operator=(const NeighbourhoodChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NeighbourhoodChange(NeighbourhoodChange&& from) noexcept
    : NeighbourhoodChange() {
    *this = ::std::move(from);
  }

  inline NeighbourhoodChange& operator=(NeighbourhoodChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChange& default_instance();

  enum ChangeTypeCase {
    kAddedNodeInfo = 1,
    kUpdatedNodeInfo = 2,
    kRemovedNodeId = 3,
    CHANGETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NeighbourhoodChange* internal_default_instance() {
    return reinterpret_cast<const NeighbourhoodChange*>(
               &_NeighbourhoodChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(NeighbourhoodChange* other);
  friend void swap(NeighbourhoodChange& a, NeighbourhoodChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NeighbourhoodChange* New() const PROTOBUF_FINAL { return New(NULL); }

  NeighbourhoodChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NeighbourhoodChange& from);
  void MergeFrom(const NeighbourhoodChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NeighbourhoodChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.NodeInfo added_node_info = 1;
  bool has_added_node_info() const;
  void clear_added_node_info();
  static const int kAddedNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& added_node_info() const;
  ::iop::locnet::NodeInfo* release_added_node_info();
  ::iop::locnet::NodeInfo* mutable_added_node_info();
  void set_allocated_added_node_info(::iop::locnet::NodeInfo* added_node_info);

  // .iop.locnet.NodeInfo updated_node_info = 2;
  bool has_updated_node_info() const;
  void clear_updated_node_info();
  static const int kUpdatedNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& updated_node_info() const;
  ::iop::locnet::NodeInfo* release_updated_node_info();
  ::iop::locnet::NodeInfo* mutable_updated_node_info();
  void set_allocated_updated_node_info(::iop::locnet::NodeInfo* updated_node_info);

  // bytes removed_node_id = 3;
  private:
  bool has_removed_node_id() const;
  public:
  void clear_removed_node_id();
  static const int kRemovedNodeIdFieldNumber = 3;
  const ::std::string& removed_node_id() const;
  void set_removed_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_removed_node_id(::std::string&& value);
  #endif
  void set_removed_node_id(const char* value);
  void set_removed_node_id(const void* value, size_t size);
  ::std::string* mutable_removed_node_id();
  ::std::string* release_removed_node_id();
  void set_allocated_removed_node_id(::std::string* removed_node_id);

  ChangeTypeCase ChangeType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChange)
 private:
  void set_has_added_node_info();
  void set_has_updated_node_info();
  void set_has_removed_node_id();

  inline bool has_ChangeType() const;
  void clear_ChangeType();
  inline void clear_has_ChangeType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ChangeTypeUnion {
    ChangeTypeUnion() {}
    ::iop::locnet::NodeInfo* added_node_info_;
    ::iop::locnet::NodeInfo* updated_node_info_;
    ::google::protobuf::internal::ArenaStringPtr removed_node_id_;
  } ChangeType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsNeighbourhoodChangeImpl();
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationRequest) */ {
 public:
  NeighbourhoodChangedNotificationRequest();
  virtual ~NeighbourhoodChangedNotificationRequest();

  NeighbourhoodChangedNotificationRequest(const NeighbourhoodChangedNotificationRequest& from);

  inline NeighbourhoodChangedNotificationRequest& operator=(const NeighbourhoodChangedNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NeighbourhoodChangedNotificationRequest(NeighbourhoodChangedNotificationRequest&& from) noexcept
    : NeighbourhoodChangedNotificationRequest() {
    *this = ::std::move(from);
  }

  inline NeighbourhoodChangedNotificationRequest& operator=(NeighbourhoodChangedNotificationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NeighbourhoodChangedNotificationRequest* internal_default_instance() {
    return reinterpret_cast<const NeighbourhoodChangedNotificationRequest*>(
               &_NeighbourhoodChangedNotificationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(NeighbourhoodChangedNotificationRequest* other);
  friend void swap(NeighbourhoodChangedNotificationRequest& a, NeighbourhoodChangedNotificationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NeighbourhoodChangedNotificationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NeighbourhoodChangedNotificationRequest& from);
  void MergeFrom(const NeighbourhoodChangedNotificationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NeighbourhoodChangedNotificationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NeighbourhoodChange changes = 1;
  int changes_size() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::iop::locnet::NeighbourhoodChange& changes(int index) const;
  ::iop::locnet::NeighbourhoodChange* mutable_changes(int index);
  ::iop::locnet::NeighbourhoodChange* add_changes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
      mutable_changes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
      changes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange > changes_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsNeighbourhoodChangedNotificationRequestImpl();
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationResponse) */ {
 public:
  NeighbourhoodChangedNotificationResponse();
  virtual ~NeighbourhoodChangedNotificationResponse();

  NeighbourhoodChangedNotificationResponse(const NeighbourhoodChangedNotificationResponse& from);

  inline NeighbourhoodChangedNotificationResponse& operator=(const NeighbourhoodChangedNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NeighbourhoodChangedNotificationResponse(NeighbourhoodChangedNotificationResponse&& from) noexcept
    : NeighbourhoodChangedNotificationResponse() {
    *this = ::std::move(from);
  }

  inline NeighbourhoodChangedNotificationResponse& operator=(NeighbourhoodChangedNotificationResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NeighbourhoodChangedNotificationResponse* internal_default_instance() {
    return reinterpret_cast<const NeighbourhoodChangedNotificationResponse*>(
               &_NeighbourhoodChangedNotificationResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(NeighbourhoodChangedNotificationResponse* other);
  friend void swap(NeighbourhoodChangedNotificationResponse& a, NeighbourhoodChangedNotificationResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NeighbourhoodChangedNotificationResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NeighbourhoodChangedNotificationResponse& from);
  void MergeFrom(const NeighbourhoodChangedNotificationResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NeighbourhoodChangedNotificationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsNeighbourhoodChangedNotificationResponseImpl();
};
// -------------------------------------------------------------------

class RemoteNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeRequest) */ {
 public:
  RemoteNodeRequest();
  virtual ~RemoteNodeRequest();

  RemoteNodeRequest(const RemoteNodeRequest& from);

  inline RemoteNodeRequest& operator=(const RemoteNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoteNodeRequest(RemoteNodeRequest&& from) noexcept
    : RemoteNodeRequest() {
    *this = ::std::move(from);
  }

  inline RemoteNodeRequest& operator=(RemoteNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeRequest& default_instance();

  enum RemoteNodeRequestTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODEREQUESTTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RemoteNodeRequest*>(
               &_RemoteNodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RemoteNodeRequest* other);
  friend void swap(RemoteNodeRequest& a, RemoteNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoteNodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoteNodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoteNodeRequest& from);
  void MergeFrom(const RemoteNodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoteNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.BuildNetworkRequest accept_colleague = 1;
  bool has_accept_colleague() const;
  void clear_accept_colleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkRequest& accept_colleague() const;
  ::iop::locnet::BuildNetworkRequest* release_accept_colleague();
  ::iop::locnet::BuildNetworkRequest* mutable_accept_colleague();
  void set_allocated_accept_colleague(::iop::locnet::BuildNetworkRequest* accept_colleague);

  // .iop.locnet.BuildNetworkRequest renew_colleague = 2;
  bool has_renew_colleague() const;
  void clear_renew_colleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkRequest& renew_colleague() const;
  ::iop::locnet::BuildNetworkRequest* release_renew_colleague();
  ::iop::locnet::BuildNetworkRequest* mutable_renew_colleague();
  void set_allocated_renew_colleague(::iop::locnet::BuildNetworkRequest* renew_colleague);

  // .iop.locnet.BuildNetworkRequest accept_neighbour = 3;
  bool has_accept_neighbour() const;
  void clear_accept_neighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkRequest& accept_neighbour() const;
  ::iop::locnet::BuildNetworkRequest* release_accept_neighbour();
  ::iop::locnet::BuildNetworkRequest* mutable_accept_neighbour();
  void set_allocated_accept_neighbour(::iop::locnet::BuildNetworkRequest* accept_neighbour);

  // .iop.locnet.BuildNetworkRequest renew_neighbour = 4;
  bool has_renew_neighbour() const;
  void clear_renew_neighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkRequest& renew_neighbour() const;
  ::iop::locnet::BuildNetworkRequest* release_renew_neighbour();
  ::iop::locnet::BuildNetworkRequest* mutable_renew_neighbour();
  void set_allocated_renew_neighbour(::iop::locnet::BuildNetworkRequest* renew_neighbour);

  // .iop.locnet.GetNodeCountRequest get_node_count = 5;
  bool has_get_node_count() const;
  void clear_get_node_count();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountRequest& get_node_count() const;
  ::iop::locnet::GetNodeCountRequest* release_get_node_count();
  ::iop::locnet::GetNodeCountRequest* mutable_get_node_count();
  void set_allocated_get_node_count(::iop::locnet::GetNodeCountRequest* get_node_count);

  // .iop.locnet.GetRandomNodesRequest get_random_nodes = 6;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesRequest& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesRequest* release_get_random_nodes();
  ::iop::locnet::GetRandomNodesRequest* mutable_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes);

  // .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 7;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes);

  // .iop.locnet.GetNodeInfoRequest get_node_info = 8;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  RemoteNodeRequestTypeCase RemoteNodeRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeRequest)
 private:
  void set_has_accept_colleague();
  void set_has_renew_colleague();
  void set_has_accept_neighbour();
  void set_has_renew_neighbour();
  void set_has_get_node_count();
  void set_has_get_random_nodes();
  void set_has_get_closest_nodes();
  void set_has_get_node_info();

  inline bool has_RemoteNodeRequestType() const;
  void clear_RemoteNodeRequestType();
  inline void clear_has_RemoteNodeRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RemoteNodeRequestTypeUnion {
    RemoteNodeRequestTypeUnion() {}
    ::iop::locnet::BuildNetworkRequest* accept_colleague_;
    ::iop::locnet::BuildNetworkRequest* renew_colleague_;
    ::iop::locnet::BuildNetworkRequest* accept_neighbour_;
    ::iop::locnet::BuildNetworkRequest* renew_neighbour_;
    ::iop::locnet::GetNodeCountRequest* get_node_count_;
    ::iop::locnet::GetRandomNodesRequest* get_random_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes_;
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
  } RemoteNodeRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsRemoteNodeRequestImpl();
};
// -------------------------------------------------------------------

class RemoteNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeResponse) */ {
 public:
  RemoteNodeResponse();
  virtual ~RemoteNodeResponse();

  RemoteNodeResponse(const RemoteNodeResponse& from);

  inline RemoteNodeResponse& operator=(const RemoteNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoteNodeResponse(RemoteNodeResponse&& from) noexcept
    : RemoteNodeResponse() {
    *this = ::std::move(from);
  }

  inline RemoteNodeResponse& operator=(RemoteNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeResponse& default_instance();

  enum RemoteNodeResponseTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODERESPONSETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteNodeResponse* internal_default_instance() {
    return reinterpret_cast<const RemoteNodeResponse*>(
               &_RemoteNodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RemoteNodeResponse* other);
  friend void swap(RemoteNodeResponse& a, RemoteNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoteNodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoteNodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoteNodeResponse& from);
  void MergeFrom(const RemoteNodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoteNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.BuildNetworkResponse accept_colleague = 1;
  bool has_accept_colleague() const;
  void clear_accept_colleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkResponse& accept_colleague() const;
  ::iop::locnet::BuildNetworkResponse* release_accept_colleague();
  ::iop::locnet::BuildNetworkResponse* mutable_accept_colleague();
  void set_allocated_accept_colleague(::iop::locnet::BuildNetworkResponse* accept_colleague);

  // .iop.locnet.BuildNetworkResponse renew_colleague = 2;
  bool has_renew_colleague() const;
  void clear_renew_colleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkResponse& renew_colleague() const;
  ::iop::locnet::BuildNetworkResponse* release_renew_colleague();
  ::iop::locnet::BuildNetworkResponse* mutable_renew_colleague();
  void set_allocated_renew_colleague(::iop::locnet::BuildNetworkResponse* renew_colleague);

  // .iop.locnet.BuildNetworkResponse accept_neighbour = 3;
  bool has_accept_neighbour() const;
  void clear_accept_neighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkResponse& accept_neighbour() const;
  ::iop::locnet::BuildNetworkResponse* release_accept_neighbour();
  ::iop::locnet::BuildNetworkResponse* mutable_accept_neighbour();
  void set_allocated_accept_neighbour(::iop::locnet::BuildNetworkResponse* accept_neighbour);

  // .iop.locnet.BuildNetworkResponse renew_neighbour = 4;
  bool has_renew_neighbour() const;
  void clear_renew_neighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkResponse& renew_neighbour() const;
  ::iop::locnet::BuildNetworkResponse* release_renew_neighbour();
  ::iop::locnet::BuildNetworkResponse* mutable_renew_neighbour();
  void set_allocated_renew_neighbour(::iop::locnet::BuildNetworkResponse* renew_neighbour);

  // .iop.locnet.GetNodeCountResponse get_node_count = 5;
  bool has_get_node_count() const;
  void clear_get_node_count();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountResponse& get_node_count() const;
  ::iop::locnet::GetNodeCountResponse* release_get_node_count();
  ::iop::locnet::GetNodeCountResponse* mutable_get_node_count();
  void set_allocated_get_node_count(::iop::locnet::GetNodeCountResponse* get_node_count);

  // .iop.locnet.GetRandomNodesResponse get_random_nodes = 6;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesResponse& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesResponse* release_get_random_nodes();
  ::iop::locnet::GetRandomNodesResponse* mutable_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes);

  // .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 7;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes);

  // .iop.locnet.GetNodeInfoResponse get_node_info = 8;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  RemoteNodeResponseTypeCase RemoteNodeResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeResponse)
 private:
  void set_has_accept_colleague();
  void set_has_renew_colleague();
  void set_has_accept_neighbour();
  void set_has_renew_neighbour();
  void set_has_get_node_count();
  void set_has_get_random_nodes();
  void set_has_get_closest_nodes();
  void set_has_get_node_info();

  inline bool has_RemoteNodeResponseType() const;
  void clear_RemoteNodeResponseType();
  inline void clear_has_RemoteNodeResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RemoteNodeResponseTypeUnion {
    RemoteNodeResponseTypeUnion() {}
    ::iop::locnet::BuildNetworkResponse* accept_colleague_;
    ::iop::locnet::BuildNetworkResponse* renew_colleague_;
    ::iop::locnet::BuildNetworkResponse* accept_neighbour_;
    ::iop::locnet::BuildNetworkResponse* renew_neighbour_;
    ::iop::locnet::GetNodeCountResponse* get_node_count_;
    ::iop::locnet::GetRandomNodesResponse* get_random_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes_;
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
  } RemoteNodeResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsRemoteNodeResponseImpl();
};
// -------------------------------------------------------------------

class BuildNetworkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkRequest) */ {
 public:
  BuildNetworkRequest();
  virtual ~BuildNetworkRequest();

  BuildNetworkRequest(const BuildNetworkRequest& from);

  inline BuildNetworkRequest& operator=(const BuildNetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuildNetworkRequest(BuildNetworkRequest&& from) noexcept
    : BuildNetworkRequest() {
    *this = ::std::move(from);
  }

  inline BuildNetworkRequest& operator=(BuildNetworkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildNetworkRequest* internal_default_instance() {
    return reinterpret_cast<const BuildNetworkRequest*>(
               &_BuildNetworkRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(BuildNetworkRequest* other);
  friend void swap(BuildNetworkRequest& a, BuildNetworkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildNetworkRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BuildNetworkRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuildNetworkRequest& from);
  void MergeFrom(const BuildNetworkRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuildNetworkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.NodeInfo requestor_node_info = 1;
  bool has_requestor_node_info() const;
  void clear_requestor_node_info();
  static const int kRequestorNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& requestor_node_info() const;
  ::iop::locnet::NodeInfo* release_requestor_node_info();
  ::iop::locnet::NodeInfo* mutable_requestor_node_info();
  void set_allocated_requestor_node_info(::iop::locnet::NodeInfo* requestor_node_info);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::NodeInfo* requestor_node_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsBuildNetworkRequestImpl();
};
// -------------------------------------------------------------------

class BuildNetworkResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkResponse) */ {
 public:
  BuildNetworkResponse();
  virtual ~BuildNetworkResponse();

  BuildNetworkResponse(const BuildNetworkResponse& from);

  inline BuildNetworkResponse& operator=(const BuildNetworkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuildNetworkResponse(BuildNetworkResponse&& from) noexcept
    : BuildNetworkResponse() {
    *this = ::std::move(from);
  }

  inline BuildNetworkResponse& operator=(BuildNetworkResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildNetworkResponse* internal_default_instance() {
    return reinterpret_cast<const BuildNetworkResponse*>(
               &_BuildNetworkResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(BuildNetworkResponse* other);
  friend void swap(BuildNetworkResponse& a, BuildNetworkResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildNetworkResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BuildNetworkResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuildNetworkResponse& from);
  void MergeFrom(const BuildNetworkResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuildNetworkResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes remote_ip_address = 3;
  void clear_remote_ip_address();
  static const int kRemoteIpAddressFieldNumber = 3;
  const ::std::string& remote_ip_address() const;
  void set_remote_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_ip_address(::std::string&& value);
  #endif
  void set_remote_ip_address(const char* value);
  void set_remote_ip_address(const void* value, size_t size);
  ::std::string* mutable_remote_ip_address();
  ::std::string* release_remote_ip_address();
  void set_allocated_remote_ip_address(::std::string* remote_ip_address);

  // .iop.locnet.NodeInfo acceptor_node_info = 2;
  bool has_acceptor_node_info() const;
  void clear_acceptor_node_info();
  static const int kAcceptorNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& acceptor_node_info() const;
  ::iop::locnet::NodeInfo* release_acceptor_node_info();
  ::iop::locnet::NodeInfo* mutable_acceptor_node_info();
  void set_allocated_acceptor_node_info(::iop::locnet::NodeInfo* acceptor_node_info);

  // bool accepted = 1;
  void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  bool accepted() const;
  void set_accepted(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr remote_ip_address_;
  ::iop::locnet::NodeInfo* acceptor_node_info_;
  bool accepted_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsBuildNetworkResponseImpl();
};
// -------------------------------------------------------------------

class GetNodeCountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountRequest) */ {
 public:
  GetNodeCountRequest();
  virtual ~GetNodeCountRequest();

  GetNodeCountRequest(const GetNodeCountRequest& from);

  inline GetNodeCountRequest& operator=(const GetNodeCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeCountRequest(GetNodeCountRequest&& from) noexcept
    : GetNodeCountRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeCountRequest& operator=(GetNodeCountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNodeCountRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeCountRequest*>(
               &_GetNodeCountRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(GetNodeCountRequest* other);
  friend void swap(GetNodeCountRequest& a, GetNodeCountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeCountRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeCountRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeCountRequest& from);
  void MergeFrom(const GetNodeCountRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeCountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNodeCountRequestImpl();
};
// -------------------------------------------------------------------

class GetNodeCountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountResponse) */ {
 public:
  GetNodeCountResponse();
  virtual ~GetNodeCountResponse();

  GetNodeCountResponse(const GetNodeCountResponse& from);

  inline GetNodeCountResponse& operator=(const GetNodeCountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeCountResponse(GetNodeCountResponse&& from) noexcept
    : GetNodeCountResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeCountResponse& operator=(GetNodeCountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNodeCountResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeCountResponse*>(
               &_GetNodeCountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(GetNodeCountResponse* other);
  friend void swap(GetNodeCountResponse& a, GetNodeCountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeCountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeCountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeCountResponse& from);
  void MergeFrom(const GetNodeCountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeCountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 node_count = 1;
  void clear_node_count();
  static const int kNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 node_count() const;
  void set_node_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 node_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNodeCountResponseImpl();
};
// -------------------------------------------------------------------

class GetRandomNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesRequest) */ {
 public:
  GetRandomNodesRequest();
  virtual ~GetRandomNodesRequest();

  GetRandomNodesRequest(const GetRandomNodesRequest& from);

  inline GetRandomNodesRequest& operator=(const GetRandomNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRandomNodesRequest(GetRandomNodesRequest&& from) noexcept
    : GetRandomNodesRequest() {
    *this = ::std::move(from);
  }

  inline GetRandomNodesRequest& operator=(GetRandomNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRandomNodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetRandomNodesRequest*>(
               &_GetRandomNodesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(GetRandomNodesRequest* other);
  friend void swap(GetRandomNodesRequest& a, GetRandomNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRandomNodesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRandomNodesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRandomNodesRequest& from);
  void MergeFrom(const GetRandomNodesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRandomNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 max_node_count = 1;
  void clear_max_node_count();
  static const int kMaxNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 max_node_count() const;
  void set_max_node_count(::google::protobuf::uint32 value);

  // bool include_neighbours = 2;
  void clear_include_neighbours();
  static const int kIncludeNeighboursFieldNumber = 2;
  bool include_neighbours() const;
  void set_include_neighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 max_node_count_;
  bool include_neighbours_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetRandomNodesRequestImpl();
};
// -------------------------------------------------------------------

class GetRandomNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesResponse) */ {
 public:
  GetRandomNodesResponse();
  virtual ~GetRandomNodesResponse();

  GetRandomNodesResponse(const GetRandomNodesResponse& from);

  inline GetRandomNodesResponse& operator=(const GetRandomNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRandomNodesResponse(GetRandomNodesResponse&& from) noexcept
    : GetRandomNodesResponse() {
    *this = ::std::move(from);
  }

  inline GetRandomNodesResponse& operator=(GetRandomNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRandomNodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetRandomNodesResponse*>(
               &_GetRandomNodesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetRandomNodesResponse* other);
  friend void swap(GetRandomNodesResponse& a, GetRandomNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRandomNodesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRandomNodesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRandomNodesResponse& from);
  void MergeFrom(const GetRandomNodesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRandomNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetRandomNodesResponseImpl();
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceRequest) */ {
 public:
  GetClosestNodesByDistanceRequest();
  virtual ~GetClosestNodesByDistanceRequest();

  GetClosestNodesByDistanceRequest(const GetClosestNodesByDistanceRequest& from);

  inline GetClosestNodesByDistanceRequest& operator=(const GetClosestNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClosestNodesByDistanceRequest(GetClosestNodesByDistanceRequest&& from) noexcept
    : GetClosestNodesByDistanceRequest() {
    *this = ::std::move(from);
  }

  inline GetClosestNodesByDistanceRequest& operator=(GetClosestNodesByDistanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClosestNodesByDistanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetClosestNodesByDistanceRequest*>(
               &_GetClosestNodesByDistanceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(GetClosestNodesByDistanceRequest* other);
  friend void swap(GetClosestNodesByDistanceRequest& a, GetClosestNodesByDistanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetClosestNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetClosestNodesByDistanceRequest& from);
  void MergeFrom(const GetClosestNodesByDistanceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetClosestNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* release_location();
  ::iop::locnet::GpsLocation* mutable_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // float max_radius_km = 2;
  void clear_max_radius_km();
  static const int kMaxRadiusKmFieldNumber = 2;
  float max_radius_km() const;
  void set_max_radius_km(float value);

  // uint32 max_node_count = 3;
  void clear_max_node_count();
  static const int kMaxNodeCountFieldNumber = 3;
  ::google::protobuf::uint32 max_node_count() const;
  void set_max_node_count(::google::protobuf::uint32 value);

  // bool include_neighbours = 4;
  void clear_include_neighbours();
  static const int kIncludeNeighboursFieldNumber = 4;
  bool include_neighbours() const;
  void set_include_neighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::GpsLocation* location_;
  float max_radius_km_;
  ::google::protobuf::uint32 max_node_count_;
  bool include_neighbours_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetClosestNodesByDistanceRequestImpl();
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceResponse) */ {
 public:
  GetClosestNodesByDistanceResponse();
  virtual ~GetClosestNodesByDistanceResponse();

  GetClosestNodesByDistanceResponse(const GetClosestNodesByDistanceResponse& from);

  inline GetClosestNodesByDistanceResponse& operator=(const GetClosestNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClosestNodesByDistanceResponse(GetClosestNodesByDistanceResponse&& from) noexcept
    : GetClosestNodesByDistanceResponse() {
    *this = ::std::move(from);
  }

  inline GetClosestNodesByDistanceResponse& operator=(GetClosestNodesByDistanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClosestNodesByDistanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetClosestNodesByDistanceResponse*>(
               &_GetClosestNodesByDistanceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(GetClosestNodesByDistanceResponse* other);
  friend void swap(GetClosestNodesByDistanceResponse& a, GetClosestNodesByDistanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetClosestNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetClosestNodesByDistanceResponse& from);
  void MergeFrom(const GetClosestNodesByDistanceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetClosestNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetClosestNodesByDistanceResponseImpl();
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientRequest) */ {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientRequest(ClientRequest&& from) noexcept
    : ClientRequest() {
    *this = ::std::move(from);
  }

  inline ClientRequest& operator=(ClientRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();

  enum ClientRequestTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    kGetRandomNodes = 5,
    CLIENTREQUESTTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientRequest* internal_default_instance() {
    return reinterpret_cast<const ClientRequest*>(
               &_ClientRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(ClientRequest* other);
  friend void swap(ClientRequest& a, ClientRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.GetNodeInfoRequest get_node_info = 1;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  // .iop.locnet.GetNeighbourNodesByDistanceClientRequest get_neighbour_nodes = 2;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* release_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* mutable_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceClientRequest* get_neighbour_nodes);

  // .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 3;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes);

  // .iop.locnet.ExploreNetworkNodesByDistanceRequest explore_nodes = 4;
  bool has_explore_nodes() const;
  void clear_explore_nodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& explore_nodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* release_explore_nodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* mutable_explore_nodes();
  void set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceRequest* explore_nodes);

  // .iop.locnet.GetRandomNodesRequest get_random_nodes = 5;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 5;
  const ::iop::locnet::GetRandomNodesRequest& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesRequest* release_get_random_nodes();
  ::iop::locnet::GetRandomNodesRequest* mutable_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes);

  ClientRequestTypeCase ClientRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientRequest)
 private:
  void set_has_get_node_info();
  void set_has_get_neighbour_nodes();
  void set_has_get_closest_nodes();
  void set_has_explore_nodes();
  void set_has_get_random_nodes();

  inline bool has_ClientRequestType() const;
  void clear_ClientRequestType();
  inline void clear_has_ClientRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ClientRequestTypeUnion {
    ClientRequestTypeUnion() {}
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
    ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* get_neighbour_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceRequest* explore_nodes_;
    ::iop::locnet::GetRandomNodesRequest* get_random_nodes_;
  } ClientRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsClientRequestImpl();
};
// -------------------------------------------------------------------

class ClientResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientResponse) */ {
 public:
  ClientResponse();
  virtual ~ClientResponse();

  ClientResponse(const ClientResponse& from);

  inline ClientResponse& operator=(const ClientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientResponse(ClientResponse&& from) noexcept
    : ClientResponse() {
    *this = ::std::move(from);
  }

  inline ClientResponse& operator=(ClientResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientResponse& default_instance();

  enum ClientResponseTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    kGetRandomNodes = 5,
    CLIENTRESPONSETYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientResponse* internal_default_instance() {
    return reinterpret_cast<const ClientResponse*>(
               &_ClientResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(ClientResponse* other);
  friend void swap(ClientResponse& a, ClientResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientResponse& from);
  void MergeFrom(const ClientResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.GetNodeInfoResponse get_node_info = 1;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  // .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 2;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes);

  // .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 3;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes);

  // .iop.locnet.ExploreNetworkNodesByDistanceResponse explore_nodes = 4;
  bool has_explore_nodes() const;
  void clear_explore_nodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& explore_nodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* release_explore_nodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* mutable_explore_nodes();
  void set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceResponse* explore_nodes);

  // .iop.locnet.GetRandomNodesResponse get_random_nodes = 5;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 5;
  const ::iop::locnet::GetRandomNodesResponse& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesResponse* release_get_random_nodes();
  ::iop::locnet::GetRandomNodesResponse* mutable_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes);

  ClientResponseTypeCase ClientResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientResponse)
 private:
  void set_has_get_node_info();
  void set_has_get_neighbour_nodes();
  void set_has_get_closest_nodes();
  void set_has_explore_nodes();
  void set_has_get_random_nodes();

  inline bool has_ClientResponseType() const;
  void clear_ClientResponseType();
  inline void clear_has_ClientResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ClientResponseTypeUnion {
    ClientResponseTypeUnion() {}
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceResponse* explore_nodes_;
    ::iop::locnet::GetRandomNodesResponse* get_random_nodes_;
  } ClientResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsClientResponseImpl();
};
// -------------------------------------------------------------------

class GetNodeInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoRequest) */ {
 public:
  GetNodeInfoRequest();
  virtual ~GetNodeInfoRequest();

  GetNodeInfoRequest(const GetNodeInfoRequest& from);

  inline GetNodeInfoRequest& operator=(const GetNodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeInfoRequest(GetNodeInfoRequest&& from) noexcept
    : GetNodeInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoRequest& operator=(GetNodeInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNodeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoRequest*>(
               &_GetNodeInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(GetNodeInfoRequest* other);
  friend void swap(GetNodeInfoRequest& a, GetNodeInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeInfoRequest& from);
  void MergeFrom(const GetNodeInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNodeInfoRequestImpl();
};
// -------------------------------------------------------------------

class GetNodeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoResponse) */ {
 public:
  GetNodeInfoResponse();
  virtual ~GetNodeInfoResponse();

  GetNodeInfoResponse(const GetNodeInfoResponse& from);

  inline GetNodeInfoResponse& operator=(const GetNodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeInfoResponse(GetNodeInfoResponse&& from) noexcept
    : GetNodeInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoResponse& operator=(GetNodeInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNodeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoResponse*>(
               &_GetNodeInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(GetNodeInfoResponse* other);
  friend void swap(GetNodeInfoResponse& a, GetNodeInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeInfoResponse& from);
  void MergeFrom(const GetNodeInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.NodeInfo node_info = 1;
  bool has_node_info() const;
  void clear_node_info();
  static const int kNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& node_info() const;
  ::iop::locnet::NodeInfo* release_node_info();
  ::iop::locnet::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::iop::locnet::NodeInfo* node_info);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::NodeInfo* node_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNodeInfoResponseImpl();
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceClientRequest) */ {
 public:
  GetNeighbourNodesByDistanceClientRequest();
  virtual ~GetNeighbourNodesByDistanceClientRequest();

  GetNeighbourNodesByDistanceClientRequest(const GetNeighbourNodesByDistanceClientRequest& from);

  inline GetNeighbourNodesByDistanceClientRequest& operator=(const GetNeighbourNodesByDistanceClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNeighbourNodesByDistanceClientRequest(GetNeighbourNodesByDistanceClientRequest&& from) noexcept
    : GetNeighbourNodesByDistanceClientRequest() {
    *this = ::std::move(from);
  }

  inline GetNeighbourNodesByDistanceClientRequest& operator=(GetNeighbourNodesByDistanceClientRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceClientRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNeighbourNodesByDistanceClientRequest* internal_default_instance() {
    return reinterpret_cast<const GetNeighbourNodesByDistanceClientRequest*>(
               &_GetNeighbourNodesByDistanceClientRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(GetNeighbourNodesByDistanceClientRequest* other);
  friend void swap(GetNeighbourNodesByDistanceClientRequest& a, GetNeighbourNodesByDistanceClientRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceClientRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNeighbourNodesByDistanceClientRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNeighbourNodesByDistanceClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsGetNeighbourNodesByDistanceClientRequestImpl();
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceRequest) */ {
 public:
  ExploreNetworkNodesByDistanceRequest();
  virtual ~ExploreNetworkNodesByDistanceRequest();

  ExploreNetworkNodesByDistanceRequest(const ExploreNetworkNodesByDistanceRequest& from);

  inline ExploreNetworkNodesByDistanceRequest& operator=(const ExploreNetworkNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExploreNetworkNodesByDistanceRequest(ExploreNetworkNodesByDistanceRequest&& from) noexcept
    : ExploreNetworkNodesByDistanceRequest() {
    *this = ::std::move(from);
  }

  inline ExploreNetworkNodesByDistanceRequest& operator=(ExploreNetworkNodesByDistanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExploreNetworkNodesByDistanceRequest* internal_default_instance() {
    return reinterpret_cast<const ExploreNetworkNodesByDistanceRequest*>(
               &_ExploreNetworkNodesByDistanceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(ExploreNetworkNodesByDistanceRequest* other);
  friend void swap(ExploreNetworkNodesByDistanceRequest& a, ExploreNetworkNodesByDistanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExploreNetworkNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExploreNetworkNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* release_location();
  ::iop::locnet::GpsLocation* mutable_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // uint32 target_node_count = 2;
  void clear_target_node_count();
  static const int kTargetNodeCountFieldNumber = 2;
  ::google::protobuf::uint32 target_node_count() const;
  void set_target_node_count(::google::protobuf::uint32 value);

  // uint32 max_node_hops = 3;
  void clear_max_node_hops();
  static const int kMaxNodeHopsFieldNumber = 3;
  ::google::protobuf::uint32 max_node_hops() const;
  void set_max_node_hops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iop::locnet::GpsLocation* location_;
  ::google::protobuf::uint32 target_node_count_;
  ::google::protobuf::uint32 max_node_hops_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsExploreNetworkNodesByDistanceRequestImpl();
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceResponse) */ {
 public:
  ExploreNetworkNodesByDistanceResponse();
  virtual ~ExploreNetworkNodesByDistanceResponse();

  ExploreNetworkNodesByDistanceResponse(const ExploreNetworkNodesByDistanceResponse& from);

  inline ExploreNetworkNodesByDistanceResponse& operator=(const ExploreNetworkNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExploreNetworkNodesByDistanceResponse(ExploreNetworkNodesByDistanceResponse&& from) noexcept
    : ExploreNetworkNodesByDistanceResponse() {
    *this = ::std::move(from);
  }

  inline ExploreNetworkNodesByDistanceResponse& operator=(ExploreNetworkNodesByDistanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExploreNetworkNodesByDistanceResponse* internal_default_instance() {
    return reinterpret_cast<const ExploreNetworkNodesByDistanceResponse*>(
               &_ExploreNetworkNodesByDistanceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(ExploreNetworkNodesByDistanceResponse* other);
  friend void swap(ExploreNetworkNodesByDistanceResponse& a, ExploreNetworkNodesByDistanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ExploreNetworkNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExploreNetworkNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo closest_nodes = 1;
  int closest_nodes_size() const;
  void clear_closest_nodes();
  static const int kClosestNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& closest_nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_closest_nodes(int index);
  ::iop::locnet::NodeInfo* add_closest_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_closest_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      closest_nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > closest_nodes_;
  mutable int _cached_size_;
  friend struct ::protobuf_IopLocNet_2eproto::TableStruct;
  friend void ::protobuf_IopLocNet_2eproto::InitDefaultsExploreNetworkNodesByDistanceResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServiceInfo

// string type = 1;
inline void ServiceInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServiceInfo::type() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.type)
  return type_.GetNoArena();
}
inline void ServiceInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.type)
}
#if LANG_CXX11
inline void ServiceInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.ServiceInfo.type)
}
#endif
inline void ServiceInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.ServiceInfo.type)
}
inline void ServiceInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.ServiceInfo.type)
}
inline ::std::string* ServiceInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.ServiceInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceInfo::release_type() {
  // @@protoc_insertion_point(field_release:iop.locnet.ServiceInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ServiceInfo.type)
}

// uint32 port = 2;
inline void ServiceInfo::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 ServiceInfo::port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.port)
  return port_;
}
inline void ServiceInfo::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.port)
}

// bytes service_data = 3;
inline void ServiceInfo::clear_service_data() {
  service_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServiceInfo::service_data() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.service_data)
  return service_data_.GetNoArena();
}
inline void ServiceInfo::set_service_data(const ::std::string& value) {
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.service_data)
}
#if LANG_CXX11
inline void ServiceInfo::set_service_data(::std::string&& value) {
  
  service_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.ServiceInfo.service_data)
}
#endif
inline void ServiceInfo::set_service_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.ServiceInfo.service_data)
}
inline void ServiceInfo::set_service_data(const void* value, size_t size) {
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.ServiceInfo.service_data)
}
inline ::std::string* ServiceInfo::mutable_service_data() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.ServiceInfo.service_data)
  return service_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceInfo::release_service_data() {
  // @@protoc_insertion_point(field_release:iop.locnet.ServiceInfo.service_data)
  
  return service_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_allocated_service_data(::std::string* service_data) {
  if (service_data != NULL) {
    
  } else {
    
  }
  service_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_data);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ServiceInfo.service_data)
}

// -------------------------------------------------------------------

// GpsLocation

// sfixed32 latitude = 1;
inline void GpsLocation::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::latitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.latitude)
  return latitude_;
}
inline void GpsLocation::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.latitude)
}

// sfixed32 longitude = 2;
inline void GpsLocation::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::longitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.longitude)
  return longitude_;
}
inline void GpsLocation::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.longitude)
}

// -------------------------------------------------------------------

// NodeContact

// bytes ip_address = 1;
inline void NodeContact::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeContact::ip_address() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.ip_address)
  return ip_address_.GetNoArena();
}
inline void NodeContact::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.ip_address)
}
#if LANG_CXX11
inline void NodeContact::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.NodeContact.ip_address)
}
#endif
inline void NodeContact::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeContact.ip_address)
}
inline void NodeContact::set_ip_address(const void* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeContact.ip_address)
}
inline ::std::string* NodeContact::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeContact.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeContact::release_ip_address() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeContact.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeContact::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeContact.ip_address)
}

// uint32 node_port = 2;
inline void NodeContact::clear_node_port() {
  node_port_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::node_port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.node_port)
  return node_port_;
}
inline void NodeContact::set_node_port(::google::protobuf::uint32 value) {
  
  node_port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.node_port)
}

// uint32 client_port = 3;
inline void NodeContact::clear_client_port() {
  client_port_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::client_port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.client_port)
  return client_port_;
}
inline void NodeContact::set_client_port(::google::protobuf::uint32 value) {
  
  client_port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.client_port)
}

// -------------------------------------------------------------------

// NodeInfo

// bytes node_id = 1;
inline void NodeInfo::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.node_id)
  return node_id_.GetNoArena();
}
inline void NodeInfo::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeInfo.node_id)
}
#if LANG_CXX11
inline void NodeInfo::set_node_id(::std::string&& value) {
  
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.NodeInfo.node_id)
}
#endif
inline void NodeInfo::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeInfo.node_id)
}
inline void NodeInfo::set_node_id(const void* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeInfo.node_id)
}
inline ::std::string* NodeInfo::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_node_id() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.node_id)
}

// .iop.locnet.NodeContact contact = 2;
inline bool NodeInfo::has_contact() const {
  return this != internal_default_instance() && contact_ != NULL;
}
inline void NodeInfo::clear_contact() {
  if (GetArenaNoVirtual() == NULL && contact_ != NULL) {
    delete contact_;
  }
  contact_ = NULL;
}
inline const ::iop::locnet::NodeContact& NodeInfo::contact() const {
  const ::iop::locnet::NodeContact* p = contact_;
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.contact)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::NodeContact*>(
      &::iop::locnet::_NodeContact_default_instance_);
}
inline ::iop::locnet::NodeContact* NodeInfo::release_contact() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.contact)
  
  ::iop::locnet::NodeContact* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline ::iop::locnet::NodeContact* NodeInfo::mutable_contact() {
  
  if (contact_ == NULL) {
    contact_ = new ::iop::locnet::NodeContact;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.contact)
  return contact_;
}
inline void NodeInfo::set_allocated_contact(::iop::locnet::NodeContact* contact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contact_;
  }
  if (contact) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.contact)
}

// .iop.locnet.GpsLocation location = 3;
inline bool NodeInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void NodeInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& NodeInfo::location() const {
  const ::iop::locnet::GpsLocation* p = location_;
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.location)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::GpsLocation*>(
      &::iop::locnet::_GpsLocation_default_instance_);
}
inline ::iop::locnet::GpsLocation* NodeInfo::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::iop::locnet::GpsLocation* NodeInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.location)
  return location_;
}
inline void NodeInfo::set_allocated_location(::iop::locnet::GpsLocation* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.location)
}

// repeated .iop.locnet.ServiceInfo services = 32;
inline int NodeInfo::services_size() const {
  return services_.size();
}
inline void NodeInfo::clear_services() {
  services_.Clear();
}
inline const ::iop::locnet::ServiceInfo& NodeInfo::services(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.services)
  return services_.Get(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.services)
  return services_.Mutable(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::add_services() {
  // @@protoc_insertion_point(field_add:iop.locnet.NodeInfo.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
NodeInfo::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NodeInfo.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
NodeInfo::services() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NodeInfo.services)
  return services_;
}

// -------------------------------------------------------------------

// MessageWithHeader

// fixed32 header = 1;
inline void MessageWithHeader::clear_header() {
  header_ = 0u;
}
inline ::google::protobuf::uint32 MessageWithHeader::header() const {
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.header)
  return header_;
}
inline void MessageWithHeader::set_header(::google::protobuf::uint32 value) {
  
  header_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.MessageWithHeader.header)
}

// .iop.locnet.Message body = 2;
inline bool MessageWithHeader::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void MessageWithHeader::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::iop::locnet::Message& MessageWithHeader::body() const {
  const ::iop::locnet::Message* p = body_;
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.body)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::Message*>(
      &::iop::locnet::_Message_default_instance_);
}
inline ::iop::locnet::Message* MessageWithHeader::release_body() {
  // @@protoc_insertion_point(field_release:iop.locnet.MessageWithHeader.body)
  
  ::iop::locnet::Message* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::iop::locnet::Message* MessageWithHeader::mutable_body() {
  
  if (body_ == NULL) {
    body_ = new ::iop::locnet::Message;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.MessageWithHeader.body)
  return body_;
}
inline void MessageWithHeader::set_allocated_body(::iop::locnet::Message* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.MessageWithHeader.body)
}

// -------------------------------------------------------------------

// Message

// uint32 id = 1;
inline void Message::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Message::id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.id)
  return id_;
}
inline void Message::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Message.id)
}

// .iop.locnet.Request request = 2;
inline bool Message::has_request() const {
  return MessageType_case() == kRequest;
}
inline void Message::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void Message::clear_request() {
  if (has_request()) {
    delete MessageType_.request_;
    clear_has_MessageType();
  }
}
inline ::iop::locnet::Request* Message::release_request() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.request)
  if (has_request()) {
    clear_has_MessageType();
      ::iop::locnet::Request* temp = MessageType_.request_;
    MessageType_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::Request& Message::request() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.request)
  return has_request()
      ? *MessageType_.request_
      : *reinterpret_cast< ::iop::locnet::Request*>(&::iop::locnet::_Request_default_instance_);
}
inline ::iop::locnet::Request* Message::mutable_request() {
  if (!has_request()) {
    clear_MessageType();
    set_has_request();
    MessageType_.request_ = new ::iop::locnet::Request;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.request)
  return MessageType_.request_;
}

// .iop.locnet.Response response = 3;
inline bool Message::has_response() const {
  return MessageType_case() == kResponse;
}
inline void Message::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void Message::clear_response() {
  if (has_response()) {
    delete MessageType_.response_;
    clear_has_MessageType();
  }
}
inline ::iop::locnet::Response* Message::release_response() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.response)
  if (has_response()) {
    clear_has_MessageType();
      ::iop::locnet::Response* temp = MessageType_.response_;
    MessageType_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::Response& Message::response() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.response)
  return has_response()
      ? *MessageType_.response_
      : *reinterpret_cast< ::iop::locnet::Response*>(&::iop::locnet::_Response_default_instance_);
}
inline ::iop::locnet::Response* Message::mutable_response() {
  if (!has_response()) {
    clear_MessageType();
    set_has_response();
    MessageType_.response_ = new ::iop::locnet::Response;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.response)
  return MessageType_.response_;
}

inline bool Message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void Message::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline Message::MessageTypeCase Message::MessageType_case() const {
  return Message::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// bytes version = 1;
inline void Request::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request::version() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.version)
  return version_.GetNoArena();
}
inline void Request::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Request.version)
}
#if LANG_CXX11
inline void Request::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.Request.version)
}
#endif
inline void Request::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Request.version)
}
inline void Request::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Request.version)
}
inline ::std::string* Request::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_version() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.version)
}

// .iop.locnet.LocalServiceRequest local_service = 2;
inline bool Request::has_local_service() const {
  return RequestType_case() == kLocalService;
}
inline void Request::set_has_local_service() {
  _oneof_case_[0] = kLocalService;
}
inline void Request::clear_local_service() {
  if (has_local_service()) {
    delete RequestType_.local_service_;
    clear_has_RequestType();
  }
}
inline ::iop::locnet::LocalServiceRequest* Request::release_local_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.local_service)
  if (has_local_service()) {
    clear_has_RequestType();
      ::iop::locnet::LocalServiceRequest* temp = RequestType_.local_service_;
    RequestType_.local_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::LocalServiceRequest& Request::local_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.local_service)
  return has_local_service()
      ? *RequestType_.local_service_
      : *reinterpret_cast< ::iop::locnet::LocalServiceRequest*>(&::iop::locnet::_LocalServiceRequest_default_instance_);
}
inline ::iop::locnet::LocalServiceRequest* Request::mutable_local_service() {
  if (!has_local_service()) {
    clear_RequestType();
    set_has_local_service();
    RequestType_.local_service_ = new ::iop::locnet::LocalServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.local_service)
  return RequestType_.local_service_;
}

// .iop.locnet.RemoteNodeRequest remote_node = 3;
inline bool Request::has_remote_node() const {
  return RequestType_case() == kRemoteNode;
}
inline void Request::set_has_remote_node() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Request::clear_remote_node() {
  if (has_remote_node()) {
    delete RequestType_.remote_node_;
    clear_has_RequestType();
  }
}
inline ::iop::locnet::RemoteNodeRequest* Request::release_remote_node() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.remote_node)
  if (has_remote_node()) {
    clear_has_RequestType();
      ::iop::locnet::RemoteNodeRequest* temp = RequestType_.remote_node_;
    RequestType_.remote_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::RemoteNodeRequest& Request::remote_node() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.remote_node)
  return has_remote_node()
      ? *RequestType_.remote_node_
      : *reinterpret_cast< ::iop::locnet::RemoteNodeRequest*>(&::iop::locnet::_RemoteNodeRequest_default_instance_);
}
inline ::iop::locnet::RemoteNodeRequest* Request::mutable_remote_node() {
  if (!has_remote_node()) {
    clear_RequestType();
    set_has_remote_node();
    RequestType_.remote_node_ = new ::iop::locnet::RemoteNodeRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.remote_node)
  return RequestType_.remote_node_;
}

// .iop.locnet.ClientRequest client = 4;
inline bool Request::has_client() const {
  return RequestType_case() == kClient;
}
inline void Request::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Request::clear_client() {
  if (has_client()) {
    delete RequestType_.client_;
    clear_has_RequestType();
  }
}
inline ::iop::locnet::ClientRequest* Request::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.client)
  if (has_client()) {
    clear_has_RequestType();
      ::iop::locnet::ClientRequest* temp = RequestType_.client_;
    RequestType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::ClientRequest& Request::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.client)
  return has_client()
      ? *RequestType_.client_
      : *reinterpret_cast< ::iop::locnet::ClientRequest*>(&::iop::locnet::_ClientRequest_default_instance_);
}
inline ::iop::locnet::ClientRequest* Request::mutable_client() {
  if (!has_client()) {
    clear_RequestType();
    set_has_client();
    RequestType_.client_ = new ::iop::locnet::ClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.client)
  return RequestType_.client_;
}

inline bool Request::has_RequestType() const {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void Request::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::RequestType_case() const {
  return Request::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .iop.locnet.Status status = 1;
inline void Response::clear_status() {
  status_ = 0;
}
inline ::iop::locnet::Status Response::status() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.status)
  return static_cast< ::iop::locnet::Status >(status_);
}
inline void Response::set_status(::iop::locnet::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.status)
}

// sint64 timestamp = 2;
inline void Response::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Response::timestamp() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.timestamp)
  return timestamp_;
}
inline void Response::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.timestamp)
}

// string details = 3;
inline void Response::clear_details() {
  details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::details() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.details)
  return details_.GetNoArena();
}
inline void Response::set_details(const ::std::string& value) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Response.details)
}
#if LANG_CXX11
inline void Response::set_details(::std::string&& value) {
  
  details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.Response.details)
}
#endif
inline void Response::set_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Response.details)
}
inline void Response::set_details(const char* value, size_t size) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Response.details)
}
inline ::std::string* Response::mutable_details() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.details)
  return details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_details() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.details)
  
  return details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_details(::std::string* details) {
  if (details != NULL) {
    
  } else {
    
  }
  details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), details);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.details)
}

// .iop.locnet.LocalServiceResponse local_service = 4;
inline bool Response::has_local_service() const {
  return ResponseType_case() == kLocalService;
}
inline void Response::set_has_local_service() {
  _oneof_case_[0] = kLocalService;
}
inline void Response::clear_local_service() {
  if (has_local_service()) {
    delete ResponseType_.local_service_;
    clear_has_ResponseType();
  }
}
inline ::iop::locnet::LocalServiceResponse* Response::release_local_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.local_service)
  if (has_local_service()) {
    clear_has_ResponseType();
      ::iop::locnet::LocalServiceResponse* temp = ResponseType_.local_service_;
    ResponseType_.local_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::LocalServiceResponse& Response::local_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.local_service)
  return has_local_service()
      ? *ResponseType_.local_service_
      : *reinterpret_cast< ::iop::locnet::LocalServiceResponse*>(&::iop::locnet::_LocalServiceResponse_default_instance_);
}
inline ::iop::locnet::LocalServiceResponse* Response::mutable_local_service() {
  if (!has_local_service()) {
    clear_ResponseType();
    set_has_local_service();
    ResponseType_.local_service_ = new ::iop::locnet::LocalServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.local_service)
  return ResponseType_.local_service_;
}

// .iop.locnet.RemoteNodeResponse remote_node = 5;
inline bool Response::has_remote_node() const {
  return ResponseType_case() == kRemoteNode;
}
inline void Response::set_has_remote_node() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Response::clear_remote_node() {
  if (has_remote_node()) {
    delete ResponseType_.remote_node_;
    clear_has_ResponseType();
  }
}
inline ::iop::locnet::RemoteNodeResponse* Response::release_remote_node() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.remote_node)
  if (has_remote_node()) {
    clear_has_ResponseType();
      ::iop::locnet::RemoteNodeResponse* temp = ResponseType_.remote_node_;
    ResponseType_.remote_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::RemoteNodeResponse& Response::remote_node() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.remote_node)
  return has_remote_node()
      ? *ResponseType_.remote_node_
      : *reinterpret_cast< ::iop::locnet::RemoteNodeResponse*>(&::iop::locnet::_RemoteNodeResponse_default_instance_);
}
inline ::iop::locnet::RemoteNodeResponse* Response::mutable_remote_node() {
  if (!has_remote_node()) {
    clear_ResponseType();
    set_has_remote_node();
    ResponseType_.remote_node_ = new ::iop::locnet::RemoteNodeResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.remote_node)
  return ResponseType_.remote_node_;
}

// .iop.locnet.ClientResponse client = 6;
inline bool Response::has_client() const {
  return ResponseType_case() == kClient;
}
inline void Response::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Response::clear_client() {
  if (has_client()) {
    delete ResponseType_.client_;
    clear_has_ResponseType();
  }
}
inline ::iop::locnet::ClientResponse* Response::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.client)
  if (has_client()) {
    clear_has_ResponseType();
      ::iop::locnet::ClientResponse* temp = ResponseType_.client_;
    ResponseType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::ClientResponse& Response::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.client)
  return has_client()
      ? *ResponseType_.client_
      : *reinterpret_cast< ::iop::locnet::ClientResponse*>(&::iop::locnet::_ClientResponse_default_instance_);
}
inline ::iop::locnet::ClientResponse* Response::mutable_client() {
  if (!has_client()) {
    clear_ResponseType();
    set_has_client();
    ResponseType_.client_ = new ::iop::locnet::ClientResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.client)
  return ResponseType_.client_;
}

inline bool Response::has_ResponseType() const {
  return ResponseType_case() != RESPONSETYPE_NOT_SET;
}
inline void Response::clear_has_ResponseType() {
  _oneof_case_[0] = RESPONSETYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::ResponseType_case() const {
  return Response::ResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceRequest

// .iop.locnet.RegisterServiceRequest register_service = 1;
inline bool LocalServiceRequest::has_register_service() const {
  return LocalServiceRequestType_case() == kRegisterService;
}
inline void LocalServiceRequest::set_has_register_service() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceRequest::clear_register_service() {
  if (has_register_service()) {
    delete LocalServiceRequestType_.register_service_;
    clear_has_LocalServiceRequestType();
  }
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::release_register_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.register_service)
  if (has_register_service()) {
    clear_has_LocalServiceRequestType();
      ::iop::locnet::RegisterServiceRequest* temp = LocalServiceRequestType_.register_service_;
    LocalServiceRequestType_.register_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::RegisterServiceRequest& LocalServiceRequest::register_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.register_service)
  return has_register_service()
      ? *LocalServiceRequestType_.register_service_
      : *reinterpret_cast< ::iop::locnet::RegisterServiceRequest*>(&::iop::locnet::_RegisterServiceRequest_default_instance_);
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::mutable_register_service() {
  if (!has_register_service()) {
    clear_LocalServiceRequestType();
    set_has_register_service();
    LocalServiceRequestType_.register_service_ = new ::iop::locnet::RegisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.register_service)
  return LocalServiceRequestType_.register_service_;
}

// .iop.locnet.DeregisterServiceRequest deregister_service = 2;
inline bool LocalServiceRequest::has_deregister_service() const {
  return LocalServiceRequestType_case() == kDeregisterService;
}
inline void LocalServiceRequest::set_has_deregister_service() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceRequest::clear_deregister_service() {
  if (has_deregister_service()) {
    delete LocalServiceRequestType_.deregister_service_;
    clear_has_LocalServiceRequestType();
  }
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::release_deregister_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.deregister_service)
  if (has_deregister_service()) {
    clear_has_LocalServiceRequestType();
      ::iop::locnet::DeregisterServiceRequest* temp = LocalServiceRequestType_.deregister_service_;
    LocalServiceRequestType_.deregister_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::DeregisterServiceRequest& LocalServiceRequest::deregister_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.deregister_service)
  return has_deregister_service()
      ? *LocalServiceRequestType_.deregister_service_
      : *reinterpret_cast< ::iop::locnet::DeregisterServiceRequest*>(&::iop::locnet::_DeregisterServiceRequest_default_instance_);
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::mutable_deregister_service() {
  if (!has_deregister_service()) {
    clear_LocalServiceRequestType();
    set_has_deregister_service();
    LocalServiceRequestType_.deregister_service_ = new ::iop::locnet::DeregisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.deregister_service)
  return LocalServiceRequestType_.deregister_service_;
}

// .iop.locnet.GetNeighbourNodesByDistanceLocalRequest get_neighbour_nodes = 3;
inline bool LocalServiceRequest::has_get_neighbour_nodes() const {
  return LocalServiceRequestType_case() == kGetNeighbourNodes;
}
inline void LocalServiceRequest::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceRequest::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete LocalServiceRequestType_.get_neighbour_nodes_;
    clear_has_LocalServiceRequestType();
  }
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_LocalServiceRequestType();
      ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* temp = LocalServiceRequestType_.get_neighbour_nodes_;
    LocalServiceRequestType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& LocalServiceRequest::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *LocalServiceRequestType_.get_neighbour_nodes_
      : *reinterpret_cast< ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest*>(&::iop::locnet::_GetNeighbourNodesByDistanceLocalRequest_default_instance_);
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_LocalServiceRequestType();
    set_has_get_neighbour_nodes();
    LocalServiceRequestType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  return LocalServiceRequestType_.get_neighbour_nodes_;
}

// .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhood_changed = 4;
inline bool LocalServiceRequest::has_neighbourhood_changed() const {
  return LocalServiceRequestType_case() == kNeighbourhoodChanged;
}
inline void LocalServiceRequest::set_has_neighbourhood_changed() {
  _oneof_case_[0] = kNeighbourhoodChanged;
}
inline void LocalServiceRequest::clear_neighbourhood_changed() {
  if (has_neighbourhood_changed()) {
    delete LocalServiceRequestType_.neighbourhood_changed_;
    clear_has_LocalServiceRequestType();
  }
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::release_neighbourhood_changed() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  if (has_neighbourhood_changed()) {
    clear_has_LocalServiceRequestType();
      ::iop::locnet::NeighbourhoodChangedNotificationRequest* temp = LocalServiceRequestType_.neighbourhood_changed_;
    LocalServiceRequestType_.neighbourhood_changed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::NeighbourhoodChangedNotificationRequest& LocalServiceRequest::neighbourhood_changed() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  return has_neighbourhood_changed()
      ? *LocalServiceRequestType_.neighbourhood_changed_
      : *reinterpret_cast< ::iop::locnet::NeighbourhoodChangedNotificationRequest*>(&::iop::locnet::_NeighbourhoodChangedNotificationRequest_default_instance_);
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::mutable_neighbourhood_changed() {
  if (!has_neighbourhood_changed()) {
    clear_LocalServiceRequestType();
    set_has_neighbourhood_changed();
    LocalServiceRequestType_.neighbourhood_changed_ = new ::iop::locnet::NeighbourhoodChangedNotificationRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  return LocalServiceRequestType_.neighbourhood_changed_;
}

// .iop.locnet.GetNodeInfoRequest get_node_info = 5;
inline bool LocalServiceRequest::has_get_node_info() const {
  return LocalServiceRequestType_case() == kGetNodeInfo;
}
inline void LocalServiceRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void LocalServiceRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete LocalServiceRequestType_.get_node_info_;
    clear_has_LocalServiceRequestType();
  }
}
inline ::iop::locnet::GetNodeInfoRequest* LocalServiceRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_LocalServiceRequestType();
      ::iop::locnet::GetNodeInfoRequest* temp = LocalServiceRequestType_.get_node_info_;
    LocalServiceRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoRequest& LocalServiceRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.get_node_info)
  return has_get_node_info()
      ? *LocalServiceRequestType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoRequest*>(&::iop::locnet::_GetNodeInfoRequest_default_instance_);
}
inline ::iop::locnet::GetNodeInfoRequest* LocalServiceRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_LocalServiceRequestType();
    set_has_get_node_info();
    LocalServiceRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.get_node_info)
  return LocalServiceRequestType_.get_node_info_;
}

inline bool LocalServiceRequest::has_LocalServiceRequestType() const {
  return LocalServiceRequestType_case() != LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline void LocalServiceRequest::clear_has_LocalServiceRequestType() {
  _oneof_case_[0] = LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline LocalServiceRequest::LocalServiceRequestTypeCase LocalServiceRequest::LocalServiceRequestType_case() const {
  return LocalServiceRequest::LocalServiceRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceResponse

// .iop.locnet.RegisterServiceResponse register_service = 1;
inline bool LocalServiceResponse::has_register_service() const {
  return LocalServiceResponseType_case() == kRegisterService;
}
inline void LocalServiceResponse::set_has_register_service() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceResponse::clear_register_service() {
  if (has_register_service()) {
    delete LocalServiceResponseType_.register_service_;
    clear_has_LocalServiceResponseType();
  }
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::release_register_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.register_service)
  if (has_register_service()) {
    clear_has_LocalServiceResponseType();
      ::iop::locnet::RegisterServiceResponse* temp = LocalServiceResponseType_.register_service_;
    LocalServiceResponseType_.register_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::RegisterServiceResponse& LocalServiceResponse::register_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.register_service)
  return has_register_service()
      ? *LocalServiceResponseType_.register_service_
      : *reinterpret_cast< ::iop::locnet::RegisterServiceResponse*>(&::iop::locnet::_RegisterServiceResponse_default_instance_);
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::mutable_register_service() {
  if (!has_register_service()) {
    clear_LocalServiceResponseType();
    set_has_register_service();
    LocalServiceResponseType_.register_service_ = new ::iop::locnet::RegisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.register_service)
  return LocalServiceResponseType_.register_service_;
}

// .iop.locnet.DeregisterServiceResponse deregister_service = 2;
inline bool LocalServiceResponse::has_deregister_service() const {
  return LocalServiceResponseType_case() == kDeregisterService;
}
inline void LocalServiceResponse::set_has_deregister_service() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceResponse::clear_deregister_service() {
  if (has_deregister_service()) {
    delete LocalServiceResponseType_.deregister_service_;
    clear_has_LocalServiceResponseType();
  }
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::release_deregister_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.deregister_service)
  if (has_deregister_service()) {
    clear_has_LocalServiceResponseType();
      ::iop::locnet::DeregisterServiceResponse* temp = LocalServiceResponseType_.deregister_service_;
    LocalServiceResponseType_.deregister_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::DeregisterServiceResponse& LocalServiceResponse::deregister_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.deregister_service)
  return has_deregister_service()
      ? *LocalServiceResponseType_.deregister_service_
      : *reinterpret_cast< ::iop::locnet::DeregisterServiceResponse*>(&::iop::locnet::_DeregisterServiceResponse_default_instance_);
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::mutable_deregister_service() {
  if (!has_deregister_service()) {
    clear_LocalServiceResponseType();
    set_has_deregister_service();
    LocalServiceResponseType_.deregister_service_ = new ::iop::locnet::DeregisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.deregister_service)
  return LocalServiceResponseType_.deregister_service_;
}

// .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 3;
inline bool LocalServiceResponse::has_get_neighbour_nodes() const {
  return LocalServiceResponseType_case() == kGetNeighbourNodes;
}
inline void LocalServiceResponse::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceResponse::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete LocalServiceResponseType_.get_neighbour_nodes_;
    clear_has_LocalServiceResponseType();
  }
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_LocalServiceResponseType();
      ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = LocalServiceResponseType_.get_neighbour_nodes_;
    LocalServiceResponseType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNeighbourNodesByDistanceResponse& LocalServiceResponse::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *LocalServiceResponseType_.get_neighbour_nodes_
      : *reinterpret_cast< ::iop::locnet::GetNeighbourNodesByDistanceResponse*>(&::iop::locnet::_GetNeighbourNodesByDistanceResponse_default_instance_);
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_LocalServiceResponseType();
    set_has_get_neighbour_nodes();
    LocalServiceResponseType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  return LocalServiceResponseType_.get_neighbour_nodes_;
}

// .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhood_updated = 4;
inline bool LocalServiceResponse::has_neighbourhood_updated() const {
  return LocalServiceResponseType_case() == kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::set_has_neighbourhood_updated() {
  _oneof_case_[0] = kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::clear_neighbourhood_updated() {
  if (has_neighbourhood_updated()) {
    delete LocalServiceResponseType_.neighbourhood_updated_;
    clear_has_LocalServiceResponseType();
  }
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::release_neighbourhood_updated() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  if (has_neighbourhood_updated()) {
    clear_has_LocalServiceResponseType();
      ::iop::locnet::NeighbourhoodChangedNotificationResponse* temp = LocalServiceResponseType_.neighbourhood_updated_;
    LocalServiceResponseType_.neighbourhood_updated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::NeighbourhoodChangedNotificationResponse& LocalServiceResponse::neighbourhood_updated() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  return has_neighbourhood_updated()
      ? *LocalServiceResponseType_.neighbourhood_updated_
      : *reinterpret_cast< ::iop::locnet::NeighbourhoodChangedNotificationResponse*>(&::iop::locnet::_NeighbourhoodChangedNotificationResponse_default_instance_);
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::mutable_neighbourhood_updated() {
  if (!has_neighbourhood_updated()) {
    clear_LocalServiceResponseType();
    set_has_neighbourhood_updated();
    LocalServiceResponseType_.neighbourhood_updated_ = new ::iop::locnet::NeighbourhoodChangedNotificationResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  return LocalServiceResponseType_.neighbourhood_updated_;
}

// .iop.locnet.GetNodeInfoResponse get_node_info = 5;
inline bool LocalServiceResponse::has_get_node_info() const {
  return LocalServiceResponseType_case() == kGetNodeInfo;
}
inline void LocalServiceResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void LocalServiceResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete LocalServiceResponseType_.get_node_info_;
    clear_has_LocalServiceResponseType();
  }
}
inline ::iop::locnet::GetNodeInfoResponse* LocalServiceResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_LocalServiceResponseType();
      ::iop::locnet::GetNodeInfoResponse* temp = LocalServiceResponseType_.get_node_info_;
    LocalServiceResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoResponse& LocalServiceResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.get_node_info)
  return has_get_node_info()
      ? *LocalServiceResponseType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoResponse*>(&::iop::locnet::_GetNodeInfoResponse_default_instance_);
}
inline ::iop::locnet::GetNodeInfoResponse* LocalServiceResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_LocalServiceResponseType();
    set_has_get_node_info();
    LocalServiceResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.get_node_info)
  return LocalServiceResponseType_.get_node_info_;
}

inline bool LocalServiceResponse::has_LocalServiceResponseType() const {
  return LocalServiceResponseType_case() != LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline void LocalServiceResponse::clear_has_LocalServiceResponseType() {
  _oneof_case_[0] = LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline LocalServiceResponse::LocalServiceResponseTypeCase LocalServiceResponse::LocalServiceResponseType_case() const {
  return LocalServiceResponse::LocalServiceResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterServiceRequest

// .iop.locnet.ServiceInfo service = 1;
inline bool RegisterServiceRequest::has_service() const {
  return this != internal_default_instance() && service_ != NULL;
}
inline void RegisterServiceRequest::clear_service() {
  if (GetArenaNoVirtual() == NULL && service_ != NULL) {
    delete service_;
  }
  service_ = NULL;
}
inline const ::iop::locnet::ServiceInfo& RegisterServiceRequest::service() const {
  const ::iop::locnet::ServiceInfo* p = service_;
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceRequest.service)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::ServiceInfo*>(
      &::iop::locnet::_ServiceInfo_default_instance_);
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::release_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceRequest.service)
  
  ::iop::locnet::ServiceInfo* temp = service_;
  service_ = NULL;
  return temp;
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::mutable_service() {
  
  if (service_ == NULL) {
    service_ = new ::iop::locnet::ServiceInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceRequest.service)
  return service_;
}
inline void RegisterServiceRequest::set_allocated_service(::iop::locnet::ServiceInfo* service) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete service_;
  }
  if (service) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      service = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceRequest.service)
}

// -------------------------------------------------------------------

// RegisterServiceResponse

// .iop.locnet.GpsLocation location = 1;
inline bool RegisterServiceResponse::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void RegisterServiceResponse::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& RegisterServiceResponse::location() const {
  const ::iop::locnet::GpsLocation* p = location_;
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceResponse.location)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::GpsLocation*>(
      &::iop::locnet::_GpsLocation_default_instance_);
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceResponse.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceResponse.location)
  return location_;
}
inline void RegisterServiceResponse::set_allocated_location(::iop::locnet::GpsLocation* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceResponse.location)
}

// -------------------------------------------------------------------

// DeregisterServiceRequest

// string service_type = 1;
inline void DeregisterServiceRequest::clear_service_type() {
  service_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeregisterServiceRequest::service_type() const {
  // @@protoc_insertion_point(field_get:iop.locnet.DeregisterServiceRequest.service_type)
  return service_type_.GetNoArena();
}
inline void DeregisterServiceRequest::set_service_type(const ::std::string& value) {
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.DeregisterServiceRequest.service_type)
}
#if LANG_CXX11
inline void DeregisterServiceRequest::set_service_type(::std::string&& value) {
  
  service_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.DeregisterServiceRequest.service_type)
}
#endif
inline void DeregisterServiceRequest::set_service_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.DeregisterServiceRequest.service_type)
}
inline void DeregisterServiceRequest::set_service_type(const char* value, size_t size) {
  
  service_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.DeregisterServiceRequest.service_type)
}
inline ::std::string* DeregisterServiceRequest::mutable_service_type() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.DeregisterServiceRequest.service_type)
  return service_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeregisterServiceRequest::release_service_type() {
  // @@protoc_insertion_point(field_release:iop.locnet.DeregisterServiceRequest.service_type)
  
  return service_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeregisterServiceRequest::set_allocated_service_type(::std::string* service_type) {
  if (service_type != NULL) {
    
  } else {
    
  }
  service_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_type);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.DeregisterServiceRequest.service_type)
}

// -------------------------------------------------------------------

// DeregisterServiceResponse

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceLocalRequest

// bool keep_alive_and_send_updates = 1;
inline void GetNeighbourNodesByDistanceLocalRequest::clear_keep_alive_and_send_updates() {
  keep_alive_and_send_updates_ = false;
}
inline bool GetNeighbourNodesByDistanceLocalRequest::keep_alive_and_send_updates() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keep_alive_and_send_updates)
  return keep_alive_and_send_updates_;
}
inline void GetNeighbourNodesByDistanceLocalRequest::set_keep_alive_and_send_updates(bool value) {
  
  keep_alive_and_send_updates_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keep_alive_and_send_updates)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetNeighbourNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetNeighbourNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetNeighbourNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetNeighbourNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetNeighbourNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChange

// .iop.locnet.NodeInfo added_node_info = 1;
inline bool NeighbourhoodChange::has_added_node_info() const {
  return ChangeType_case() == kAddedNodeInfo;
}
inline void NeighbourhoodChange::set_has_added_node_info() {
  _oneof_case_[0] = kAddedNodeInfo;
}
inline void NeighbourhoodChange::clear_added_node_info() {
  if (has_added_node_info()) {
    delete ChangeType_.added_node_info_;
    clear_has_ChangeType();
  }
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_added_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.added_node_info)
  if (has_added_node_info()) {
    clear_has_ChangeType();
      ::iop::locnet::NodeInfo* temp = ChangeType_.added_node_info_;
    ChangeType_.added_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::NodeInfo& NeighbourhoodChange::added_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.added_node_info)
  return has_added_node_info()
      ? *ChangeType_.added_node_info_
      : *reinterpret_cast< ::iop::locnet::NodeInfo*>(&::iop::locnet::_NodeInfo_default_instance_);
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_added_node_info() {
  if (!has_added_node_info()) {
    clear_ChangeType();
    set_has_added_node_info();
    ChangeType_.added_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.added_node_info)
  return ChangeType_.added_node_info_;
}

// .iop.locnet.NodeInfo updated_node_info = 2;
inline bool NeighbourhoodChange::has_updated_node_info() const {
  return ChangeType_case() == kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::set_has_updated_node_info() {
  _oneof_case_[0] = kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::clear_updated_node_info() {
  if (has_updated_node_info()) {
    delete ChangeType_.updated_node_info_;
    clear_has_ChangeType();
  }
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_updated_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.updated_node_info)
  if (has_updated_node_info()) {
    clear_has_ChangeType();
      ::iop::locnet::NodeInfo* temp = ChangeType_.updated_node_info_;
    ChangeType_.updated_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::NodeInfo& NeighbourhoodChange::updated_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.updated_node_info)
  return has_updated_node_info()
      ? *ChangeType_.updated_node_info_
      : *reinterpret_cast< ::iop::locnet::NodeInfo*>(&::iop::locnet::_NodeInfo_default_instance_);
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_updated_node_info() {
  if (!has_updated_node_info()) {
    clear_ChangeType();
    set_has_updated_node_info();
    ChangeType_.updated_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.updated_node_info)
  return ChangeType_.updated_node_info_;
}

// bytes removed_node_id = 3;
inline bool NeighbourhoodChange::has_removed_node_id() const {
  return ChangeType_case() == kRemovedNodeId;
}
inline void NeighbourhoodChange::set_has_removed_node_id() {
  _oneof_case_[0] = kRemovedNodeId;
}
inline void NeighbourhoodChange::clear_removed_node_id() {
  if (has_removed_node_id()) {
    ChangeType_.removed_node_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ChangeType();
  }
}
inline const ::std::string& NeighbourhoodChange::removed_node_id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (has_removed_node_id()) {
    return ChangeType_.removed_node_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void NeighbourhoodChange::set_removed_node_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removed_node_id)
}
#if LANG_CXX11
inline void NeighbourhoodChange::set_removed_node_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.NeighbourhoodChange.removed_node_id)
}
#endif
inline void NeighbourhoodChange::set_removed_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NeighbourhoodChange.removed_node_id)
}
inline void NeighbourhoodChange::set_removed_node_id(const void* value, size_t size) {
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NeighbourhoodChange.removed_node_id)
}
inline ::std::string* NeighbourhoodChange::mutable_removed_node_id() {
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.removed_node_id)
  return ChangeType_.removed_node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeighbourhoodChange::release_removed_node_id() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (has_removed_node_id()) {
    clear_has_ChangeType();
    return ChangeType_.removed_node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_removed_node_id(::std::string* removed_node_id) {
  if (!has_removed_node_id()) {
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_ChangeType();
  if (removed_node_id != NULL) {
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        removed_node_id);
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.removed_node_id)
}

inline bool NeighbourhoodChange::has_ChangeType() const {
  return ChangeType_case() != CHANGETYPE_NOT_SET;
}
inline void NeighbourhoodChange::clear_has_ChangeType() {
  _oneof_case_[0] = CHANGETYPE_NOT_SET;
}
inline NeighbourhoodChange::ChangeTypeCase NeighbourhoodChange::ChangeType_case() const {
  return NeighbourhoodChange::ChangeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationRequest

// repeated .iop.locnet.NeighbourhoodChange changes = 1;
inline int NeighbourhoodChangedNotificationRequest::changes_size() const {
  return changes_.size();
}
inline void NeighbourhoodChangedNotificationRequest::clear_changes() {
  changes_.Clear();
}
inline const ::iop::locnet::NeighbourhoodChange& NeighbourhoodChangedNotificationRequest::changes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Get(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Mutable(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::add_changes() {
  // @@protoc_insertion_point(field_add:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
NeighbourhoodChangedNotificationRequest::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return &changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
NeighbourhoodChangedNotificationRequest::changes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationResponse

// -------------------------------------------------------------------

// RemoteNodeRequest

// .iop.locnet.BuildNetworkRequest accept_colleague = 1;
inline bool RemoteNodeRequest::has_accept_colleague() const {
  return RemoteNodeRequestType_case() == kAcceptColleague;
}
inline void RemoteNodeRequest::set_has_accept_colleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeRequest::clear_accept_colleague() {
  if (has_accept_colleague()) {
    delete RemoteNodeRequestType_.accept_colleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_accept_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.accept_colleague)
  if (has_accept_colleague()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.accept_colleague_;
    RemoteNodeRequestType_.accept_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::accept_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.accept_colleague)
  return has_accept_colleague()
      ? *RemoteNodeRequestType_.accept_colleague_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkRequest*>(&::iop::locnet::_BuildNetworkRequest_default_instance_);
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_accept_colleague() {
  if (!has_accept_colleague()) {
    clear_RemoteNodeRequestType();
    set_has_accept_colleague();
    RemoteNodeRequestType_.accept_colleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.accept_colleague)
  return RemoteNodeRequestType_.accept_colleague_;
}

// .iop.locnet.BuildNetworkRequest renew_colleague = 2;
inline bool RemoteNodeRequest::has_renew_colleague() const {
  return RemoteNodeRequestType_case() == kRenewColleague;
}
inline void RemoteNodeRequest::set_has_renew_colleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeRequest::clear_renew_colleague() {
  if (has_renew_colleague()) {
    delete RemoteNodeRequestType_.renew_colleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renew_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renew_colleague)
  if (has_renew_colleague()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renew_colleague_;
    RemoteNodeRequestType_.renew_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renew_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renew_colleague)
  return has_renew_colleague()
      ? *RemoteNodeRequestType_.renew_colleague_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkRequest*>(&::iop::locnet::_BuildNetworkRequest_default_instance_);
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renew_colleague() {
  if (!has_renew_colleague()) {
    clear_RemoteNodeRequestType();
    set_has_renew_colleague();
    RemoteNodeRequestType_.renew_colleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renew_colleague)
  return RemoteNodeRequestType_.renew_colleague_;
}

// .iop.locnet.BuildNetworkRequest accept_neighbour = 3;
inline bool RemoteNodeRequest::has_accept_neighbour() const {
  return RemoteNodeRequestType_case() == kAcceptNeighbour;
}
inline void RemoteNodeRequest::set_has_accept_neighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeRequest::clear_accept_neighbour() {
  if (has_accept_neighbour()) {
    delete RemoteNodeRequestType_.accept_neighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_accept_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.accept_neighbour)
  if (has_accept_neighbour()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.accept_neighbour_;
    RemoteNodeRequestType_.accept_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::accept_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.accept_neighbour)
  return has_accept_neighbour()
      ? *RemoteNodeRequestType_.accept_neighbour_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkRequest*>(&::iop::locnet::_BuildNetworkRequest_default_instance_);
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_accept_neighbour() {
  if (!has_accept_neighbour()) {
    clear_RemoteNodeRequestType();
    set_has_accept_neighbour();
    RemoteNodeRequestType_.accept_neighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.accept_neighbour)
  return RemoteNodeRequestType_.accept_neighbour_;
}

// .iop.locnet.BuildNetworkRequest renew_neighbour = 4;
inline bool RemoteNodeRequest::has_renew_neighbour() const {
  return RemoteNodeRequestType_case() == kRenewNeighbour;
}
inline void RemoteNodeRequest::set_has_renew_neighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeRequest::clear_renew_neighbour() {
  if (has_renew_neighbour()) {
    delete RemoteNodeRequestType_.renew_neighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renew_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renew_neighbour)
  if (has_renew_neighbour()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renew_neighbour_;
    RemoteNodeRequestType_.renew_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renew_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renew_neighbour)
  return has_renew_neighbour()
      ? *RemoteNodeRequestType_.renew_neighbour_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkRequest*>(&::iop::locnet::_BuildNetworkRequest_default_instance_);
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renew_neighbour() {
  if (!has_renew_neighbour()) {
    clear_RemoteNodeRequestType();
    set_has_renew_neighbour();
    RemoteNodeRequestType_.renew_neighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renew_neighbour)
  return RemoteNodeRequestType_.renew_neighbour_;
}

// .iop.locnet.GetNodeCountRequest get_node_count = 5;
inline bool RemoteNodeRequest::has_get_node_count() const {
  return RemoteNodeRequestType_case() == kGetNodeCount;
}
inline void RemoteNodeRequest::set_has_get_node_count() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeRequest::clear_get_node_count() {
  if (has_get_node_count()) {
    delete RemoteNodeRequestType_.get_node_count_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::release_get_node_count() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_node_count)
  if (has_get_node_count()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::GetNodeCountRequest* temp = RemoteNodeRequestType_.get_node_count_;
    RemoteNodeRequestType_.get_node_count_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeCountRequest& RemoteNodeRequest::get_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_node_count)
  return has_get_node_count()
      ? *RemoteNodeRequestType_.get_node_count_
      : *reinterpret_cast< ::iop::locnet::GetNodeCountRequest*>(&::iop::locnet::_GetNodeCountRequest_default_instance_);
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::mutable_get_node_count() {
  if (!has_get_node_count()) {
    clear_RemoteNodeRequestType();
    set_has_get_node_count();
    RemoteNodeRequestType_.get_node_count_ = new ::iop::locnet::GetNodeCountRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_node_count)
  return RemoteNodeRequestType_.get_node_count_;
}

// .iop.locnet.GetRandomNodesRequest get_random_nodes = 6;
inline bool RemoteNodeRequest::has_get_random_nodes() const {
  return RemoteNodeRequestType_case() == kGetRandomNodes;
}
inline void RemoteNodeRequest::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeRequest::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete RemoteNodeRequestType_.get_random_nodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::GetRandomNodesRequest* temp = RemoteNodeRequestType_.get_random_nodes_;
    RemoteNodeRequestType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetRandomNodesRequest& RemoteNodeRequest::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_random_nodes)
  return has_get_random_nodes()
      ? *RemoteNodeRequestType_.get_random_nodes_
      : *reinterpret_cast< ::iop::locnet::GetRandomNodesRequest*>(&::iop::locnet::_GetRandomNodesRequest_default_instance_);
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_RemoteNodeRequestType();
    set_has_get_random_nodes();
    RemoteNodeRequestType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_random_nodes)
  return RemoteNodeRequestType_.get_random_nodes_;
}

// .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 7;
inline bool RemoteNodeRequest::has_get_closest_nodes() const {
  return RemoteNodeRequestType_case() == kGetClosestNodes;
}
inline void RemoteNodeRequest::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeRequest::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete RemoteNodeRequestType_.get_closest_nodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::GetClosestNodesByDistanceRequest* temp = RemoteNodeRequestType_.get_closest_nodes_;
    RemoteNodeRequestType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetClosestNodesByDistanceRequest& RemoteNodeRequest::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  return has_get_closest_nodes()
      ? *RemoteNodeRequestType_.get_closest_nodes_
      : *reinterpret_cast< ::iop::locnet::GetClosestNodesByDistanceRequest*>(&::iop::locnet::_GetClosestNodesByDistanceRequest_default_instance_);
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_RemoteNodeRequestType();
    set_has_get_closest_nodes();
    RemoteNodeRequestType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  return RemoteNodeRequestType_.get_closest_nodes_;
}

// .iop.locnet.GetNodeInfoRequest get_node_info = 8;
inline bool RemoteNodeRequest::has_get_node_info() const {
  return RemoteNodeRequestType_case() == kGetNodeInfo;
}
inline void RemoteNodeRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete RemoteNodeRequestType_.get_node_info_;
    clear_has_RemoteNodeRequestType();
  }
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_RemoteNodeRequestType();
      ::iop::locnet::GetNodeInfoRequest* temp = RemoteNodeRequestType_.get_node_info_;
    RemoteNodeRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoRequest& RemoteNodeRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_node_info)
  return has_get_node_info()
      ? *RemoteNodeRequestType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoRequest*>(&::iop::locnet::_GetNodeInfoRequest_default_instance_);
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_RemoteNodeRequestType();
    set_has_get_node_info();
    RemoteNodeRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_node_info)
  return RemoteNodeRequestType_.get_node_info_;
}

inline bool RemoteNodeRequest::has_RemoteNodeRequestType() const {
  return RemoteNodeRequestType_case() != REMOTENODEREQUESTTYPE_NOT_SET;
}
inline void RemoteNodeRequest::clear_has_RemoteNodeRequestType() {
  _oneof_case_[0] = REMOTENODEREQUESTTYPE_NOT_SET;
}
inline RemoteNodeRequest::RemoteNodeRequestTypeCase RemoteNodeRequest::RemoteNodeRequestType_case() const {
  return RemoteNodeRequest::RemoteNodeRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteNodeResponse

// .iop.locnet.BuildNetworkResponse accept_colleague = 1;
inline bool RemoteNodeResponse::has_accept_colleague() const {
  return RemoteNodeResponseType_case() == kAcceptColleague;
}
inline void RemoteNodeResponse::set_has_accept_colleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeResponse::clear_accept_colleague() {
  if (has_accept_colleague()) {
    delete RemoteNodeResponseType_.accept_colleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_accept_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.accept_colleague)
  if (has_accept_colleague()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.accept_colleague_;
    RemoteNodeResponseType_.accept_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::accept_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.accept_colleague)
  return has_accept_colleague()
      ? *RemoteNodeResponseType_.accept_colleague_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkResponse*>(&::iop::locnet::_BuildNetworkResponse_default_instance_);
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_accept_colleague() {
  if (!has_accept_colleague()) {
    clear_RemoteNodeResponseType();
    set_has_accept_colleague();
    RemoteNodeResponseType_.accept_colleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.accept_colleague)
  return RemoteNodeResponseType_.accept_colleague_;
}

// .iop.locnet.BuildNetworkResponse renew_colleague = 2;
inline bool RemoteNodeResponse::has_renew_colleague() const {
  return RemoteNodeResponseType_case() == kRenewColleague;
}
inline void RemoteNodeResponse::set_has_renew_colleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeResponse::clear_renew_colleague() {
  if (has_renew_colleague()) {
    delete RemoteNodeResponseType_.renew_colleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renew_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renew_colleague)
  if (has_renew_colleague()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renew_colleague_;
    RemoteNodeResponseType_.renew_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renew_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renew_colleague)
  return has_renew_colleague()
      ? *RemoteNodeResponseType_.renew_colleague_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkResponse*>(&::iop::locnet::_BuildNetworkResponse_default_instance_);
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renew_colleague() {
  if (!has_renew_colleague()) {
    clear_RemoteNodeResponseType();
    set_has_renew_colleague();
    RemoteNodeResponseType_.renew_colleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renew_colleague)
  return RemoteNodeResponseType_.renew_colleague_;
}

// .iop.locnet.BuildNetworkResponse accept_neighbour = 3;
inline bool RemoteNodeResponse::has_accept_neighbour() const {
  return RemoteNodeResponseType_case() == kAcceptNeighbour;
}
inline void RemoteNodeResponse::set_has_accept_neighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeResponse::clear_accept_neighbour() {
  if (has_accept_neighbour()) {
    delete RemoteNodeResponseType_.accept_neighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_accept_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.accept_neighbour)
  if (has_accept_neighbour()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.accept_neighbour_;
    RemoteNodeResponseType_.accept_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::accept_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.accept_neighbour)
  return has_accept_neighbour()
      ? *RemoteNodeResponseType_.accept_neighbour_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkResponse*>(&::iop::locnet::_BuildNetworkResponse_default_instance_);
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_accept_neighbour() {
  if (!has_accept_neighbour()) {
    clear_RemoteNodeResponseType();
    set_has_accept_neighbour();
    RemoteNodeResponseType_.accept_neighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.accept_neighbour)
  return RemoteNodeResponseType_.accept_neighbour_;
}

// .iop.locnet.BuildNetworkResponse renew_neighbour = 4;
inline bool RemoteNodeResponse::has_renew_neighbour() const {
  return RemoteNodeResponseType_case() == kRenewNeighbour;
}
inline void RemoteNodeResponse::set_has_renew_neighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeResponse::clear_renew_neighbour() {
  if (has_renew_neighbour()) {
    delete RemoteNodeResponseType_.renew_neighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renew_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renew_neighbour)
  if (has_renew_neighbour()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renew_neighbour_;
    RemoteNodeResponseType_.renew_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renew_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renew_neighbour)
  return has_renew_neighbour()
      ? *RemoteNodeResponseType_.renew_neighbour_
      : *reinterpret_cast< ::iop::locnet::BuildNetworkResponse*>(&::iop::locnet::_BuildNetworkResponse_default_instance_);
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renew_neighbour() {
  if (!has_renew_neighbour()) {
    clear_RemoteNodeResponseType();
    set_has_renew_neighbour();
    RemoteNodeResponseType_.renew_neighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renew_neighbour)
  return RemoteNodeResponseType_.renew_neighbour_;
}

// .iop.locnet.GetNodeCountResponse get_node_count = 5;
inline bool RemoteNodeResponse::has_get_node_count() const {
  return RemoteNodeResponseType_case() == kGetNodeCount;
}
inline void RemoteNodeResponse::set_has_get_node_count() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeResponse::clear_get_node_count() {
  if (has_get_node_count()) {
    delete RemoteNodeResponseType_.get_node_count_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::release_get_node_count() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_node_count)
  if (has_get_node_count()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::GetNodeCountResponse* temp = RemoteNodeResponseType_.get_node_count_;
    RemoteNodeResponseType_.get_node_count_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeCountResponse& RemoteNodeResponse::get_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_node_count)
  return has_get_node_count()
      ? *RemoteNodeResponseType_.get_node_count_
      : *reinterpret_cast< ::iop::locnet::GetNodeCountResponse*>(&::iop::locnet::_GetNodeCountResponse_default_instance_);
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::mutable_get_node_count() {
  if (!has_get_node_count()) {
    clear_RemoteNodeResponseType();
    set_has_get_node_count();
    RemoteNodeResponseType_.get_node_count_ = new ::iop::locnet::GetNodeCountResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_node_count)
  return RemoteNodeResponseType_.get_node_count_;
}

// .iop.locnet.GetRandomNodesResponse get_random_nodes = 6;
inline bool RemoteNodeResponse::has_get_random_nodes() const {
  return RemoteNodeResponseType_case() == kGetRandomNodes;
}
inline void RemoteNodeResponse::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeResponse::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete RemoteNodeResponseType_.get_random_nodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::GetRandomNodesResponse* temp = RemoteNodeResponseType_.get_random_nodes_;
    RemoteNodeResponseType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetRandomNodesResponse& RemoteNodeResponse::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_random_nodes)
  return has_get_random_nodes()
      ? *RemoteNodeResponseType_.get_random_nodes_
      : *reinterpret_cast< ::iop::locnet::GetRandomNodesResponse*>(&::iop::locnet::_GetRandomNodesResponse_default_instance_);
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_RemoteNodeResponseType();
    set_has_get_random_nodes();
    RemoteNodeResponseType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_random_nodes)
  return RemoteNodeResponseType_.get_random_nodes_;
}

// .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 7;
inline bool RemoteNodeResponse::has_get_closest_nodes() const {
  return RemoteNodeResponseType_case() == kGetClosestNodes;
}
inline void RemoteNodeResponse::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeResponse::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete RemoteNodeResponseType_.get_closest_nodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::GetClosestNodesByDistanceResponse* temp = RemoteNodeResponseType_.get_closest_nodes_;
    RemoteNodeResponseType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetClosestNodesByDistanceResponse& RemoteNodeResponse::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  return has_get_closest_nodes()
      ? *RemoteNodeResponseType_.get_closest_nodes_
      : *reinterpret_cast< ::iop::locnet::GetClosestNodesByDistanceResponse*>(&::iop::locnet::_GetClosestNodesByDistanceResponse_default_instance_);
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_RemoteNodeResponseType();
    set_has_get_closest_nodes();
    RemoteNodeResponseType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  return RemoteNodeResponseType_.get_closest_nodes_;
}

// .iop.locnet.GetNodeInfoResponse get_node_info = 8;
inline bool RemoteNodeResponse::has_get_node_info() const {
  return RemoteNodeResponseType_case() == kGetNodeInfo;
}
inline void RemoteNodeResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete RemoteNodeResponseType_.get_node_info_;
    clear_has_RemoteNodeResponseType();
  }
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_RemoteNodeResponseType();
      ::iop::locnet::GetNodeInfoResponse* temp = RemoteNodeResponseType_.get_node_info_;
    RemoteNodeResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoResponse& RemoteNodeResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_node_info)
  return has_get_node_info()
      ? *RemoteNodeResponseType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoResponse*>(&::iop::locnet::_GetNodeInfoResponse_default_instance_);
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_RemoteNodeResponseType();
    set_has_get_node_info();
    RemoteNodeResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_node_info)
  return RemoteNodeResponseType_.get_node_info_;
}

inline bool RemoteNodeResponse::has_RemoteNodeResponseType() const {
  return RemoteNodeResponseType_case() != REMOTENODERESPONSETYPE_NOT_SET;
}
inline void RemoteNodeResponse::clear_has_RemoteNodeResponseType() {
  _oneof_case_[0] = REMOTENODERESPONSETYPE_NOT_SET;
}
inline RemoteNodeResponse::RemoteNodeResponseTypeCase RemoteNodeResponse::RemoteNodeResponseType_case() const {
  return RemoteNodeResponse::RemoteNodeResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BuildNetworkRequest

// .iop.locnet.NodeInfo requestor_node_info = 1;
inline bool BuildNetworkRequest::has_requestor_node_info() const {
  return this != internal_default_instance() && requestor_node_info_ != NULL;
}
inline void BuildNetworkRequest::clear_requestor_node_info() {
  if (GetArenaNoVirtual() == NULL && requestor_node_info_ != NULL) {
    delete requestor_node_info_;
  }
  requestor_node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkRequest::requestor_node_info() const {
  const ::iop::locnet::NodeInfo* p = requestor_node_info_;
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkRequest.requestor_node_info)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::NodeInfo*>(
      &::iop::locnet::_NodeInfo_default_instance_);
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::release_requestor_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkRequest.requestor_node_info)
  
  ::iop::locnet::NodeInfo* temp = requestor_node_info_;
  requestor_node_info_ = NULL;
  return temp;
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::mutable_requestor_node_info() {
  
  if (requestor_node_info_ == NULL) {
    requestor_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkRequest.requestor_node_info)
  return requestor_node_info_;
}
inline void BuildNetworkRequest::set_allocated_requestor_node_info(::iop::locnet::NodeInfo* requestor_node_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete requestor_node_info_;
  }
  if (requestor_node_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      requestor_node_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, requestor_node_info, submessage_arena);
    }
    
  } else {
    
  }
  requestor_node_info_ = requestor_node_info;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkRequest.requestor_node_info)
}

// -------------------------------------------------------------------

// BuildNetworkResponse

// bool accepted = 1;
inline void BuildNetworkResponse::clear_accepted() {
  accepted_ = false;
}
inline bool BuildNetworkResponse::accepted() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.accepted)
  return accepted_;
}
inline void BuildNetworkResponse::set_accepted(bool value) {
  
  accepted_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.accepted)
}

// .iop.locnet.NodeInfo acceptor_node_info = 2;
inline bool BuildNetworkResponse::has_acceptor_node_info() const {
  return this != internal_default_instance() && acceptor_node_info_ != NULL;
}
inline void BuildNetworkResponse::clear_acceptor_node_info() {
  if (GetArenaNoVirtual() == NULL && acceptor_node_info_ != NULL) {
    delete acceptor_node_info_;
  }
  acceptor_node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkResponse::acceptor_node_info() const {
  const ::iop::locnet::NodeInfo* p = acceptor_node_info_;
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::NodeInfo*>(
      &::iop::locnet::_NodeInfo_default_instance_);
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::release_acceptor_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  
  ::iop::locnet::NodeInfo* temp = acceptor_node_info_;
  acceptor_node_info_ = NULL;
  return temp;
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::mutable_acceptor_node_info() {
  
  if (acceptor_node_info_ == NULL) {
    acceptor_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  return acceptor_node_info_;
}
inline void BuildNetworkResponse::set_allocated_acceptor_node_info(::iop::locnet::NodeInfo* acceptor_node_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acceptor_node_info_;
  }
  if (acceptor_node_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceptor_node_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceptor_node_info, submessage_arena);
    }
    
  } else {
    
  }
  acceptor_node_info_ = acceptor_node_info;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.acceptor_node_info)
}

// bytes remote_ip_address = 3;
inline void BuildNetworkResponse::clear_remote_ip_address() {
  remote_ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildNetworkResponse::remote_ip_address() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.remote_ip_address)
  return remote_ip_address_.GetNoArena();
}
inline void BuildNetworkResponse::set_remote_ip_address(const ::std::string& value) {
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
#if LANG_CXX11
inline void BuildNetworkResponse::set_remote_ip_address(::std::string&& value) {
  
  remote_ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
#endif
inline void BuildNetworkResponse::set_remote_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
inline void BuildNetworkResponse::set_remote_ip_address(const void* value, size_t size) {
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
inline ::std::string* BuildNetworkResponse::mutable_remote_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.remote_ip_address)
  return remote_ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildNetworkResponse::release_remote_ip_address() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.remote_ip_address)
  
  return remote_ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildNetworkResponse::set_allocated_remote_ip_address(::std::string* remote_ip_address) {
  if (remote_ip_address != NULL) {
    
  } else {
    
  }
  remote_ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip_address);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.remote_ip_address)
}

// -------------------------------------------------------------------

// GetNodeCountRequest

// -------------------------------------------------------------------

// GetNodeCountResponse

// uint32 node_count = 1;
inline void GetNodeCountResponse::clear_node_count() {
  node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeCountResponse::node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeCountResponse.node_count)
  return node_count_;
}
inline void GetNodeCountResponse::set_node_count(::google::protobuf::uint32 value) {
  
  node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNodeCountResponse.node_count)
}

// -------------------------------------------------------------------

// GetRandomNodesRequest

// uint32 max_node_count = 1;
inline void GetRandomNodesRequest::clear_max_node_count() {
  max_node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetRandomNodesRequest::max_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.max_node_count)
  return max_node_count_;
}
inline void GetRandomNodesRequest::set_max_node_count(::google::protobuf::uint32 value) {
  
  max_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.max_node_count)
}

// bool include_neighbours = 2;
inline void GetRandomNodesRequest::clear_include_neighbours() {
  include_neighbours_ = false;
}
inline bool GetRandomNodesRequest::include_neighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.include_neighbours)
  return include_neighbours_;
}
inline void GetRandomNodesRequest::set_include_neighbours(bool value) {
  
  include_neighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.include_neighbours)
}

// -------------------------------------------------------------------

// GetRandomNodesResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetRandomNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetRandomNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetRandomNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetRandomNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetRandomNodesResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetRandomNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceRequest

// .iop.locnet.GpsLocation location = 1;
inline bool GetClosestNodesByDistanceRequest::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void GetClosestNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& GetClosestNodesByDistanceRequest::location() const {
  const ::iop::locnet::GpsLocation* p = location_;
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::GpsLocation*>(
      &::iop::locnet::_GpsLocation_default_instance_);
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetClosestNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return location_;
}
inline void GetClosestNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetClosestNodesByDistanceRequest.location)
}

// float max_radius_km = 2;
inline void GetClosestNodesByDistanceRequest::clear_max_radius_km() {
  max_radius_km_ = 0;
}
inline float GetClosestNodesByDistanceRequest::max_radius_km() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.max_radius_km)
  return max_radius_km_;
}
inline void GetClosestNodesByDistanceRequest::set_max_radius_km(float value) {
  
  max_radius_km_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.max_radius_km)
}

// uint32 max_node_count = 3;
inline void GetClosestNodesByDistanceRequest::clear_max_node_count() {
  max_node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetClosestNodesByDistanceRequest::max_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.max_node_count)
  return max_node_count_;
}
inline void GetClosestNodesByDistanceRequest::set_max_node_count(::google::protobuf::uint32 value) {
  
  max_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.max_node_count)
}

// bool include_neighbours = 4;
inline void GetClosestNodesByDistanceRequest::clear_include_neighbours() {
  include_neighbours_ = false;
}
inline bool GetClosestNodesByDistanceRequest::include_neighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.include_neighbours)
  return include_neighbours_;
}
inline void GetClosestNodesByDistanceRequest::set_include_neighbours(bool value) {
  
  include_neighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.include_neighbours)
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetClosestNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetClosestNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetClosestNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetClosestNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetClosestNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// ClientRequest

// .iop.locnet.GetNodeInfoRequest get_node_info = 1;
inline bool ClientRequest::has_get_node_info() const {
  return ClientRequestType_case() == kGetNodeInfo;
}
inline void ClientRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete ClientRequestType_.get_node_info_;
    clear_has_ClientRequestType();
  }
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_ClientRequestType();
      ::iop::locnet::GetNodeInfoRequest* temp = ClientRequestType_.get_node_info_;
    ClientRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoRequest& ClientRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_node_info)
  return has_get_node_info()
      ? *ClientRequestType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoRequest*>(&::iop::locnet::_GetNodeInfoRequest_default_instance_);
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_ClientRequestType();
    set_has_get_node_info();
    ClientRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_node_info)
  return ClientRequestType_.get_node_info_;
}

// .iop.locnet.GetNeighbourNodesByDistanceClientRequest get_neighbour_nodes = 2;
inline bool ClientRequest::has_get_neighbour_nodes() const {
  return ClientRequestType_case() == kGetNeighbourNodes;
}
inline void ClientRequest::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientRequest::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete ClientRequestType_.get_neighbour_nodes_;
    clear_has_ClientRequestType();
  }
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_ClientRequestType();
      ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* temp = ClientRequestType_.get_neighbour_nodes_;
    ClientRequestType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& ClientRequest::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *ClientRequestType_.get_neighbour_nodes_
      : *reinterpret_cast< ::iop::locnet::GetNeighbourNodesByDistanceClientRequest*>(&::iop::locnet::_GetNeighbourNodesByDistanceClientRequest_default_instance_);
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_ClientRequestType();
    set_has_get_neighbour_nodes();
    ClientRequestType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_neighbour_nodes)
  return ClientRequestType_.get_neighbour_nodes_;
}

// .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 3;
inline bool ClientRequest::has_get_closest_nodes() const {
  return ClientRequestType_case() == kGetClosestNodes;
}
inline void ClientRequest::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientRequest::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete ClientRequestType_.get_closest_nodes_;
    clear_has_ClientRequestType();
  }
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_ClientRequestType();
      ::iop::locnet::GetClosestNodesByDistanceRequest* temp = ClientRequestType_.get_closest_nodes_;
    ClientRequestType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetClosestNodesByDistanceRequest& ClientRequest::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_closest_nodes)
  return has_get_closest_nodes()
      ? *ClientRequestType_.get_closest_nodes_
      : *reinterpret_cast< ::iop::locnet::GetClosestNodesByDistanceRequest*>(&::iop::locnet::_GetClosestNodesByDistanceRequest_default_instance_);
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_ClientRequestType();
    set_has_get_closest_nodes();
    ClientRequestType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_closest_nodes)
  return ClientRequestType_.get_closest_nodes_;
}

// .iop.locnet.ExploreNetworkNodesByDistanceRequest explore_nodes = 4;
inline bool ClientRequest::has_explore_nodes() const {
  return ClientRequestType_case() == kExploreNodes;
}
inline void ClientRequest::set_has_explore_nodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientRequest::clear_explore_nodes() {
  if (has_explore_nodes()) {
    delete ClientRequestType_.explore_nodes_;
    clear_has_ClientRequestType();
  }
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::release_explore_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.explore_nodes)
  if (has_explore_nodes()) {
    clear_has_ClientRequestType();
      ::iop::locnet::ExploreNetworkNodesByDistanceRequest* temp = ClientRequestType_.explore_nodes_;
    ClientRequestType_.explore_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& ClientRequest::explore_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.explore_nodes)
  return has_explore_nodes()
      ? *ClientRequestType_.explore_nodes_
      : *reinterpret_cast< ::iop::locnet::ExploreNetworkNodesByDistanceRequest*>(&::iop::locnet::_ExploreNetworkNodesByDistanceRequest_default_instance_);
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::mutable_explore_nodes() {
  if (!has_explore_nodes()) {
    clear_ClientRequestType();
    set_has_explore_nodes();
    ClientRequestType_.explore_nodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.explore_nodes)
  return ClientRequestType_.explore_nodes_;
}

// .iop.locnet.GetRandomNodesRequest get_random_nodes = 5;
inline bool ClientRequest::has_get_random_nodes() const {
  return ClientRequestType_case() == kGetRandomNodes;
}
inline void ClientRequest::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void ClientRequest::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete ClientRequestType_.get_random_nodes_;
    clear_has_ClientRequestType();
  }
}
inline ::iop::locnet::GetRandomNodesRequest* ClientRequest::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_ClientRequestType();
      ::iop::locnet::GetRandomNodesRequest* temp = ClientRequestType_.get_random_nodes_;
    ClientRequestType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetRandomNodesRequest& ClientRequest::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_random_nodes)
  return has_get_random_nodes()
      ? *ClientRequestType_.get_random_nodes_
      : *reinterpret_cast< ::iop::locnet::GetRandomNodesRequest*>(&::iop::locnet::_GetRandomNodesRequest_default_instance_);
}
inline ::iop::locnet::GetRandomNodesRequest* ClientRequest::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_ClientRequestType();
    set_has_get_random_nodes();
    ClientRequestType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_random_nodes)
  return ClientRequestType_.get_random_nodes_;
}

inline bool ClientRequest::has_ClientRequestType() const {
  return ClientRequestType_case() != CLIENTREQUESTTYPE_NOT_SET;
}
inline void ClientRequest::clear_has_ClientRequestType() {
  _oneof_case_[0] = CLIENTREQUESTTYPE_NOT_SET;
}
inline ClientRequest::ClientRequestTypeCase ClientRequest::ClientRequestType_case() const {
  return ClientRequest::ClientRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientResponse

// .iop.locnet.GetNodeInfoResponse get_node_info = 1;
inline bool ClientResponse::has_get_node_info() const {
  return ClientResponseType_case() == kGetNodeInfo;
}
inline void ClientResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete ClientResponseType_.get_node_info_;
    clear_has_ClientResponseType();
  }
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_ClientResponseType();
      ::iop::locnet::GetNodeInfoResponse* temp = ClientResponseType_.get_node_info_;
    ClientResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNodeInfoResponse& ClientResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_node_info)
  return has_get_node_info()
      ? *ClientResponseType_.get_node_info_
      : *reinterpret_cast< ::iop::locnet::GetNodeInfoResponse*>(&::iop::locnet::_GetNodeInfoResponse_default_instance_);
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_ClientResponseType();
    set_has_get_node_info();
    ClientResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_node_info)
  return ClientResponseType_.get_node_info_;
}

// .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 2;
inline bool ClientResponse::has_get_neighbour_nodes() const {
  return ClientResponseType_case() == kGetNeighbourNodes;
}
inline void ClientResponse::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientResponse::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete ClientResponseType_.get_neighbour_nodes_;
    clear_has_ClientResponseType();
  }
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_ClientResponseType();
      ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = ClientResponseType_.get_neighbour_nodes_;
    ClientResponseType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetNeighbourNodesByDistanceResponse& ClientResponse::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *ClientResponseType_.get_neighbour_nodes_
      : *reinterpret_cast< ::iop::locnet::GetNeighbourNodesByDistanceResponse*>(&::iop::locnet::_GetNeighbourNodesByDistanceResponse_default_instance_);
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_ClientResponseType();
    set_has_get_neighbour_nodes();
    ClientResponseType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_neighbour_nodes)
  return ClientResponseType_.get_neighbour_nodes_;
}

// .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 3;
inline bool ClientResponse::has_get_closest_nodes() const {
  return ClientResponseType_case() == kGetClosestNodes;
}
inline void ClientResponse::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientResponse::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete ClientResponseType_.get_closest_nodes_;
    clear_has_ClientResponseType();
  }
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_ClientResponseType();
      ::iop::locnet::GetClosestNodesByDistanceResponse* temp = ClientResponseType_.get_closest_nodes_;
    ClientResponseType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetClosestNodesByDistanceResponse& ClientResponse::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_closest_nodes)
  return has_get_closest_nodes()
      ? *ClientResponseType_.get_closest_nodes_
      : *reinterpret_cast< ::iop::locnet::GetClosestNodesByDistanceResponse*>(&::iop::locnet::_GetClosestNodesByDistanceResponse_default_instance_);
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_ClientResponseType();
    set_has_get_closest_nodes();
    ClientResponseType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_closest_nodes)
  return ClientResponseType_.get_closest_nodes_;
}

// .iop.locnet.ExploreNetworkNodesByDistanceResponse explore_nodes = 4;
inline bool ClientResponse::has_explore_nodes() const {
  return ClientResponseType_case() == kExploreNodes;
}
inline void ClientResponse::set_has_explore_nodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientResponse::clear_explore_nodes() {
  if (has_explore_nodes()) {
    delete ClientResponseType_.explore_nodes_;
    clear_has_ClientResponseType();
  }
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::release_explore_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.explore_nodes)
  if (has_explore_nodes()) {
    clear_has_ClientResponseType();
      ::iop::locnet::ExploreNetworkNodesByDistanceResponse* temp = ClientResponseType_.explore_nodes_;
    ClientResponseType_.explore_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& ClientResponse::explore_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.explore_nodes)
  return has_explore_nodes()
      ? *ClientResponseType_.explore_nodes_
      : *reinterpret_cast< ::iop::locnet::ExploreNetworkNodesByDistanceResponse*>(&::iop::locnet::_ExploreNetworkNodesByDistanceResponse_default_instance_);
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::mutable_explore_nodes() {
  if (!has_explore_nodes()) {
    clear_ClientResponseType();
    set_has_explore_nodes();
    ClientResponseType_.explore_nodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.explore_nodes)
  return ClientResponseType_.explore_nodes_;
}

// .iop.locnet.GetRandomNodesResponse get_random_nodes = 5;
inline bool ClientResponse::has_get_random_nodes() const {
  return ClientResponseType_case() == kGetRandomNodes;
}
inline void ClientResponse::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void ClientResponse::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete ClientResponseType_.get_random_nodes_;
    clear_has_ClientResponseType();
  }
}
inline ::iop::locnet::GetRandomNodesResponse* ClientResponse::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_ClientResponseType();
      ::iop::locnet::GetRandomNodesResponse* temp = ClientResponseType_.get_random_nodes_;
    ClientResponseType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iop::locnet::GetRandomNodesResponse& ClientResponse::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_random_nodes)
  return has_get_random_nodes()
      ? *ClientResponseType_.get_random_nodes_
      : *reinterpret_cast< ::iop::locnet::GetRandomNodesResponse*>(&::iop::locnet::_GetRandomNodesResponse_default_instance_);
}
inline ::iop::locnet::GetRandomNodesResponse* ClientResponse::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_ClientResponseType();
    set_has_get_random_nodes();
    ClientResponseType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_random_nodes)
  return ClientResponseType_.get_random_nodes_;
}

inline bool ClientResponse::has_ClientResponseType() const {
  return ClientResponseType_case() != CLIENTRESPONSETYPE_NOT_SET;
}
inline void ClientResponse::clear_has_ClientResponseType() {
  _oneof_case_[0] = CLIENTRESPONSETYPE_NOT_SET;
}
inline ClientResponse::ClientResponseTypeCase ClientResponse::ClientResponseType_case() const {
  return ClientResponse::ClientResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetNodeInfoRequest

// -------------------------------------------------------------------

// GetNodeInfoResponse

// .iop.locnet.NodeInfo node_info = 1;
inline bool GetNodeInfoResponse::has_node_info() const {
  return this != internal_default_instance() && node_info_ != NULL;
}
inline void GetNodeInfoResponse::clear_node_info() {
  if (GetArenaNoVirtual() == NULL && node_info_ != NULL) {
    delete node_info_;
  }
  node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& GetNodeInfoResponse::node_info() const {
  const ::iop::locnet::NodeInfo* p = node_info_;
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeInfoResponse.node_info)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::NodeInfo*>(
      &::iop::locnet::_NodeInfo_default_instance_);
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::release_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetNodeInfoResponse.node_info)
  
  ::iop::locnet::NodeInfo* temp = node_info_;
  node_info_ = NULL;
  return temp;
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::mutable_node_info() {
  
  if (node_info_ == NULL) {
    node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNodeInfoResponse.node_info)
  return node_info_;
}
inline void GetNodeInfoResponse::set_allocated_node_info(::iop::locnet::NodeInfo* node_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_info_;
  }
  if (node_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_info, submessage_arena);
    }
    
  } else {
    
  }
  node_info_ = node_info;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetNodeInfoResponse.node_info)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceClientRequest

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceRequest

// .iop.locnet.GpsLocation location = 1;
inline bool ExploreNetworkNodesByDistanceRequest::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void ExploreNetworkNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& ExploreNetworkNodesByDistanceRequest::location() const {
  const ::iop::locnet::GpsLocation* p = location_;
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return p != NULL ? *p : *reinterpret_cast<const ::iop::locnet::GpsLocation*>(
      &::iop::locnet::_GpsLocation_default_instance_);
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return location_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
}

// uint32 target_node_count = 2;
inline void ExploreNetworkNodesByDistanceRequest::clear_target_node_count() {
  target_node_count_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::target_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.target_node_count)
  return target_node_count_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_target_node_count(::google::protobuf::uint32 value) {
  
  target_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.target_node_count)
}

// uint32 max_node_hops = 3;
inline void ExploreNetworkNodesByDistanceRequest::clear_max_node_hops() {
  max_node_hops_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::max_node_hops() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.max_node_hops)
  return max_node_hops_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_max_node_hops(::google::protobuf::uint32 value) {
  
  max_node_hops_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.max_node_hops)
}

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo closest_nodes = 1;
inline int ExploreNetworkNodesByDistanceResponse::closest_nodes_size() const {
  return closest_nodes_.size();
}
inline void ExploreNetworkNodesByDistanceResponse::clear_closest_nodes() {
  closest_nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& ExploreNetworkNodesByDistanceResponse::closest_nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::mutable_closest_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::add_closest_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
ExploreNetworkNodesByDistanceResponse::mutable_closest_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return &closest_nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
ExploreNetworkNodesByDistanceResponse::closest_nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace locnet
}  // namespace iop

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::iop::locnet::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iop::locnet::Status>() {
  return ::iop::locnet::Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IopLocNet_2eproto__INCLUDED
