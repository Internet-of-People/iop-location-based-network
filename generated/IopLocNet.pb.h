// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IopLocNet.proto

#ifndef PROTOBUF_IopLocNet_2eproto__INCLUDED
#define PROTOBUF_IopLocNet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace iop {
namespace locnet {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_IopLocNet_2eproto();
void protobuf_AssignDesc_IopLocNet_2eproto();
void protobuf_ShutdownFile_IopLocNet_2eproto();

class BuildNetworkRequest;
class BuildNetworkResponse;
class ClientRequest;
class ClientResponse;
class DeregisterServiceRequest;
class DeregisterServiceResponse;
class ExploreNetworkNodesByDistanceRequest;
class ExploreNetworkNodesByDistanceResponse;
class GetClosestNodesByDistanceRequest;
class GetClosestNodesByDistanceResponse;
class GetNeighbourNodesByDistanceClientRequest;
class GetNeighbourNodesByDistanceLocalRequest;
class GetNeighbourNodesByDistanceResponse;
class GetNodeCountRequest;
class GetNodeCountResponse;
class GetNodeInfoRequest;
class GetNodeInfoResponse;
class GetRandomNodesRequest;
class GetRandomNodesResponse;
class GpsLocation;
class LocalServiceRequest;
class LocalServiceResponse;
class Message;
class MessageWithHeader;
class NeighbourhoodChange;
class NeighbourhoodChangedNotificationRequest;
class NeighbourhoodChangedNotificationResponse;
class NodeContact;
class NodeInfo;
class RegisterServiceRequest;
class RegisterServiceResponse;
class RemoteNodeRequest;
class RemoteNodeResponse;
class Request;
class Response;
class ServiceInfo;

enum Status {
  STATUS_OK = 0,
  ERROR_PROTOCOL_VIOLATION = 1,
  ERROR_UNSUPPORTED = 2,
  ERROR_INTERNAL = 8,
  ERROR_INVALID_VALUE = 54,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Status_IsValid(int value);
const Status Status_MIN = STATUS_OK;
const Status Status_MAX = ERROR_INVALID_VALUE;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum ServiceType {
  UNSTRUCTURED = 0,
  CONTENT = 1,
  LATENCY = 2,
  LOCATION = 3,
  TOKEN = 10,
  PROFILE = 11,
  PROXIMITY = 12,
  RELAY = 13,
  REPUTATION = 14,
  MINTING = 15,
  ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceType_IsValid(int value);
const ServiceType ServiceType_MIN = UNSTRUCTURED;
const ServiceType ServiceType_MAX = MINTING;
const int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceType_descriptor();
inline const ::std::string& ServiceType_Name(ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceType_descriptor(), value);
}
inline bool ServiceType_Parse(
    const ::std::string& name, ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
// ===================================================================

class ServiceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ServiceInfo) */ {
 public:
  ServiceInfo();
  virtual ~ServiceInfo();

  ServiceInfo(const ServiceInfo& from);

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceInfo& default_instance();

  void Swap(ServiceInfo* other);

  // implements Message ----------------------------------------------

  inline ServiceInfo* New() const { return New(NULL); }

  ServiceInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceInfo& from);
  void MergeFrom(const ServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::iop::locnet::ServiceType type() const;
  void set_type(::iop::locnet::ServiceType value);

  // optional uint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional bytes service_data = 3;
  void clear_service_data();
  static const int kServiceDataFieldNumber = 3;
  const ::std::string& service_data() const;
  void set_service_data(const ::std::string& value);
  void set_service_data(const char* value);
  void set_service_data(const void* value, size_t size);
  ::std::string* mutable_service_data();
  ::std::string* release_service_data();
  void set_allocated_service_data(::std::string* service_data);

  // @@protoc_insertion_point(class_scope:iop.locnet.ServiceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::internal::ArenaStringPtr service_data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GpsLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GpsLocation) */ {
 public:
  GpsLocation();
  virtual ~GpsLocation();

  GpsLocation(const GpsLocation& from);

  inline GpsLocation& operator=(const GpsLocation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsLocation& default_instance();

  void Swap(GpsLocation* other);

  // implements Message ----------------------------------------------

  inline GpsLocation* New() const { return New(NULL); }

  GpsLocation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsLocation& from);
  void MergeFrom(const GpsLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpsLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // optional sfixed32 longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GpsLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GpsLocation* default_instance_;
};
// -------------------------------------------------------------------

class NodeContact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeContact) */ {
 public:
  NodeContact();
  virtual ~NodeContact();

  NodeContact(const NodeContact& from);

  inline NodeContact& operator=(const NodeContact& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeContact& default_instance();

  void Swap(NodeContact* other);

  // implements Message ----------------------------------------------

  inline NodeContact* New() const { return New(NULL); }

  NodeContact* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeContact& from);
  void MergeFrom(const NodeContact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeContact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const void* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // optional uint32 node_port = 2;
  void clear_node_port();
  static const int kNodePortFieldNumber = 2;
  ::google::protobuf::uint32 node_port() const;
  void set_node_port(::google::protobuf::uint32 value);

  // optional uint32 client_port = 3;
  void clear_client_port();
  static const int kClientPortFieldNumber = 3;
  ::google::protobuf::uint32 client_port() const;
  void set_client_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeContact)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::uint32 node_port_;
  ::google::protobuf::uint32 client_port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NodeContact* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  void Swap(NodeInfo* other);

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const { return New(NULL); }

  NodeInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional .iop.locnet.NodeContact contact = 2;
  bool has_contact() const;
  void clear_contact();
  static const int kContactFieldNumber = 2;
  const ::iop::locnet::NodeContact& contact() const;
  ::iop::locnet::NodeContact* mutable_contact();
  ::iop::locnet::NodeContact* release_contact();
  void set_allocated_contact(::iop::locnet::NodeContact* contact);

  // optional .iop.locnet.GpsLocation location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // repeated .iop.locnet.ServiceInfo services = 32;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 32;
  const ::iop::locnet::ServiceInfo& services(int index) const;
  ::iop::locnet::ServiceInfo* mutable_services(int index);
  ::iop::locnet::ServiceInfo* add_services();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
      services() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::iop::locnet::NodeContact* contact_;
  ::iop::locnet::GpsLocation* location_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo > services_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MessageWithHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.MessageWithHeader) */ {
 public:
  MessageWithHeader();
  virtual ~MessageWithHeader();

  MessageWithHeader(const MessageWithHeader& from);

  inline MessageWithHeader& operator=(const MessageWithHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWithHeader& default_instance();

  void Swap(MessageWithHeader* other);

  // implements Message ----------------------------------------------

  inline MessageWithHeader* New() const { return New(NULL); }

  MessageWithHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageWithHeader& from);
  void MergeFrom(const MessageWithHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageWithHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 header = 1;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  ::google::protobuf::uint32 header() const;
  void set_header(::google::protobuf::uint32 value);

  // optional .iop.locnet.Message body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::iop::locnet::Message& body() const;
  ::iop::locnet::Message* mutable_body();
  ::iop::locnet::Message* release_body();
  void set_allocated_body(::iop::locnet::Message* body);

  // @@protoc_insertion_point(class_scope:iop.locnet.MessageWithHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::Message* body_;
  ::google::protobuf::uint32 header_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static MessageWithHeader* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MessageTypeCase {
    kRequest = 2,
    kResponse = 3,
    MESSAGETYPE_NOT_SET = 0,
  };

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional .iop.locnet.Request request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::iop::locnet::Request& request() const;
  ::iop::locnet::Request* mutable_request();
  ::iop::locnet::Request* release_request();
  void set_allocated_request(::iop::locnet::Request* request);

  // optional .iop.locnet.Response response = 3;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 3;
  const ::iop::locnet::Response& response() const;
  ::iop::locnet::Response* mutable_response();
  ::iop::locnet::Response* release_response();
  void set_allocated_response(::iop::locnet::Response* response);

  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Message)
 private:
  inline void set_has_request();
  inline void set_has_response();

  inline bool has_MessageType() const;
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 id_;
  union MessageTypeUnion {
    MessageTypeUnion() {}
    ::iop::locnet::Request* request_;
    ::iop::locnet::Response* response_;
  } MessageType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestTypeCase {
    kLocalService = 2,
    kRemoteNode = 3,
    kClient = 4,
    REQUESTTYPE_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional .iop.locnet.LocalServiceRequest local_service = 2;
  bool has_local_service() const;
  void clear_local_service();
  static const int kLocalServiceFieldNumber = 2;
  const ::iop::locnet::LocalServiceRequest& local_service() const;
  ::iop::locnet::LocalServiceRequest* mutable_local_service();
  ::iop::locnet::LocalServiceRequest* release_local_service();
  void set_allocated_local_service(::iop::locnet::LocalServiceRequest* local_service);

  // optional .iop.locnet.RemoteNodeRequest remote_node = 3;
  bool has_remote_node() const;
  void clear_remote_node();
  static const int kRemoteNodeFieldNumber = 3;
  const ::iop::locnet::RemoteNodeRequest& remote_node() const;
  ::iop::locnet::RemoteNodeRequest* mutable_remote_node();
  ::iop::locnet::RemoteNodeRequest* release_remote_node();
  void set_allocated_remote_node(::iop::locnet::RemoteNodeRequest* remote_node);

  // optional .iop.locnet.ClientRequest client = 4;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 4;
  const ::iop::locnet::ClientRequest& client() const;
  ::iop::locnet::ClientRequest* mutable_client();
  ::iop::locnet::ClientRequest* release_client();
  void set_allocated_client(::iop::locnet::ClientRequest* client);

  RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Request)
 private:
  inline void set_has_local_service();
  inline void set_has_remote_node();
  inline void set_has_client();

  inline bool has_RequestType() const;
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::iop::locnet::LocalServiceRequest* local_service_;
    ::iop::locnet::RemoteNodeRequest* remote_node_;
    ::iop::locnet::ClientRequest* client_;
  } RequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseTypeCase {
    kLocalService = 4,
    kRemoteNode = 5,
    kClient = 6,
    RESPONSETYPE_NOT_SET = 0,
  };

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::iop::locnet::Status status() const;
  void set_status(::iop::locnet::Status value);

  // optional sint64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional string details = 3;
  void clear_details();
  static const int kDetailsFieldNumber = 3;
  const ::std::string& details() const;
  void set_details(const ::std::string& value);
  void set_details(const char* value);
  void set_details(const char* value, size_t size);
  ::std::string* mutable_details();
  ::std::string* release_details();
  void set_allocated_details(::std::string* details);

  // optional .iop.locnet.LocalServiceResponse local_service = 4;
  bool has_local_service() const;
  void clear_local_service();
  static const int kLocalServiceFieldNumber = 4;
  const ::iop::locnet::LocalServiceResponse& local_service() const;
  ::iop::locnet::LocalServiceResponse* mutable_local_service();
  ::iop::locnet::LocalServiceResponse* release_local_service();
  void set_allocated_local_service(::iop::locnet::LocalServiceResponse* local_service);

  // optional .iop.locnet.RemoteNodeResponse remote_node = 5;
  bool has_remote_node() const;
  void clear_remote_node();
  static const int kRemoteNodeFieldNumber = 5;
  const ::iop::locnet::RemoteNodeResponse& remote_node() const;
  ::iop::locnet::RemoteNodeResponse* mutable_remote_node();
  ::iop::locnet::RemoteNodeResponse* release_remote_node();
  void set_allocated_remote_node(::iop::locnet::RemoteNodeResponse* remote_node);

  // optional .iop.locnet.ClientResponse client = 6;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 6;
  const ::iop::locnet::ClientResponse& client() const;
  ::iop::locnet::ClientResponse* mutable_client();
  ::iop::locnet::ClientResponse* release_client();
  void set_allocated_client(::iop::locnet::ClientResponse* client);

  ResponseTypeCase ResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Response)
 private:
  inline void set_has_local_service();
  inline void set_has_remote_node();
  inline void set_has_client();

  inline bool has_ResponseType() const;
  void clear_ResponseType();
  inline void clear_has_ResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::internal::ArenaStringPtr details_;
  int status_;
  union ResponseTypeUnion {
    ResponseTypeUnion() {}
    ::iop::locnet::LocalServiceResponse* local_service_;
    ::iop::locnet::RemoteNodeResponse* remote_node_;
    ::iop::locnet::ClientResponse* client_;
  } ResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class LocalServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceRequest) */ {
 public:
  LocalServiceRequest();
  virtual ~LocalServiceRequest();

  LocalServiceRequest(const LocalServiceRequest& from);

  inline LocalServiceRequest& operator=(const LocalServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceRequest& default_instance();

  enum LocalServiceRequestTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodChanged = 4,
    kGetNodeInfo = 5,
    LOCALSERVICEREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(LocalServiceRequest* other);

  // implements Message ----------------------------------------------

  inline LocalServiceRequest* New() const { return New(NULL); }

  LocalServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalServiceRequest& from);
  void MergeFrom(const LocalServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.RegisterServiceRequest register_service = 1;
  bool has_register_service() const;
  void clear_register_service();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceRequest& register_service() const;
  ::iop::locnet::RegisterServiceRequest* mutable_register_service();
  ::iop::locnet::RegisterServiceRequest* release_register_service();
  void set_allocated_register_service(::iop::locnet::RegisterServiceRequest* register_service);

  // optional .iop.locnet.DeregisterServiceRequest deregister_service = 2;
  bool has_deregister_service() const;
  void clear_deregister_service();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceRequest& deregister_service() const;
  ::iop::locnet::DeregisterServiceRequest* mutable_deregister_service();
  ::iop::locnet::DeregisterServiceRequest* release_deregister_service();
  void set_allocated_deregister_service(::iop::locnet::DeregisterServiceRequest* deregister_service);

  // optional .iop.locnet.GetNeighbourNodesByDistanceLocalRequest get_neighbour_nodes = 3;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* mutable_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* release_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* get_neighbour_nodes);

  // optional .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhood_changed = 4;
  bool has_neighbourhood_changed() const;
  void clear_neighbourhood_changed();
  static const int kNeighbourhoodChangedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationRequest& neighbourhood_changed() const;
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* mutable_neighbourhood_changed();
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* release_neighbourhood_changed();
  void set_allocated_neighbourhood_changed(::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhood_changed);

  // optional .iop.locnet.GetNodeInfoRequest get_node_info = 5;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 5;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  LocalServiceRequestTypeCase LocalServiceRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceRequest)
 private:
  inline void set_has_register_service();
  inline void set_has_deregister_service();
  inline void set_has_get_neighbour_nodes();
  inline void set_has_neighbourhood_changed();
  inline void set_has_get_node_info();

  inline bool has_LocalServiceRequestType() const;
  void clear_LocalServiceRequestType();
  inline void clear_has_LocalServiceRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union LocalServiceRequestTypeUnion {
    LocalServiceRequestTypeUnion() {}
    ::iop::locnet::RegisterServiceRequest* register_service_;
    ::iop::locnet::DeregisterServiceRequest* deregister_service_;
    ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* get_neighbour_nodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhood_changed_;
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
  } LocalServiceRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static LocalServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class LocalServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceResponse) */ {
 public:
  LocalServiceResponse();
  virtual ~LocalServiceResponse();

  LocalServiceResponse(const LocalServiceResponse& from);

  inline LocalServiceResponse& operator=(const LocalServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceResponse& default_instance();

  enum LocalServiceResponseTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodUpdated = 4,
    kGetNodeInfo = 5,
    LOCALSERVICERESPONSETYPE_NOT_SET = 0,
  };

  void Swap(LocalServiceResponse* other);

  // implements Message ----------------------------------------------

  inline LocalServiceResponse* New() const { return New(NULL); }

  LocalServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalServiceResponse& from);
  void MergeFrom(const LocalServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.RegisterServiceResponse register_service = 1;
  bool has_register_service() const;
  void clear_register_service();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceResponse& register_service() const;
  ::iop::locnet::RegisterServiceResponse* mutable_register_service();
  ::iop::locnet::RegisterServiceResponse* release_register_service();
  void set_allocated_register_service(::iop::locnet::RegisterServiceResponse* register_service);

  // optional .iop.locnet.DeregisterServiceResponse deregister_service = 2;
  bool has_deregister_service() const;
  void clear_deregister_service();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceResponse& deregister_service() const;
  ::iop::locnet::DeregisterServiceResponse* mutable_deregister_service();
  ::iop::locnet::DeregisterServiceResponse* release_deregister_service();
  void set_allocated_deregister_service(::iop::locnet::DeregisterServiceResponse* deregister_service);

  // optional .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 3;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes);

  // optional .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhood_updated = 4;
  bool has_neighbourhood_updated() const;
  void clear_neighbourhood_updated();
  static const int kNeighbourhoodUpdatedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationResponse& neighbourhood_updated() const;
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* mutable_neighbourhood_updated();
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* release_neighbourhood_updated();
  void set_allocated_neighbourhood_updated(::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhood_updated);

  // optional .iop.locnet.GetNodeInfoResponse get_node_info = 5;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 5;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  LocalServiceResponseTypeCase LocalServiceResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceResponse)
 private:
  inline void set_has_register_service();
  inline void set_has_deregister_service();
  inline void set_has_get_neighbour_nodes();
  inline void set_has_neighbourhood_updated();
  inline void set_has_get_node_info();

  inline bool has_LocalServiceResponseType() const;
  void clear_LocalServiceResponseType();
  inline void clear_has_LocalServiceResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union LocalServiceResponseTypeUnion {
    LocalServiceResponseTypeUnion() {}
    ::iop::locnet::RegisterServiceResponse* register_service_;
    ::iop::locnet::DeregisterServiceResponse* deregister_service_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhood_updated_;
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
  } LocalServiceResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static LocalServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceRequest) */ {
 public:
  RegisterServiceRequest();
  virtual ~RegisterServiceRequest();

  RegisterServiceRequest(const RegisterServiceRequest& from);

  inline RegisterServiceRequest& operator=(const RegisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceRequest& default_instance();

  void Swap(RegisterServiceRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterServiceRequest* New() const { return New(NULL); }

  RegisterServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServiceRequest& from);
  void MergeFrom(const RegisterServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceInfo service = 1;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::iop::locnet::ServiceInfo& service() const;
  ::iop::locnet::ServiceInfo* mutable_service();
  ::iop::locnet::ServiceInfo* release_service();
  void set_allocated_service(::iop::locnet::ServiceInfo* service);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::ServiceInfo* service_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RegisterServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceResponse) */ {
 public:
  RegisterServiceResponse();
  virtual ~RegisterServiceResponse();

  RegisterServiceResponse(const RegisterServiceResponse& from);

  inline RegisterServiceResponse& operator=(const RegisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceResponse& default_instance();

  void Swap(RegisterServiceResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterServiceResponse* New() const { return New(NULL); }

  RegisterServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServiceResponse& from);
  void MergeFrom(const RegisterServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RegisterServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeregisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceRequest) */ {
 public:
  DeregisterServiceRequest();
  virtual ~DeregisterServiceRequest();

  DeregisterServiceRequest(const DeregisterServiceRequest& from);

  inline DeregisterServiceRequest& operator=(const DeregisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceRequest& default_instance();

  void Swap(DeregisterServiceRequest* other);

  // implements Message ----------------------------------------------

  inline DeregisterServiceRequest* New() const { return New(NULL); }

  DeregisterServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterServiceRequest& from);
  void MergeFrom(const DeregisterServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceType service_type = 1;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  ::iop::locnet::ServiceType service_type() const;
  void set_service_type(::iop::locnet::ServiceType value);

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int service_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static DeregisterServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeregisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceResponse) */ {
 public:
  DeregisterServiceResponse();
  virtual ~DeregisterServiceResponse();

  DeregisterServiceResponse(const DeregisterServiceResponse& from);

  inline DeregisterServiceResponse& operator=(const DeregisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceResponse& default_instance();

  void Swap(DeregisterServiceResponse* other);

  // implements Message ----------------------------------------------

  inline DeregisterServiceResponse* New() const { return New(NULL); }

  DeregisterServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterServiceResponse& from);
  void MergeFrom(const DeregisterServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static DeregisterServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceLocalRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceLocalRequest) */ {
 public:
  GetNeighbourNodesByDistanceLocalRequest();
  virtual ~GetNeighbourNodesByDistanceLocalRequest();

  GetNeighbourNodesByDistanceLocalRequest(const GetNeighbourNodesByDistanceLocalRequest& from);

  inline GetNeighbourNodesByDistanceLocalRequest& operator=(const GetNeighbourNodesByDistanceLocalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceLocalRequest& default_instance();

  void Swap(GetNeighbourNodesByDistanceLocalRequest* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceLocalRequest* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceLocalRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceLocalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool keep_alive_and_send_updates = 1;
  void clear_keep_alive_and_send_updates();
  static const int kKeepAliveAndSendUpdatesFieldNumber = 1;
  bool keep_alive_and_send_updates() const;
  void set_keep_alive_and_send_updates(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceLocalRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool keep_alive_and_send_updates_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceLocalRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceResponse) */ {
 public:
  GetNeighbourNodesByDistanceResponse();
  virtual ~GetNeighbourNodesByDistanceResponse();

  GetNeighbourNodesByDistanceResponse(const GetNeighbourNodesByDistanceResponse& from);

  inline GetNeighbourNodesByDistanceResponse& operator=(const GetNeighbourNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceResponse& default_instance();

  void Swap(GetNeighbourNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceResponse* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceResponse& from);
  void MergeFrom(const GetNeighbourNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChange) */ {
 public:
  NeighbourhoodChange();
  virtual ~NeighbourhoodChange();

  NeighbourhoodChange(const NeighbourhoodChange& from);

  inline NeighbourhoodChange& operator=(const NeighbourhoodChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChange& default_instance();

  enum ChangeTypeCase {
    kAddedNodeInfo = 1,
    kUpdatedNodeInfo = 2,
    kRemovedNodeId = 3,
    CHANGETYPE_NOT_SET = 0,
  };

  void Swap(NeighbourhoodChange* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChange* New() const { return New(NULL); }

  NeighbourhoodChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChange& from);
  void MergeFrom(const NeighbourhoodChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo added_node_info = 1;
  bool has_added_node_info() const;
  void clear_added_node_info();
  static const int kAddedNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& added_node_info() const;
  ::iop::locnet::NodeInfo* mutable_added_node_info();
  ::iop::locnet::NodeInfo* release_added_node_info();
  void set_allocated_added_node_info(::iop::locnet::NodeInfo* added_node_info);

  // optional .iop.locnet.NodeInfo updated_node_info = 2;
  bool has_updated_node_info() const;
  void clear_updated_node_info();
  static const int kUpdatedNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& updated_node_info() const;
  ::iop::locnet::NodeInfo* mutable_updated_node_info();
  ::iop::locnet::NodeInfo* release_updated_node_info();
  void set_allocated_updated_node_info(::iop::locnet::NodeInfo* updated_node_info);

  // optional bytes removed_node_id = 3;
  private:
  bool has_removed_node_id() const;
  public:
  void clear_removed_node_id();
  static const int kRemovedNodeIdFieldNumber = 3;
  const ::std::string& removed_node_id() const;
  void set_removed_node_id(const ::std::string& value);
  void set_removed_node_id(const char* value);
  void set_removed_node_id(const void* value, size_t size);
  ::std::string* mutable_removed_node_id();
  ::std::string* release_removed_node_id();
  void set_allocated_removed_node_id(::std::string* removed_node_id);

  ChangeTypeCase ChangeType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChange)
 private:
  inline void set_has_added_node_info();
  inline void set_has_updated_node_info();
  inline void set_has_removed_node_id();

  inline bool has_ChangeType() const;
  void clear_ChangeType();
  inline void clear_has_ChangeType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ChangeTypeUnion {
    ChangeTypeUnion() {}
    ::iop::locnet::NodeInfo* added_node_info_;
    ::iop::locnet::NodeInfo* updated_node_info_;
    ::google::protobuf::internal::ArenaStringPtr removed_node_id_;
  } ChangeType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChange* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationRequest) */ {
 public:
  NeighbourhoodChangedNotificationRequest();
  virtual ~NeighbourhoodChangedNotificationRequest();

  NeighbourhoodChangedNotificationRequest(const NeighbourhoodChangedNotificationRequest& from);

  inline NeighbourhoodChangedNotificationRequest& operator=(const NeighbourhoodChangedNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationRequest& default_instance();

  void Swap(NeighbourhoodChangedNotificationRequest* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationRequest* New() const { return New(NULL); }

  NeighbourhoodChangedNotificationRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChangedNotificationRequest& from);
  void MergeFrom(const NeighbourhoodChangedNotificationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChangedNotificationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NeighbourhoodChange changes = 1;
  int changes_size() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::iop::locnet::NeighbourhoodChange& changes(int index) const;
  ::iop::locnet::NeighbourhoodChange* mutable_changes(int index);
  ::iop::locnet::NeighbourhoodChange* add_changes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
      mutable_changes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
      changes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange > changes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChangedNotificationRequest* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationResponse) */ {
 public:
  NeighbourhoodChangedNotificationResponse();
  virtual ~NeighbourhoodChangedNotificationResponse();

  NeighbourhoodChangedNotificationResponse(const NeighbourhoodChangedNotificationResponse& from);

  inline NeighbourhoodChangedNotificationResponse& operator=(const NeighbourhoodChangedNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationResponse& default_instance();

  void Swap(NeighbourhoodChangedNotificationResponse* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationResponse* New() const { return New(NULL); }

  NeighbourhoodChangedNotificationResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChangedNotificationResponse& from);
  void MergeFrom(const NeighbourhoodChangedNotificationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChangedNotificationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChangedNotificationResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoteNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeRequest) */ {
 public:
  RemoteNodeRequest();
  virtual ~RemoteNodeRequest();

  RemoteNodeRequest(const RemoteNodeRequest& from);

  inline RemoteNodeRequest& operator=(const RemoteNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeRequest& default_instance();

  enum RemoteNodeRequestTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODEREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(RemoteNodeRequest* other);

  // implements Message ----------------------------------------------

  inline RemoteNodeRequest* New() const { return New(NULL); }

  RemoteNodeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteNodeRequest& from);
  void MergeFrom(const RemoteNodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.BuildNetworkRequest accept_colleague = 1;
  bool has_accept_colleague() const;
  void clear_accept_colleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkRequest& accept_colleague() const;
  ::iop::locnet::BuildNetworkRequest* mutable_accept_colleague();
  ::iop::locnet::BuildNetworkRequest* release_accept_colleague();
  void set_allocated_accept_colleague(::iop::locnet::BuildNetworkRequest* accept_colleague);

  // optional .iop.locnet.BuildNetworkRequest renew_colleague = 2;
  bool has_renew_colleague() const;
  void clear_renew_colleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkRequest& renew_colleague() const;
  ::iop::locnet::BuildNetworkRequest* mutable_renew_colleague();
  ::iop::locnet::BuildNetworkRequest* release_renew_colleague();
  void set_allocated_renew_colleague(::iop::locnet::BuildNetworkRequest* renew_colleague);

  // optional .iop.locnet.BuildNetworkRequest accept_neighbour = 3;
  bool has_accept_neighbour() const;
  void clear_accept_neighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkRequest& accept_neighbour() const;
  ::iop::locnet::BuildNetworkRequest* mutable_accept_neighbour();
  ::iop::locnet::BuildNetworkRequest* release_accept_neighbour();
  void set_allocated_accept_neighbour(::iop::locnet::BuildNetworkRequest* accept_neighbour);

  // optional .iop.locnet.BuildNetworkRequest renew_neighbour = 4;
  bool has_renew_neighbour() const;
  void clear_renew_neighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkRequest& renew_neighbour() const;
  ::iop::locnet::BuildNetworkRequest* mutable_renew_neighbour();
  ::iop::locnet::BuildNetworkRequest* release_renew_neighbour();
  void set_allocated_renew_neighbour(::iop::locnet::BuildNetworkRequest* renew_neighbour);

  // optional .iop.locnet.GetNodeCountRequest get_node_count = 5;
  bool has_get_node_count() const;
  void clear_get_node_count();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountRequest& get_node_count() const;
  ::iop::locnet::GetNodeCountRequest* mutable_get_node_count();
  ::iop::locnet::GetNodeCountRequest* release_get_node_count();
  void set_allocated_get_node_count(::iop::locnet::GetNodeCountRequest* get_node_count);

  // optional .iop.locnet.GetRandomNodesRequest get_random_nodes = 6;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesRequest& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesRequest* mutable_get_random_nodes();
  ::iop::locnet::GetRandomNodesRequest* release_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes);

  // optional .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 7;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes);

  // optional .iop.locnet.GetNodeInfoRequest get_node_info = 8;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  RemoteNodeRequestTypeCase RemoteNodeRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeRequest)
 private:
  inline void set_has_accept_colleague();
  inline void set_has_renew_colleague();
  inline void set_has_accept_neighbour();
  inline void set_has_renew_neighbour();
  inline void set_has_get_node_count();
  inline void set_has_get_random_nodes();
  inline void set_has_get_closest_nodes();
  inline void set_has_get_node_info();

  inline bool has_RemoteNodeRequestType() const;
  void clear_RemoteNodeRequestType();
  inline void clear_has_RemoteNodeRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union RemoteNodeRequestTypeUnion {
    RemoteNodeRequestTypeUnion() {}
    ::iop::locnet::BuildNetworkRequest* accept_colleague_;
    ::iop::locnet::BuildNetworkRequest* renew_colleague_;
    ::iop::locnet::BuildNetworkRequest* accept_neighbour_;
    ::iop::locnet::BuildNetworkRequest* renew_neighbour_;
    ::iop::locnet::GetNodeCountRequest* get_node_count_;
    ::iop::locnet::GetRandomNodesRequest* get_random_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes_;
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
  } RemoteNodeRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RemoteNodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoteNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeResponse) */ {
 public:
  RemoteNodeResponse();
  virtual ~RemoteNodeResponse();

  RemoteNodeResponse(const RemoteNodeResponse& from);

  inline RemoteNodeResponse& operator=(const RemoteNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeResponse& default_instance();

  enum RemoteNodeResponseTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODERESPONSETYPE_NOT_SET = 0,
  };

  void Swap(RemoteNodeResponse* other);

  // implements Message ----------------------------------------------

  inline RemoteNodeResponse* New() const { return New(NULL); }

  RemoteNodeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteNodeResponse& from);
  void MergeFrom(const RemoteNodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.BuildNetworkResponse accept_colleague = 1;
  bool has_accept_colleague() const;
  void clear_accept_colleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkResponse& accept_colleague() const;
  ::iop::locnet::BuildNetworkResponse* mutable_accept_colleague();
  ::iop::locnet::BuildNetworkResponse* release_accept_colleague();
  void set_allocated_accept_colleague(::iop::locnet::BuildNetworkResponse* accept_colleague);

  // optional .iop.locnet.BuildNetworkResponse renew_colleague = 2;
  bool has_renew_colleague() const;
  void clear_renew_colleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkResponse& renew_colleague() const;
  ::iop::locnet::BuildNetworkResponse* mutable_renew_colleague();
  ::iop::locnet::BuildNetworkResponse* release_renew_colleague();
  void set_allocated_renew_colleague(::iop::locnet::BuildNetworkResponse* renew_colleague);

  // optional .iop.locnet.BuildNetworkResponse accept_neighbour = 3;
  bool has_accept_neighbour() const;
  void clear_accept_neighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkResponse& accept_neighbour() const;
  ::iop::locnet::BuildNetworkResponse* mutable_accept_neighbour();
  ::iop::locnet::BuildNetworkResponse* release_accept_neighbour();
  void set_allocated_accept_neighbour(::iop::locnet::BuildNetworkResponse* accept_neighbour);

  // optional .iop.locnet.BuildNetworkResponse renew_neighbour = 4;
  bool has_renew_neighbour() const;
  void clear_renew_neighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkResponse& renew_neighbour() const;
  ::iop::locnet::BuildNetworkResponse* mutable_renew_neighbour();
  ::iop::locnet::BuildNetworkResponse* release_renew_neighbour();
  void set_allocated_renew_neighbour(::iop::locnet::BuildNetworkResponse* renew_neighbour);

  // optional .iop.locnet.GetNodeCountResponse get_node_count = 5;
  bool has_get_node_count() const;
  void clear_get_node_count();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountResponse& get_node_count() const;
  ::iop::locnet::GetNodeCountResponse* mutable_get_node_count();
  ::iop::locnet::GetNodeCountResponse* release_get_node_count();
  void set_allocated_get_node_count(::iop::locnet::GetNodeCountResponse* get_node_count);

  // optional .iop.locnet.GetRandomNodesResponse get_random_nodes = 6;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesResponse& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesResponse* mutable_get_random_nodes();
  ::iop::locnet::GetRandomNodesResponse* release_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes);

  // optional .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 7;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes);

  // optional .iop.locnet.GetNodeInfoResponse get_node_info = 8;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  RemoteNodeResponseTypeCase RemoteNodeResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeResponse)
 private:
  inline void set_has_accept_colleague();
  inline void set_has_renew_colleague();
  inline void set_has_accept_neighbour();
  inline void set_has_renew_neighbour();
  inline void set_has_get_node_count();
  inline void set_has_get_random_nodes();
  inline void set_has_get_closest_nodes();
  inline void set_has_get_node_info();

  inline bool has_RemoteNodeResponseType() const;
  void clear_RemoteNodeResponseType();
  inline void clear_has_RemoteNodeResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union RemoteNodeResponseTypeUnion {
    RemoteNodeResponseTypeUnion() {}
    ::iop::locnet::BuildNetworkResponse* accept_colleague_;
    ::iop::locnet::BuildNetworkResponse* renew_colleague_;
    ::iop::locnet::BuildNetworkResponse* accept_neighbour_;
    ::iop::locnet::BuildNetworkResponse* renew_neighbour_;
    ::iop::locnet::GetNodeCountResponse* get_node_count_;
    ::iop::locnet::GetRandomNodesResponse* get_random_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes_;
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
  } RemoteNodeResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RemoteNodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class BuildNetworkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkRequest) */ {
 public:
  BuildNetworkRequest();
  virtual ~BuildNetworkRequest();

  BuildNetworkRequest(const BuildNetworkRequest& from);

  inline BuildNetworkRequest& operator=(const BuildNetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkRequest& default_instance();

  void Swap(BuildNetworkRequest* other);

  // implements Message ----------------------------------------------

  inline BuildNetworkRequest* New() const { return New(NULL); }

  BuildNetworkRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildNetworkRequest& from);
  void MergeFrom(const BuildNetworkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildNetworkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo requestor_node_info = 1;
  bool has_requestor_node_info() const;
  void clear_requestor_node_info();
  static const int kRequestorNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& requestor_node_info() const;
  ::iop::locnet::NodeInfo* mutable_requestor_node_info();
  ::iop::locnet::NodeInfo* release_requestor_node_info();
  void set_allocated_requestor_node_info(::iop::locnet::NodeInfo* requestor_node_info);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* requestor_node_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static BuildNetworkRequest* default_instance_;
};
// -------------------------------------------------------------------

class BuildNetworkResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkResponse) */ {
 public:
  BuildNetworkResponse();
  virtual ~BuildNetworkResponse();

  BuildNetworkResponse(const BuildNetworkResponse& from);

  inline BuildNetworkResponse& operator=(const BuildNetworkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkResponse& default_instance();

  void Swap(BuildNetworkResponse* other);

  // implements Message ----------------------------------------------

  inline BuildNetworkResponse* New() const { return New(NULL); }

  BuildNetworkResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildNetworkResponse& from);
  void MergeFrom(const BuildNetworkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildNetworkResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool accepted = 1;
  void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  bool accepted() const;
  void set_accepted(bool value);

  // optional .iop.locnet.NodeInfo acceptor_node_info = 2;
  bool has_acceptor_node_info() const;
  void clear_acceptor_node_info();
  static const int kAcceptorNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& acceptor_node_info() const;
  ::iop::locnet::NodeInfo* mutable_acceptor_node_info();
  ::iop::locnet::NodeInfo* release_acceptor_node_info();
  void set_allocated_acceptor_node_info(::iop::locnet::NodeInfo* acceptor_node_info);

  // optional bytes remote_ip_address = 3;
  void clear_remote_ip_address();
  static const int kRemoteIpAddressFieldNumber = 3;
  const ::std::string& remote_ip_address() const;
  void set_remote_ip_address(const ::std::string& value);
  void set_remote_ip_address(const char* value);
  void set_remote_ip_address(const void* value, size_t size);
  ::std::string* mutable_remote_ip_address();
  ::std::string* release_remote_ip_address();
  void set_allocated_remote_ip_address(::std::string* remote_ip_address);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* acceptor_node_info_;
  ::google::protobuf::internal::ArenaStringPtr remote_ip_address_;
  bool accepted_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static BuildNetworkResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeCountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountRequest) */ {
 public:
  GetNodeCountRequest();
  virtual ~GetNodeCountRequest();

  GetNodeCountRequest(const GetNodeCountRequest& from);

  inline GetNodeCountRequest& operator=(const GetNodeCountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountRequest& default_instance();

  void Swap(GetNodeCountRequest* other);

  // implements Message ----------------------------------------------

  inline GetNodeCountRequest* New() const { return New(NULL); }

  GetNodeCountRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeCountRequest& from);
  void MergeFrom(const GetNodeCountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeCountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeCountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeCountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountResponse) */ {
 public:
  GetNodeCountResponse();
  virtual ~GetNodeCountResponse();

  GetNodeCountResponse(const GetNodeCountResponse& from);

  inline GetNodeCountResponse& operator=(const GetNodeCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountResponse& default_instance();

  void Swap(GetNodeCountResponse* other);

  // implements Message ----------------------------------------------

  inline GetNodeCountResponse* New() const { return New(NULL); }

  GetNodeCountResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeCountResponse& from);
  void MergeFrom(const GetNodeCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeCountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_count = 1;
  void clear_node_count();
  static const int kNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 node_count() const;
  void set_node_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 node_count_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesRequest) */ {
 public:
  GetRandomNodesRequest();
  virtual ~GetRandomNodesRequest();

  GetRandomNodesRequest(const GetRandomNodesRequest& from);

  inline GetRandomNodesRequest& operator=(const GetRandomNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesRequest& default_instance();

  void Swap(GetRandomNodesRequest* other);

  // implements Message ----------------------------------------------

  inline GetRandomNodesRequest* New() const { return New(NULL); }

  GetRandomNodesRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRandomNodesRequest& from);
  void MergeFrom(const GetRandomNodesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRandomNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 max_node_count = 1;
  void clear_max_node_count();
  static const int kMaxNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 max_node_count() const;
  void set_max_node_count(::google::protobuf::uint32 value);

  // optional bool include_neighbours = 2;
  void clear_include_neighbours();
  static const int kIncludeNeighboursFieldNumber = 2;
  bool include_neighbours() const;
  void set_include_neighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 max_node_count_;
  bool include_neighbours_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetRandomNodesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesResponse) */ {
 public:
  GetRandomNodesResponse();
  virtual ~GetRandomNodesResponse();

  GetRandomNodesResponse(const GetRandomNodesResponse& from);

  inline GetRandomNodesResponse& operator=(const GetRandomNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesResponse& default_instance();

  void Swap(GetRandomNodesResponse* other);

  // implements Message ----------------------------------------------

  inline GetRandomNodesResponse* New() const { return New(NULL); }

  GetRandomNodesResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRandomNodesResponse& from);
  void MergeFrom(const GetRandomNodesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRandomNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetRandomNodesResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceRequest) */ {
 public:
  GetClosestNodesByDistanceRequest();
  virtual ~GetClosestNodesByDistanceRequest();

  GetClosestNodesByDistanceRequest(const GetClosestNodesByDistanceRequest& from);

  inline GetClosestNodesByDistanceRequest& operator=(const GetClosestNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceRequest& default_instance();

  void Swap(GetClosestNodesByDistanceRequest* other);

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceRequest* New() const { return New(NULL); }

  GetClosestNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClosestNodesByDistanceRequest& from);
  void MergeFrom(const GetClosestNodesByDistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetClosestNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // optional float max_radius_km = 2;
  void clear_max_radius_km();
  static const int kMaxRadiusKmFieldNumber = 2;
  float max_radius_km() const;
  void set_max_radius_km(float value);

  // optional uint32 max_node_count = 3;
  void clear_max_node_count();
  static const int kMaxNodeCountFieldNumber = 3;
  ::google::protobuf::uint32 max_node_count() const;
  void set_max_node_count(::google::protobuf::uint32 value);

  // optional bool include_neighbours = 4;
  void clear_include_neighbours();
  static const int kIncludeNeighboursFieldNumber = 4;
  bool include_neighbours() const;
  void set_include_neighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  float max_radius_km_;
  ::google::protobuf::uint32 max_node_count_;
  bool include_neighbours_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetClosestNodesByDistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceResponse) */ {
 public:
  GetClosestNodesByDistanceResponse();
  virtual ~GetClosestNodesByDistanceResponse();

  GetClosestNodesByDistanceResponse(const GetClosestNodesByDistanceResponse& from);

  inline GetClosestNodesByDistanceResponse& operator=(const GetClosestNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceResponse& default_instance();

  void Swap(GetClosestNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceResponse* New() const { return New(NULL); }

  GetClosestNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClosestNodesByDistanceResponse& from);
  void MergeFrom(const GetClosestNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetClosestNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetClosestNodesByDistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientRequest) */ {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();

  enum ClientRequestTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    kGetRandomNodes = 5,
    CLIENTREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(ClientRequest* other);

  // implements Message ----------------------------------------------

  inline ClientRequest* New() const { return New(NULL); }

  ClientRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GetNodeInfoRequest get_node_info = 1;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoRequest& get_node_info() const;
  ::iop::locnet::GetNodeInfoRequest* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoRequest* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info);

  // optional .iop.locnet.GetNeighbourNodesByDistanceClientRequest get_neighbour_nodes = 2;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* mutable_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* release_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceClientRequest* get_neighbour_nodes);

  // optional .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 3;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes);

  // optional .iop.locnet.ExploreNetworkNodesByDistanceRequest explore_nodes = 4;
  bool has_explore_nodes() const;
  void clear_explore_nodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& explore_nodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* mutable_explore_nodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* release_explore_nodes();
  void set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceRequest* explore_nodes);

  // optional .iop.locnet.GetRandomNodesRequest get_random_nodes = 5;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 5;
  const ::iop::locnet::GetRandomNodesRequest& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesRequest* mutable_get_random_nodes();
  ::iop::locnet::GetRandomNodesRequest* release_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes);

  ClientRequestTypeCase ClientRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientRequest)
 private:
  inline void set_has_get_node_info();
  inline void set_has_get_neighbour_nodes();
  inline void set_has_get_closest_nodes();
  inline void set_has_explore_nodes();
  inline void set_has_get_random_nodes();

  inline bool has_ClientRequestType() const;
  void clear_ClientRequestType();
  inline void clear_has_ClientRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ClientRequestTypeUnion {
    ClientRequestTypeUnion() {}
    ::iop::locnet::GetNodeInfoRequest* get_node_info_;
    ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* get_neighbour_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceRequest* explore_nodes_;
    ::iop::locnet::GetRandomNodesRequest* get_random_nodes_;
  } ClientRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientResponse) */ {
 public:
  ClientResponse();
  virtual ~ClientResponse();

  ClientResponse(const ClientResponse& from);

  inline ClientResponse& operator=(const ClientResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientResponse& default_instance();

  enum ClientResponseTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    kGetRandomNodes = 5,
    CLIENTRESPONSETYPE_NOT_SET = 0,
  };

  void Swap(ClientResponse* other);

  // implements Message ----------------------------------------------

  inline ClientResponse* New() const { return New(NULL); }

  ClientResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientResponse& from);
  void MergeFrom(const ClientResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GetNodeInfoResponse get_node_info = 1;
  bool has_get_node_info() const;
  void clear_get_node_info();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoResponse& get_node_info() const;
  ::iop::locnet::GetNodeInfoResponse* mutable_get_node_info();
  ::iop::locnet::GetNodeInfoResponse* release_get_node_info();
  void set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info);

  // optional .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 2;
  bool has_get_neighbour_nodes() const;
  void clear_get_neighbour_nodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& get_neighbour_nodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_get_neighbour_nodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_get_neighbour_nodes();
  void set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes);

  // optional .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 3;
  bool has_get_closest_nodes() const;
  void clear_get_closest_nodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& get_closest_nodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_get_closest_nodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_get_closest_nodes();
  void set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes);

  // optional .iop.locnet.ExploreNetworkNodesByDistanceResponse explore_nodes = 4;
  bool has_explore_nodes() const;
  void clear_explore_nodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& explore_nodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* mutable_explore_nodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* release_explore_nodes();
  void set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceResponse* explore_nodes);

  // optional .iop.locnet.GetRandomNodesResponse get_random_nodes = 5;
  bool has_get_random_nodes() const;
  void clear_get_random_nodes();
  static const int kGetRandomNodesFieldNumber = 5;
  const ::iop::locnet::GetRandomNodesResponse& get_random_nodes() const;
  ::iop::locnet::GetRandomNodesResponse* mutable_get_random_nodes();
  ::iop::locnet::GetRandomNodesResponse* release_get_random_nodes();
  void set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes);

  ClientResponseTypeCase ClientResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientResponse)
 private:
  inline void set_has_get_node_info();
  inline void set_has_get_neighbour_nodes();
  inline void set_has_get_closest_nodes();
  inline void set_has_explore_nodes();
  inline void set_has_get_random_nodes();

  inline bool has_ClientResponseType() const;
  void clear_ClientResponseType();
  inline void clear_has_ClientResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ClientResponseTypeUnion {
    ClientResponseTypeUnion() {}
    ::iop::locnet::GetNodeInfoResponse* get_node_info_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceResponse* explore_nodes_;
    ::iop::locnet::GetRandomNodesResponse* get_random_nodes_;
  } ClientResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ClientResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoRequest) */ {
 public:
  GetNodeInfoRequest();
  virtual ~GetNodeInfoRequest();

  GetNodeInfoRequest(const GetNodeInfoRequest& from);

  inline GetNodeInfoRequest& operator=(const GetNodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoRequest& default_instance();

  void Swap(GetNodeInfoRequest* other);

  // implements Message ----------------------------------------------

  inline GetNodeInfoRequest* New() const { return New(NULL); }

  GetNodeInfoRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeInfoRequest& from);
  void MergeFrom(const GetNodeInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoResponse) */ {
 public:
  GetNodeInfoResponse();
  virtual ~GetNodeInfoResponse();

  GetNodeInfoResponse(const GetNodeInfoResponse& from);

  inline GetNodeInfoResponse& operator=(const GetNodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoResponse& default_instance();

  void Swap(GetNodeInfoResponse* other);

  // implements Message ----------------------------------------------

  inline GetNodeInfoResponse* New() const { return New(NULL); }

  GetNodeInfoResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeInfoResponse& from);
  void MergeFrom(const GetNodeInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo node_info = 1;
  bool has_node_info() const;
  void clear_node_info();
  static const int kNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& node_info() const;
  ::iop::locnet::NodeInfo* mutable_node_info();
  ::iop::locnet::NodeInfo* release_node_info();
  void set_allocated_node_info(::iop::locnet::NodeInfo* node_info);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* node_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceClientRequest) */ {
 public:
  GetNeighbourNodesByDistanceClientRequest();
  virtual ~GetNeighbourNodesByDistanceClientRequest();

  GetNeighbourNodesByDistanceClientRequest(const GetNeighbourNodesByDistanceClientRequest& from);

  inline GetNeighbourNodesByDistanceClientRequest& operator=(const GetNeighbourNodesByDistanceClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceClientRequest& default_instance();

  void Swap(GetNeighbourNodesByDistanceClientRequest* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceClientRequest* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceClientRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceRequest) */ {
 public:
  ExploreNetworkNodesByDistanceRequest();
  virtual ~ExploreNetworkNodesByDistanceRequest();

  ExploreNetworkNodesByDistanceRequest(const ExploreNetworkNodesByDistanceRequest& from);

  inline ExploreNetworkNodesByDistanceRequest& operator=(const ExploreNetworkNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceRequest& default_instance();

  void Swap(ExploreNetworkNodesByDistanceRequest* other);

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceRequest* New() const { return New(NULL); }

  ExploreNetworkNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExploreNetworkNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // optional uint32 target_node_count = 2;
  void clear_target_node_count();
  static const int kTargetNodeCountFieldNumber = 2;
  ::google::protobuf::uint32 target_node_count() const;
  void set_target_node_count(::google::protobuf::uint32 value);

  // optional uint32 max_node_hops = 3;
  void clear_max_node_hops();
  static const int kMaxNodeHopsFieldNumber = 3;
  ::google::protobuf::uint32 max_node_hops() const;
  void set_max_node_hops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  ::google::protobuf::uint32 target_node_count_;
  ::google::protobuf::uint32 max_node_hops_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ExploreNetworkNodesByDistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceResponse) */ {
 public:
  ExploreNetworkNodesByDistanceResponse();
  virtual ~ExploreNetworkNodesByDistanceResponse();

  ExploreNetworkNodesByDistanceResponse(const ExploreNetworkNodesByDistanceResponse& from);

  inline ExploreNetworkNodesByDistanceResponse& operator=(const ExploreNetworkNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceResponse& default_instance();

  void Swap(ExploreNetworkNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceResponse* New() const { return New(NULL); }

  ExploreNetworkNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExploreNetworkNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo closest_nodes = 1;
  int closest_nodes_size() const;
  void clear_closest_nodes();
  static const int kClosestNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& closest_nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_closest_nodes(int index);
  ::iop::locnet::NodeInfo* add_closest_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_closest_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      closest_nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > closest_nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ExploreNetworkNodesByDistanceResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ServiceInfo

// optional .iop.locnet.ServiceType type = 1;
inline void ServiceInfo::clear_type() {
  type_ = 0;
}
inline ::iop::locnet::ServiceType ServiceInfo::type() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.type)
  return static_cast< ::iop::locnet::ServiceType >(type_);
}
inline void ServiceInfo::set_type(::iop::locnet::ServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.type)
}

// optional uint32 port = 2;
inline void ServiceInfo::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 ServiceInfo::port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.port)
  return port_;
}
inline void ServiceInfo::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.port)
}

// optional bytes service_data = 3;
inline void ServiceInfo::clear_service_data() {
  service_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServiceInfo::service_data() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.service_data)
  return service_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_service_data(const ::std::string& value) {
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.service_data)
}
inline void ServiceInfo::set_service_data(const char* value) {
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.ServiceInfo.service_data)
}
inline void ServiceInfo::set_service_data(const void* value, size_t size) {
  
  service_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.ServiceInfo.service_data)
}
inline ::std::string* ServiceInfo::mutable_service_data() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.ServiceInfo.service_data)
  return service_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceInfo::release_service_data() {
  // @@protoc_insertion_point(field_release:iop.locnet.ServiceInfo.service_data)
  
  return service_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_allocated_service_data(::std::string* service_data) {
  if (service_data != NULL) {
    
  } else {
    
  }
  service_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_data);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ServiceInfo.service_data)
}

// -------------------------------------------------------------------

// GpsLocation

// optional sfixed32 latitude = 1;
inline void GpsLocation::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::latitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.latitude)
  return latitude_;
}
inline void GpsLocation::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.latitude)
}

// optional sfixed32 longitude = 2;
inline void GpsLocation::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::longitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.longitude)
  return longitude_;
}
inline void GpsLocation::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.longitude)
}

// -------------------------------------------------------------------

// NodeContact

// optional bytes ip_address = 1;
inline void NodeContact::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeContact::ip_address() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeContact::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.ip_address)
}
inline void NodeContact::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeContact.ip_address)
}
inline void NodeContact::set_ip_address(const void* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeContact.ip_address)
}
inline ::std::string* NodeContact::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeContact.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeContact::release_ip_address() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeContact.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeContact::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeContact.ip_address)
}

// optional uint32 node_port = 2;
inline void NodeContact::clear_node_port() {
  node_port_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::node_port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.node_port)
  return node_port_;
}
inline void NodeContact::set_node_port(::google::protobuf::uint32 value) {
  
  node_port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.node_port)
}

// optional uint32 client_port = 3;
inline void NodeContact::clear_client_port() {
  client_port_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::client_port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.client_port)
  return client_port_;
}
inline void NodeContact::set_client_port(::google::protobuf::uint32 value) {
  
  client_port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.client_port)
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes node_id = 1;
inline void NodeInfo::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.node_id)
  return node_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeInfo.node_id)
}
inline void NodeInfo::set_node_id(const char* value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeInfo.node_id)
}
inline void NodeInfo::set_node_id(const void* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeInfo.node_id)
}
inline ::std::string* NodeInfo::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_node_id() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.node_id)
}

// optional .iop.locnet.NodeContact contact = 2;
inline bool NodeInfo::has_contact() const {
  return !_is_default_instance_ && contact_ != NULL;
}
inline void NodeInfo::clear_contact() {
  if (GetArenaNoVirtual() == NULL && contact_ != NULL) delete contact_;
  contact_ = NULL;
}
inline const ::iop::locnet::NodeContact& NodeInfo::contact() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.contact)
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
}
inline ::iop::locnet::NodeContact* NodeInfo::mutable_contact() {
  
  if (contact_ == NULL) {
    contact_ = new ::iop::locnet::NodeContact;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.contact)
  return contact_;
}
inline ::iop::locnet::NodeContact* NodeInfo::release_contact() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.contact)
  
  ::iop::locnet::NodeContact* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_contact(::iop::locnet::NodeContact* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.contact)
}

// optional .iop.locnet.GpsLocation location = 3;
inline bool NodeInfo::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void NodeInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& NodeInfo::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* NodeInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* NodeInfo::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.location)
}

// repeated .iop.locnet.ServiceInfo services = 32;
inline int NodeInfo::services_size() const {
  return services_.size();
}
inline void NodeInfo::clear_services() {
  services_.Clear();
}
inline const ::iop::locnet::ServiceInfo& NodeInfo::services(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.services)
  return services_.Get(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.services)
  return services_.Mutable(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::add_services() {
  // @@protoc_insertion_point(field_add:iop.locnet.NodeInfo.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
NodeInfo::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NodeInfo.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
NodeInfo::services() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NodeInfo.services)
  return services_;
}

// -------------------------------------------------------------------

// MessageWithHeader

// optional fixed32 header = 1;
inline void MessageWithHeader::clear_header() {
  header_ = 0u;
}
inline ::google::protobuf::uint32 MessageWithHeader::header() const {
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.header)
  return header_;
}
inline void MessageWithHeader::set_header(::google::protobuf::uint32 value) {
  
  header_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.MessageWithHeader.header)
}

// optional .iop.locnet.Message body = 2;
inline bool MessageWithHeader::has_body() const {
  return !_is_default_instance_ && body_ != NULL;
}
inline void MessageWithHeader::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) delete body_;
  body_ = NULL;
}
inline const ::iop::locnet::Message& MessageWithHeader::body() const {
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::iop::locnet::Message* MessageWithHeader::mutable_body() {
  
  if (body_ == NULL) {
    body_ = new ::iop::locnet::Message;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.MessageWithHeader.body)
  return body_;
}
inline ::iop::locnet::Message* MessageWithHeader::release_body() {
  // @@protoc_insertion_point(field_release:iop.locnet.MessageWithHeader.body)
  
  ::iop::locnet::Message* temp = body_;
  body_ = NULL;
  return temp;
}
inline void MessageWithHeader::set_allocated_body(::iop::locnet::Message* body) {
  delete body_;
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.MessageWithHeader.body)
}

// -------------------------------------------------------------------

// Message

// optional uint32 id = 1;
inline void Message::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Message::id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.id)
  return id_;
}
inline void Message::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Message.id)
}

// optional .iop.locnet.Request request = 2;
inline bool Message::has_request() const {
  return MessageType_case() == kRequest;
}
inline void Message::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void Message::clear_request() {
  if (has_request()) {
    delete MessageType_.request_;
    clear_has_MessageType();
  }
}
inline  const ::iop::locnet::Request& Message::request() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.request)
  return has_request()
      ? *MessageType_.request_
      : ::iop::locnet::Request::default_instance();
}
inline ::iop::locnet::Request* Message::mutable_request() {
  if (!has_request()) {
    clear_MessageType();
    set_has_request();
    MessageType_.request_ = new ::iop::locnet::Request;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.request)
  return MessageType_.request_;
}
inline ::iop::locnet::Request* Message::release_request() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.request)
  if (has_request()) {
    clear_has_MessageType();
    ::iop::locnet::Request* temp = MessageType_.request_;
    MessageType_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_request(::iop::locnet::Request* request) {
  clear_MessageType();
  if (request) {
    set_has_request();
    MessageType_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Message.request)
}

// optional .iop.locnet.Response response = 3;
inline bool Message::has_response() const {
  return MessageType_case() == kResponse;
}
inline void Message::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void Message::clear_response() {
  if (has_response()) {
    delete MessageType_.response_;
    clear_has_MessageType();
  }
}
inline  const ::iop::locnet::Response& Message::response() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.response)
  return has_response()
      ? *MessageType_.response_
      : ::iop::locnet::Response::default_instance();
}
inline ::iop::locnet::Response* Message::mutable_response() {
  if (!has_response()) {
    clear_MessageType();
    set_has_response();
    MessageType_.response_ = new ::iop::locnet::Response;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.response)
  return MessageType_.response_;
}
inline ::iop::locnet::Response* Message::release_response() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.response)
  if (has_response()) {
    clear_has_MessageType();
    ::iop::locnet::Response* temp = MessageType_.response_;
    MessageType_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_response(::iop::locnet::Response* response) {
  clear_MessageType();
  if (response) {
    set_has_response();
    MessageType_.response_ = response;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Message.response)
}

inline bool Message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void Message::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline Message::MessageTypeCase Message::MessageType_case() const {
  return Message::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// optional bytes version = 1;
inline void Request::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request::version() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Request.version)
}
inline void Request::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Request.version)
}
inline void Request::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Request.version)
}
inline ::std::string* Request::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_version() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.version)
}

// optional .iop.locnet.LocalServiceRequest local_service = 2;
inline bool Request::has_local_service() const {
  return RequestType_case() == kLocalService;
}
inline void Request::set_has_local_service() {
  _oneof_case_[0] = kLocalService;
}
inline void Request::clear_local_service() {
  if (has_local_service()) {
    delete RequestType_.local_service_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::LocalServiceRequest& Request::local_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.local_service)
  return has_local_service()
      ? *RequestType_.local_service_
      : ::iop::locnet::LocalServiceRequest::default_instance();
}
inline ::iop::locnet::LocalServiceRequest* Request::mutable_local_service() {
  if (!has_local_service()) {
    clear_RequestType();
    set_has_local_service();
    RequestType_.local_service_ = new ::iop::locnet::LocalServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.local_service)
  return RequestType_.local_service_;
}
inline ::iop::locnet::LocalServiceRequest* Request::release_local_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.local_service)
  if (has_local_service()) {
    clear_has_RequestType();
    ::iop::locnet::LocalServiceRequest* temp = RequestType_.local_service_;
    RequestType_.local_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_local_service(::iop::locnet::LocalServiceRequest* local_service) {
  clear_RequestType();
  if (local_service) {
    set_has_local_service();
    RequestType_.local_service_ = local_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.local_service)
}

// optional .iop.locnet.RemoteNodeRequest remote_node = 3;
inline bool Request::has_remote_node() const {
  return RequestType_case() == kRemoteNode;
}
inline void Request::set_has_remote_node() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Request::clear_remote_node() {
  if (has_remote_node()) {
    delete RequestType_.remote_node_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::RemoteNodeRequest& Request::remote_node() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.remote_node)
  return has_remote_node()
      ? *RequestType_.remote_node_
      : ::iop::locnet::RemoteNodeRequest::default_instance();
}
inline ::iop::locnet::RemoteNodeRequest* Request::mutable_remote_node() {
  if (!has_remote_node()) {
    clear_RequestType();
    set_has_remote_node();
    RequestType_.remote_node_ = new ::iop::locnet::RemoteNodeRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.remote_node)
  return RequestType_.remote_node_;
}
inline ::iop::locnet::RemoteNodeRequest* Request::release_remote_node() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.remote_node)
  if (has_remote_node()) {
    clear_has_RequestType();
    ::iop::locnet::RemoteNodeRequest* temp = RequestType_.remote_node_;
    RequestType_.remote_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_remote_node(::iop::locnet::RemoteNodeRequest* remote_node) {
  clear_RequestType();
  if (remote_node) {
    set_has_remote_node();
    RequestType_.remote_node_ = remote_node;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.remote_node)
}

// optional .iop.locnet.ClientRequest client = 4;
inline bool Request::has_client() const {
  return RequestType_case() == kClient;
}
inline void Request::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Request::clear_client() {
  if (has_client()) {
    delete RequestType_.client_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::ClientRequest& Request::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.client)
  return has_client()
      ? *RequestType_.client_
      : ::iop::locnet::ClientRequest::default_instance();
}
inline ::iop::locnet::ClientRequest* Request::mutable_client() {
  if (!has_client()) {
    clear_RequestType();
    set_has_client();
    RequestType_.client_ = new ::iop::locnet::ClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.client)
  return RequestType_.client_;
}
inline ::iop::locnet::ClientRequest* Request::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.client)
  if (has_client()) {
    clear_has_RequestType();
    ::iop::locnet::ClientRequest* temp = RequestType_.client_;
    RequestType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_client(::iop::locnet::ClientRequest* client) {
  clear_RequestType();
  if (client) {
    set_has_client();
    RequestType_.client_ = client;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.client)
}

inline bool Request::has_RequestType() const {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void Request::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::RequestType_case() const {
  return Request::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .iop.locnet.Status status = 1;
inline void Response::clear_status() {
  status_ = 0;
}
inline ::iop::locnet::Status Response::status() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.status)
  return static_cast< ::iop::locnet::Status >(status_);
}
inline void Response::set_status(::iop::locnet::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.status)
}

// optional sint64 timestamp = 2;
inline void Response::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Response::timestamp() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.timestamp)
  return timestamp_;
}
inline void Response::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.timestamp)
}

// optional string details = 3;
inline void Response::clear_details() {
  details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::details() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.details)
  return details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_details(const ::std::string& value) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Response.details)
}
inline void Response::set_details(const char* value) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Response.details)
}
inline void Response::set_details(const char* value, size_t size) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Response.details)
}
inline ::std::string* Response::mutable_details() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.details)
  return details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_details() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.details)
  
  return details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_details(::std::string* details) {
  if (details != NULL) {
    
  } else {
    
  }
  details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), details);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.details)
}

// optional .iop.locnet.LocalServiceResponse local_service = 4;
inline bool Response::has_local_service() const {
  return ResponseType_case() == kLocalService;
}
inline void Response::set_has_local_service() {
  _oneof_case_[0] = kLocalService;
}
inline void Response::clear_local_service() {
  if (has_local_service()) {
    delete ResponseType_.local_service_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::LocalServiceResponse& Response::local_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.local_service)
  return has_local_service()
      ? *ResponseType_.local_service_
      : ::iop::locnet::LocalServiceResponse::default_instance();
}
inline ::iop::locnet::LocalServiceResponse* Response::mutable_local_service() {
  if (!has_local_service()) {
    clear_ResponseType();
    set_has_local_service();
    ResponseType_.local_service_ = new ::iop::locnet::LocalServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.local_service)
  return ResponseType_.local_service_;
}
inline ::iop::locnet::LocalServiceResponse* Response::release_local_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.local_service)
  if (has_local_service()) {
    clear_has_ResponseType();
    ::iop::locnet::LocalServiceResponse* temp = ResponseType_.local_service_;
    ResponseType_.local_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_local_service(::iop::locnet::LocalServiceResponse* local_service) {
  clear_ResponseType();
  if (local_service) {
    set_has_local_service();
    ResponseType_.local_service_ = local_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.local_service)
}

// optional .iop.locnet.RemoteNodeResponse remote_node = 5;
inline bool Response::has_remote_node() const {
  return ResponseType_case() == kRemoteNode;
}
inline void Response::set_has_remote_node() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Response::clear_remote_node() {
  if (has_remote_node()) {
    delete ResponseType_.remote_node_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::RemoteNodeResponse& Response::remote_node() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.remote_node)
  return has_remote_node()
      ? *ResponseType_.remote_node_
      : ::iop::locnet::RemoteNodeResponse::default_instance();
}
inline ::iop::locnet::RemoteNodeResponse* Response::mutable_remote_node() {
  if (!has_remote_node()) {
    clear_ResponseType();
    set_has_remote_node();
    ResponseType_.remote_node_ = new ::iop::locnet::RemoteNodeResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.remote_node)
  return ResponseType_.remote_node_;
}
inline ::iop::locnet::RemoteNodeResponse* Response::release_remote_node() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.remote_node)
  if (has_remote_node()) {
    clear_has_ResponseType();
    ::iop::locnet::RemoteNodeResponse* temp = ResponseType_.remote_node_;
    ResponseType_.remote_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_remote_node(::iop::locnet::RemoteNodeResponse* remote_node) {
  clear_ResponseType();
  if (remote_node) {
    set_has_remote_node();
    ResponseType_.remote_node_ = remote_node;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.remote_node)
}

// optional .iop.locnet.ClientResponse client = 6;
inline bool Response::has_client() const {
  return ResponseType_case() == kClient;
}
inline void Response::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Response::clear_client() {
  if (has_client()) {
    delete ResponseType_.client_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::ClientResponse& Response::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.client)
  return has_client()
      ? *ResponseType_.client_
      : ::iop::locnet::ClientResponse::default_instance();
}
inline ::iop::locnet::ClientResponse* Response::mutable_client() {
  if (!has_client()) {
    clear_ResponseType();
    set_has_client();
    ResponseType_.client_ = new ::iop::locnet::ClientResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.client)
  return ResponseType_.client_;
}
inline ::iop::locnet::ClientResponse* Response::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.client)
  if (has_client()) {
    clear_has_ResponseType();
    ::iop::locnet::ClientResponse* temp = ResponseType_.client_;
    ResponseType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_client(::iop::locnet::ClientResponse* client) {
  clear_ResponseType();
  if (client) {
    set_has_client();
    ResponseType_.client_ = client;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.client)
}

inline bool Response::has_ResponseType() const {
  return ResponseType_case() != RESPONSETYPE_NOT_SET;
}
inline void Response::clear_has_ResponseType() {
  _oneof_case_[0] = RESPONSETYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::ResponseType_case() const {
  return Response::ResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceRequest

// optional .iop.locnet.RegisterServiceRequest register_service = 1;
inline bool LocalServiceRequest::has_register_service() const {
  return LocalServiceRequestType_case() == kRegisterService;
}
inline void LocalServiceRequest::set_has_register_service() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceRequest::clear_register_service() {
  if (has_register_service()) {
    delete LocalServiceRequestType_.register_service_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::RegisterServiceRequest& LocalServiceRequest::register_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.register_service)
  return has_register_service()
      ? *LocalServiceRequestType_.register_service_
      : ::iop::locnet::RegisterServiceRequest::default_instance();
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::mutable_register_service() {
  if (!has_register_service()) {
    clear_LocalServiceRequestType();
    set_has_register_service();
    LocalServiceRequestType_.register_service_ = new ::iop::locnet::RegisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.register_service)
  return LocalServiceRequestType_.register_service_;
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::release_register_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.register_service)
  if (has_register_service()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::RegisterServiceRequest* temp = LocalServiceRequestType_.register_service_;
    LocalServiceRequestType_.register_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_register_service(::iop::locnet::RegisterServiceRequest* register_service) {
  clear_LocalServiceRequestType();
  if (register_service) {
    set_has_register_service();
    LocalServiceRequestType_.register_service_ = register_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.register_service)
}

// optional .iop.locnet.DeregisterServiceRequest deregister_service = 2;
inline bool LocalServiceRequest::has_deregister_service() const {
  return LocalServiceRequestType_case() == kDeregisterService;
}
inline void LocalServiceRequest::set_has_deregister_service() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceRequest::clear_deregister_service() {
  if (has_deregister_service()) {
    delete LocalServiceRequestType_.deregister_service_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::DeregisterServiceRequest& LocalServiceRequest::deregister_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.deregister_service)
  return has_deregister_service()
      ? *LocalServiceRequestType_.deregister_service_
      : ::iop::locnet::DeregisterServiceRequest::default_instance();
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::mutable_deregister_service() {
  if (!has_deregister_service()) {
    clear_LocalServiceRequestType();
    set_has_deregister_service();
    LocalServiceRequestType_.deregister_service_ = new ::iop::locnet::DeregisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.deregister_service)
  return LocalServiceRequestType_.deregister_service_;
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::release_deregister_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.deregister_service)
  if (has_deregister_service()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::DeregisterServiceRequest* temp = LocalServiceRequestType_.deregister_service_;
    LocalServiceRequestType_.deregister_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_deregister_service(::iop::locnet::DeregisterServiceRequest* deregister_service) {
  clear_LocalServiceRequestType();
  if (deregister_service) {
    set_has_deregister_service();
    LocalServiceRequestType_.deregister_service_ = deregister_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.deregister_service)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceLocalRequest get_neighbour_nodes = 3;
inline bool LocalServiceRequest::has_get_neighbour_nodes() const {
  return LocalServiceRequestType_case() == kGetNeighbourNodes;
}
inline void LocalServiceRequest::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceRequest::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete LocalServiceRequestType_.get_neighbour_nodes_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& LocalServiceRequest::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *LocalServiceRequestType_.get_neighbour_nodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_LocalServiceRequestType();
    set_has_get_neighbour_nodes();
    LocalServiceRequestType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  return LocalServiceRequestType_.get_neighbour_nodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* temp = LocalServiceRequestType_.get_neighbour_nodes_;
    LocalServiceRequestType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* get_neighbour_nodes) {
  clear_LocalServiceRequestType();
  if (get_neighbour_nodes) {
    set_has_get_neighbour_nodes();
    LocalServiceRequestType_.get_neighbour_nodes_ = get_neighbour_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.get_neighbour_nodes)
}

// optional .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhood_changed = 4;
inline bool LocalServiceRequest::has_neighbourhood_changed() const {
  return LocalServiceRequestType_case() == kNeighbourhoodChanged;
}
inline void LocalServiceRequest::set_has_neighbourhood_changed() {
  _oneof_case_[0] = kNeighbourhoodChanged;
}
inline void LocalServiceRequest::clear_neighbourhood_changed() {
  if (has_neighbourhood_changed()) {
    delete LocalServiceRequestType_.neighbourhood_changed_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::NeighbourhoodChangedNotificationRequest& LocalServiceRequest::neighbourhood_changed() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  return has_neighbourhood_changed()
      ? *LocalServiceRequestType_.neighbourhood_changed_
      : ::iop::locnet::NeighbourhoodChangedNotificationRequest::default_instance();
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::mutable_neighbourhood_changed() {
  if (!has_neighbourhood_changed()) {
    clear_LocalServiceRequestType();
    set_has_neighbourhood_changed();
    LocalServiceRequestType_.neighbourhood_changed_ = new ::iop::locnet::NeighbourhoodChangedNotificationRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  return LocalServiceRequestType_.neighbourhood_changed_;
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::release_neighbourhood_changed() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.neighbourhood_changed)
  if (has_neighbourhood_changed()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::NeighbourhoodChangedNotificationRequest* temp = LocalServiceRequestType_.neighbourhood_changed_;
    LocalServiceRequestType_.neighbourhood_changed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_neighbourhood_changed(::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhood_changed) {
  clear_LocalServiceRequestType();
  if (neighbourhood_changed) {
    set_has_neighbourhood_changed();
    LocalServiceRequestType_.neighbourhood_changed_ = neighbourhood_changed;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.neighbourhood_changed)
}

// optional .iop.locnet.GetNodeInfoRequest get_node_info = 5;
inline bool LocalServiceRequest::has_get_node_info() const {
  return LocalServiceRequestType_case() == kGetNodeInfo;
}
inline void LocalServiceRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void LocalServiceRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete LocalServiceRequestType_.get_node_info_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::GetNodeInfoRequest& LocalServiceRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.get_node_info)
  return has_get_node_info()
      ? *LocalServiceRequestType_.get_node_info_
      : ::iop::locnet::GetNodeInfoRequest::default_instance();
}
inline ::iop::locnet::GetNodeInfoRequest* LocalServiceRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_LocalServiceRequestType();
    set_has_get_node_info();
    LocalServiceRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.get_node_info)
  return LocalServiceRequestType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoRequest* LocalServiceRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::GetNodeInfoRequest* temp = LocalServiceRequestType_.get_node_info_;
    LocalServiceRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info) {
  clear_LocalServiceRequestType();
  if (get_node_info) {
    set_has_get_node_info();
    LocalServiceRequestType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.get_node_info)
}

inline bool LocalServiceRequest::has_LocalServiceRequestType() const {
  return LocalServiceRequestType_case() != LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline void LocalServiceRequest::clear_has_LocalServiceRequestType() {
  _oneof_case_[0] = LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline LocalServiceRequest::LocalServiceRequestTypeCase LocalServiceRequest::LocalServiceRequestType_case() const {
  return LocalServiceRequest::LocalServiceRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceResponse

// optional .iop.locnet.RegisterServiceResponse register_service = 1;
inline bool LocalServiceResponse::has_register_service() const {
  return LocalServiceResponseType_case() == kRegisterService;
}
inline void LocalServiceResponse::set_has_register_service() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceResponse::clear_register_service() {
  if (has_register_service()) {
    delete LocalServiceResponseType_.register_service_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::RegisterServiceResponse& LocalServiceResponse::register_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.register_service)
  return has_register_service()
      ? *LocalServiceResponseType_.register_service_
      : ::iop::locnet::RegisterServiceResponse::default_instance();
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::mutable_register_service() {
  if (!has_register_service()) {
    clear_LocalServiceResponseType();
    set_has_register_service();
    LocalServiceResponseType_.register_service_ = new ::iop::locnet::RegisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.register_service)
  return LocalServiceResponseType_.register_service_;
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::release_register_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.register_service)
  if (has_register_service()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::RegisterServiceResponse* temp = LocalServiceResponseType_.register_service_;
    LocalServiceResponseType_.register_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_register_service(::iop::locnet::RegisterServiceResponse* register_service) {
  clear_LocalServiceResponseType();
  if (register_service) {
    set_has_register_service();
    LocalServiceResponseType_.register_service_ = register_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.register_service)
}

// optional .iop.locnet.DeregisterServiceResponse deregister_service = 2;
inline bool LocalServiceResponse::has_deregister_service() const {
  return LocalServiceResponseType_case() == kDeregisterService;
}
inline void LocalServiceResponse::set_has_deregister_service() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceResponse::clear_deregister_service() {
  if (has_deregister_service()) {
    delete LocalServiceResponseType_.deregister_service_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::DeregisterServiceResponse& LocalServiceResponse::deregister_service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.deregister_service)
  return has_deregister_service()
      ? *LocalServiceResponseType_.deregister_service_
      : ::iop::locnet::DeregisterServiceResponse::default_instance();
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::mutable_deregister_service() {
  if (!has_deregister_service()) {
    clear_LocalServiceResponseType();
    set_has_deregister_service();
    LocalServiceResponseType_.deregister_service_ = new ::iop::locnet::DeregisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.deregister_service)
  return LocalServiceResponseType_.deregister_service_;
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::release_deregister_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.deregister_service)
  if (has_deregister_service()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::DeregisterServiceResponse* temp = LocalServiceResponseType_.deregister_service_;
    LocalServiceResponseType_.deregister_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_deregister_service(::iop::locnet::DeregisterServiceResponse* deregister_service) {
  clear_LocalServiceResponseType();
  if (deregister_service) {
    set_has_deregister_service();
    LocalServiceResponseType_.deregister_service_ = deregister_service;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.deregister_service)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 3;
inline bool LocalServiceResponse::has_get_neighbour_nodes() const {
  return LocalServiceResponseType_case() == kGetNeighbourNodes;
}
inline void LocalServiceResponse::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceResponse::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete LocalServiceResponseType_.get_neighbour_nodes_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& LocalServiceResponse::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *LocalServiceResponseType_.get_neighbour_nodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_LocalServiceResponseType();
    set_has_get_neighbour_nodes();
    LocalServiceResponseType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  return LocalServiceResponseType_.get_neighbour_nodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = LocalServiceResponseType_.get_neighbour_nodes_;
    LocalServiceResponseType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes) {
  clear_LocalServiceResponseType();
  if (get_neighbour_nodes) {
    set_has_get_neighbour_nodes();
    LocalServiceResponseType_.get_neighbour_nodes_ = get_neighbour_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.get_neighbour_nodes)
}

// optional .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhood_updated = 4;
inline bool LocalServiceResponse::has_neighbourhood_updated() const {
  return LocalServiceResponseType_case() == kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::set_has_neighbourhood_updated() {
  _oneof_case_[0] = kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::clear_neighbourhood_updated() {
  if (has_neighbourhood_updated()) {
    delete LocalServiceResponseType_.neighbourhood_updated_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::NeighbourhoodChangedNotificationResponse& LocalServiceResponse::neighbourhood_updated() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  return has_neighbourhood_updated()
      ? *LocalServiceResponseType_.neighbourhood_updated_
      : ::iop::locnet::NeighbourhoodChangedNotificationResponse::default_instance();
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::mutable_neighbourhood_updated() {
  if (!has_neighbourhood_updated()) {
    clear_LocalServiceResponseType();
    set_has_neighbourhood_updated();
    LocalServiceResponseType_.neighbourhood_updated_ = new ::iop::locnet::NeighbourhoodChangedNotificationResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  return LocalServiceResponseType_.neighbourhood_updated_;
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::release_neighbourhood_updated() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.neighbourhood_updated)
  if (has_neighbourhood_updated()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::NeighbourhoodChangedNotificationResponse* temp = LocalServiceResponseType_.neighbourhood_updated_;
    LocalServiceResponseType_.neighbourhood_updated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_neighbourhood_updated(::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhood_updated) {
  clear_LocalServiceResponseType();
  if (neighbourhood_updated) {
    set_has_neighbourhood_updated();
    LocalServiceResponseType_.neighbourhood_updated_ = neighbourhood_updated;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.neighbourhood_updated)
}

// optional .iop.locnet.GetNodeInfoResponse get_node_info = 5;
inline bool LocalServiceResponse::has_get_node_info() const {
  return LocalServiceResponseType_case() == kGetNodeInfo;
}
inline void LocalServiceResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void LocalServiceResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete LocalServiceResponseType_.get_node_info_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::GetNodeInfoResponse& LocalServiceResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.get_node_info)
  return has_get_node_info()
      ? *LocalServiceResponseType_.get_node_info_
      : ::iop::locnet::GetNodeInfoResponse::default_instance();
}
inline ::iop::locnet::GetNodeInfoResponse* LocalServiceResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_LocalServiceResponseType();
    set_has_get_node_info();
    LocalServiceResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.get_node_info)
  return LocalServiceResponseType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoResponse* LocalServiceResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::GetNodeInfoResponse* temp = LocalServiceResponseType_.get_node_info_;
    LocalServiceResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info) {
  clear_LocalServiceResponseType();
  if (get_node_info) {
    set_has_get_node_info();
    LocalServiceResponseType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.get_node_info)
}

inline bool LocalServiceResponse::has_LocalServiceResponseType() const {
  return LocalServiceResponseType_case() != LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline void LocalServiceResponse::clear_has_LocalServiceResponseType() {
  _oneof_case_[0] = LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline LocalServiceResponse::LocalServiceResponseTypeCase LocalServiceResponse::LocalServiceResponseType_case() const {
  return LocalServiceResponse::LocalServiceResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterServiceRequest

// optional .iop.locnet.ServiceInfo service = 1;
inline bool RegisterServiceRequest::has_service() const {
  return !_is_default_instance_ && service_ != NULL;
}
inline void RegisterServiceRequest::clear_service() {
  if (GetArenaNoVirtual() == NULL && service_ != NULL) delete service_;
  service_ = NULL;
}
inline const ::iop::locnet::ServiceInfo& RegisterServiceRequest::service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceRequest.service)
  return service_ != NULL ? *service_ : *default_instance_->service_;
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::mutable_service() {
  
  if (service_ == NULL) {
    service_ = new ::iop::locnet::ServiceInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceRequest.service)
  return service_;
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::release_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceRequest.service)
  
  ::iop::locnet::ServiceInfo* temp = service_;
  service_ = NULL;
  return temp;
}
inline void RegisterServiceRequest::set_allocated_service(::iop::locnet::ServiceInfo* service) {
  delete service_;
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceRequest.service)
}

// -------------------------------------------------------------------

// RegisterServiceResponse

// optional .iop.locnet.GpsLocation location = 1;
inline bool RegisterServiceResponse::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void RegisterServiceResponse::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& RegisterServiceResponse::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceResponse.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceResponse.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceResponse.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RegisterServiceResponse::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceResponse.location)
}

// -------------------------------------------------------------------

// DeregisterServiceRequest

// optional .iop.locnet.ServiceType service_type = 1;
inline void DeregisterServiceRequest::clear_service_type() {
  service_type_ = 0;
}
inline ::iop::locnet::ServiceType DeregisterServiceRequest::service_type() const {
  // @@protoc_insertion_point(field_get:iop.locnet.DeregisterServiceRequest.service_type)
  return static_cast< ::iop::locnet::ServiceType >(service_type_);
}
inline void DeregisterServiceRequest::set_service_type(::iop::locnet::ServiceType value) {
  
  service_type_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.DeregisterServiceRequest.service_type)
}

// -------------------------------------------------------------------

// DeregisterServiceResponse

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceLocalRequest

// optional bool keep_alive_and_send_updates = 1;
inline void GetNeighbourNodesByDistanceLocalRequest::clear_keep_alive_and_send_updates() {
  keep_alive_and_send_updates_ = false;
}
inline bool GetNeighbourNodesByDistanceLocalRequest::keep_alive_and_send_updates() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keep_alive_and_send_updates)
  return keep_alive_and_send_updates_;
}
inline void GetNeighbourNodesByDistanceLocalRequest::set_keep_alive_and_send_updates(bool value) {
  
  keep_alive_and_send_updates_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keep_alive_and_send_updates)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetNeighbourNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetNeighbourNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetNeighbourNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetNeighbourNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetNeighbourNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChange

// optional .iop.locnet.NodeInfo added_node_info = 1;
inline bool NeighbourhoodChange::has_added_node_info() const {
  return ChangeType_case() == kAddedNodeInfo;
}
inline void NeighbourhoodChange::set_has_added_node_info() {
  _oneof_case_[0] = kAddedNodeInfo;
}
inline void NeighbourhoodChange::clear_added_node_info() {
  if (has_added_node_info()) {
    delete ChangeType_.added_node_info_;
    clear_has_ChangeType();
  }
}
inline  const ::iop::locnet::NodeInfo& NeighbourhoodChange::added_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.added_node_info)
  return has_added_node_info()
      ? *ChangeType_.added_node_info_
      : ::iop::locnet::NodeInfo::default_instance();
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_added_node_info() {
  if (!has_added_node_info()) {
    clear_ChangeType();
    set_has_added_node_info();
    ChangeType_.added_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.added_node_info)
  return ChangeType_.added_node_info_;
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_added_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.added_node_info)
  if (has_added_node_info()) {
    clear_has_ChangeType();
    ::iop::locnet::NodeInfo* temp = ChangeType_.added_node_info_;
    ChangeType_.added_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_added_node_info(::iop::locnet::NodeInfo* added_node_info) {
  clear_ChangeType();
  if (added_node_info) {
    set_has_added_node_info();
    ChangeType_.added_node_info_ = added_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.added_node_info)
}

// optional .iop.locnet.NodeInfo updated_node_info = 2;
inline bool NeighbourhoodChange::has_updated_node_info() const {
  return ChangeType_case() == kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::set_has_updated_node_info() {
  _oneof_case_[0] = kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::clear_updated_node_info() {
  if (has_updated_node_info()) {
    delete ChangeType_.updated_node_info_;
    clear_has_ChangeType();
  }
}
inline  const ::iop::locnet::NodeInfo& NeighbourhoodChange::updated_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.updated_node_info)
  return has_updated_node_info()
      ? *ChangeType_.updated_node_info_
      : ::iop::locnet::NodeInfo::default_instance();
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_updated_node_info() {
  if (!has_updated_node_info()) {
    clear_ChangeType();
    set_has_updated_node_info();
    ChangeType_.updated_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.updated_node_info)
  return ChangeType_.updated_node_info_;
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_updated_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.updated_node_info)
  if (has_updated_node_info()) {
    clear_has_ChangeType();
    ::iop::locnet::NodeInfo* temp = ChangeType_.updated_node_info_;
    ChangeType_.updated_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_updated_node_info(::iop::locnet::NodeInfo* updated_node_info) {
  clear_ChangeType();
  if (updated_node_info) {
    set_has_updated_node_info();
    ChangeType_.updated_node_info_ = updated_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.updated_node_info)
}

// optional bytes removed_node_id = 3;
inline bool NeighbourhoodChange::has_removed_node_id() const {
  return ChangeType_case() == kRemovedNodeId;
}
inline void NeighbourhoodChange::set_has_removed_node_id() {
  _oneof_case_[0] = kRemovedNodeId;
}
inline void NeighbourhoodChange::clear_removed_node_id() {
  if (has_removed_node_id()) {
    ChangeType_.removed_node_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ChangeType();
  }
}
inline const ::std::string& NeighbourhoodChange::removed_node_id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (has_removed_node_id()) {
    return ChangeType_.removed_node_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void NeighbourhoodChange::set_removed_node_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removed_node_id)
}
inline void NeighbourhoodChange::set_removed_node_id(const char* value) {
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NeighbourhoodChange.removed_node_id)
}
inline void NeighbourhoodChange::set_removed_node_id(const void* value, size_t size) {
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removed_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NeighbourhoodChange.removed_node_id)
}
inline ::std::string* NeighbourhoodChange::mutable_removed_node_id() {
  if (!has_removed_node_id()) {
    clear_ChangeType();
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.removed_node_id)
  return ChangeType_.removed_node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeighbourhoodChange::release_removed_node_id() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.removed_node_id)
  if (has_removed_node_id()) {
    clear_has_ChangeType();
    return ChangeType_.removed_node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_removed_node_id(::std::string* removed_node_id) {
  if (!has_removed_node_id()) {
    ChangeType_.removed_node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_ChangeType();
  if (removed_node_id != NULL) {
    set_has_removed_node_id();
    ChangeType_.removed_node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        removed_node_id);
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.removed_node_id)
}

inline bool NeighbourhoodChange::has_ChangeType() const {
  return ChangeType_case() != CHANGETYPE_NOT_SET;
}
inline void NeighbourhoodChange::clear_has_ChangeType() {
  _oneof_case_[0] = CHANGETYPE_NOT_SET;
}
inline NeighbourhoodChange::ChangeTypeCase NeighbourhoodChange::ChangeType_case() const {
  return NeighbourhoodChange::ChangeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationRequest

// repeated .iop.locnet.NeighbourhoodChange changes = 1;
inline int NeighbourhoodChangedNotificationRequest::changes_size() const {
  return changes_.size();
}
inline void NeighbourhoodChangedNotificationRequest::clear_changes() {
  changes_.Clear();
}
inline const ::iop::locnet::NeighbourhoodChange& NeighbourhoodChangedNotificationRequest::changes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Get(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Mutable(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::add_changes() {
  // @@protoc_insertion_point(field_add:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
NeighbourhoodChangedNotificationRequest::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return &changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
NeighbourhoodChangedNotificationRequest::changes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationResponse

// -------------------------------------------------------------------

// RemoteNodeRequest

// optional .iop.locnet.BuildNetworkRequest accept_colleague = 1;
inline bool RemoteNodeRequest::has_accept_colleague() const {
  return RemoteNodeRequestType_case() == kAcceptColleague;
}
inline void RemoteNodeRequest::set_has_accept_colleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeRequest::clear_accept_colleague() {
  if (has_accept_colleague()) {
    delete RemoteNodeRequestType_.accept_colleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::accept_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.accept_colleague)
  return has_accept_colleague()
      ? *RemoteNodeRequestType_.accept_colleague_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_accept_colleague() {
  if (!has_accept_colleague()) {
    clear_RemoteNodeRequestType();
    set_has_accept_colleague();
    RemoteNodeRequestType_.accept_colleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.accept_colleague)
  return RemoteNodeRequestType_.accept_colleague_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_accept_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.accept_colleague)
  if (has_accept_colleague()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.accept_colleague_;
    RemoteNodeRequestType_.accept_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_accept_colleague(::iop::locnet::BuildNetworkRequest* accept_colleague) {
  clear_RemoteNodeRequestType();
  if (accept_colleague) {
    set_has_accept_colleague();
    RemoteNodeRequestType_.accept_colleague_ = accept_colleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.accept_colleague)
}

// optional .iop.locnet.BuildNetworkRequest renew_colleague = 2;
inline bool RemoteNodeRequest::has_renew_colleague() const {
  return RemoteNodeRequestType_case() == kRenewColleague;
}
inline void RemoteNodeRequest::set_has_renew_colleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeRequest::clear_renew_colleague() {
  if (has_renew_colleague()) {
    delete RemoteNodeRequestType_.renew_colleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renew_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renew_colleague)
  return has_renew_colleague()
      ? *RemoteNodeRequestType_.renew_colleague_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renew_colleague() {
  if (!has_renew_colleague()) {
    clear_RemoteNodeRequestType();
    set_has_renew_colleague();
    RemoteNodeRequestType_.renew_colleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renew_colleague)
  return RemoteNodeRequestType_.renew_colleague_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renew_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renew_colleague)
  if (has_renew_colleague()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renew_colleague_;
    RemoteNodeRequestType_.renew_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_renew_colleague(::iop::locnet::BuildNetworkRequest* renew_colleague) {
  clear_RemoteNodeRequestType();
  if (renew_colleague) {
    set_has_renew_colleague();
    RemoteNodeRequestType_.renew_colleague_ = renew_colleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.renew_colleague)
}

// optional .iop.locnet.BuildNetworkRequest accept_neighbour = 3;
inline bool RemoteNodeRequest::has_accept_neighbour() const {
  return RemoteNodeRequestType_case() == kAcceptNeighbour;
}
inline void RemoteNodeRequest::set_has_accept_neighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeRequest::clear_accept_neighbour() {
  if (has_accept_neighbour()) {
    delete RemoteNodeRequestType_.accept_neighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::accept_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.accept_neighbour)
  return has_accept_neighbour()
      ? *RemoteNodeRequestType_.accept_neighbour_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_accept_neighbour() {
  if (!has_accept_neighbour()) {
    clear_RemoteNodeRequestType();
    set_has_accept_neighbour();
    RemoteNodeRequestType_.accept_neighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.accept_neighbour)
  return RemoteNodeRequestType_.accept_neighbour_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_accept_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.accept_neighbour)
  if (has_accept_neighbour()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.accept_neighbour_;
    RemoteNodeRequestType_.accept_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_accept_neighbour(::iop::locnet::BuildNetworkRequest* accept_neighbour) {
  clear_RemoteNodeRequestType();
  if (accept_neighbour) {
    set_has_accept_neighbour();
    RemoteNodeRequestType_.accept_neighbour_ = accept_neighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.accept_neighbour)
}

// optional .iop.locnet.BuildNetworkRequest renew_neighbour = 4;
inline bool RemoteNodeRequest::has_renew_neighbour() const {
  return RemoteNodeRequestType_case() == kRenewNeighbour;
}
inline void RemoteNodeRequest::set_has_renew_neighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeRequest::clear_renew_neighbour() {
  if (has_renew_neighbour()) {
    delete RemoteNodeRequestType_.renew_neighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renew_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renew_neighbour)
  return has_renew_neighbour()
      ? *RemoteNodeRequestType_.renew_neighbour_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renew_neighbour() {
  if (!has_renew_neighbour()) {
    clear_RemoteNodeRequestType();
    set_has_renew_neighbour();
    RemoteNodeRequestType_.renew_neighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renew_neighbour)
  return RemoteNodeRequestType_.renew_neighbour_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renew_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renew_neighbour)
  if (has_renew_neighbour()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renew_neighbour_;
    RemoteNodeRequestType_.renew_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_renew_neighbour(::iop::locnet::BuildNetworkRequest* renew_neighbour) {
  clear_RemoteNodeRequestType();
  if (renew_neighbour) {
    set_has_renew_neighbour();
    RemoteNodeRequestType_.renew_neighbour_ = renew_neighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.renew_neighbour)
}

// optional .iop.locnet.GetNodeCountRequest get_node_count = 5;
inline bool RemoteNodeRequest::has_get_node_count() const {
  return RemoteNodeRequestType_case() == kGetNodeCount;
}
inline void RemoteNodeRequest::set_has_get_node_count() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeRequest::clear_get_node_count() {
  if (has_get_node_count()) {
    delete RemoteNodeRequestType_.get_node_count_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetNodeCountRequest& RemoteNodeRequest::get_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_node_count)
  return has_get_node_count()
      ? *RemoteNodeRequestType_.get_node_count_
      : ::iop::locnet::GetNodeCountRequest::default_instance();
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::mutable_get_node_count() {
  if (!has_get_node_count()) {
    clear_RemoteNodeRequestType();
    set_has_get_node_count();
    RemoteNodeRequestType_.get_node_count_ = new ::iop::locnet::GetNodeCountRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_node_count)
  return RemoteNodeRequestType_.get_node_count_;
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::release_get_node_count() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_node_count)
  if (has_get_node_count()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetNodeCountRequest* temp = RemoteNodeRequestType_.get_node_count_;
    RemoteNodeRequestType_.get_node_count_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_get_node_count(::iop::locnet::GetNodeCountRequest* get_node_count) {
  clear_RemoteNodeRequestType();
  if (get_node_count) {
    set_has_get_node_count();
    RemoteNodeRequestType_.get_node_count_ = get_node_count;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.get_node_count)
}

// optional .iop.locnet.GetRandomNodesRequest get_random_nodes = 6;
inline bool RemoteNodeRequest::has_get_random_nodes() const {
  return RemoteNodeRequestType_case() == kGetRandomNodes;
}
inline void RemoteNodeRequest::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeRequest::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete RemoteNodeRequestType_.get_random_nodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetRandomNodesRequest& RemoteNodeRequest::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_random_nodes)
  return has_get_random_nodes()
      ? *RemoteNodeRequestType_.get_random_nodes_
      : ::iop::locnet::GetRandomNodesRequest::default_instance();
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_RemoteNodeRequestType();
    set_has_get_random_nodes();
    RemoteNodeRequestType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_random_nodes)
  return RemoteNodeRequestType_.get_random_nodes_;
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetRandomNodesRequest* temp = RemoteNodeRequestType_.get_random_nodes_;
    RemoteNodeRequestType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes) {
  clear_RemoteNodeRequestType();
  if (get_random_nodes) {
    set_has_get_random_nodes();
    RemoteNodeRequestType_.get_random_nodes_ = get_random_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.get_random_nodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 7;
inline bool RemoteNodeRequest::has_get_closest_nodes() const {
  return RemoteNodeRequestType_case() == kGetClosestNodes;
}
inline void RemoteNodeRequest::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeRequest::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete RemoteNodeRequestType_.get_closest_nodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceRequest& RemoteNodeRequest::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  return has_get_closest_nodes()
      ? *RemoteNodeRequestType_.get_closest_nodes_
      : ::iop::locnet::GetClosestNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_RemoteNodeRequestType();
    set_has_get_closest_nodes();
    RemoteNodeRequestType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  return RemoteNodeRequestType_.get_closest_nodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetClosestNodesByDistanceRequest* temp = RemoteNodeRequestType_.get_closest_nodes_;
    RemoteNodeRequestType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes) {
  clear_RemoteNodeRequestType();
  if (get_closest_nodes) {
    set_has_get_closest_nodes();
    RemoteNodeRequestType_.get_closest_nodes_ = get_closest_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.get_closest_nodes)
}

// optional .iop.locnet.GetNodeInfoRequest get_node_info = 8;
inline bool RemoteNodeRequest::has_get_node_info() const {
  return RemoteNodeRequestType_case() == kGetNodeInfo;
}
inline void RemoteNodeRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete RemoteNodeRequestType_.get_node_info_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetNodeInfoRequest& RemoteNodeRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.get_node_info)
  return has_get_node_info()
      ? *RemoteNodeRequestType_.get_node_info_
      : ::iop::locnet::GetNodeInfoRequest::default_instance();
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_RemoteNodeRequestType();
    set_has_get_node_info();
    RemoteNodeRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.get_node_info)
  return RemoteNodeRequestType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetNodeInfoRequest* temp = RemoteNodeRequestType_.get_node_info_;
    RemoteNodeRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info) {
  clear_RemoteNodeRequestType();
  if (get_node_info) {
    set_has_get_node_info();
    RemoteNodeRequestType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.get_node_info)
}

inline bool RemoteNodeRequest::has_RemoteNodeRequestType() const {
  return RemoteNodeRequestType_case() != REMOTENODEREQUESTTYPE_NOT_SET;
}
inline void RemoteNodeRequest::clear_has_RemoteNodeRequestType() {
  _oneof_case_[0] = REMOTENODEREQUESTTYPE_NOT_SET;
}
inline RemoteNodeRequest::RemoteNodeRequestTypeCase RemoteNodeRequest::RemoteNodeRequestType_case() const {
  return RemoteNodeRequest::RemoteNodeRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteNodeResponse

// optional .iop.locnet.BuildNetworkResponse accept_colleague = 1;
inline bool RemoteNodeResponse::has_accept_colleague() const {
  return RemoteNodeResponseType_case() == kAcceptColleague;
}
inline void RemoteNodeResponse::set_has_accept_colleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeResponse::clear_accept_colleague() {
  if (has_accept_colleague()) {
    delete RemoteNodeResponseType_.accept_colleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::accept_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.accept_colleague)
  return has_accept_colleague()
      ? *RemoteNodeResponseType_.accept_colleague_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_accept_colleague() {
  if (!has_accept_colleague()) {
    clear_RemoteNodeResponseType();
    set_has_accept_colleague();
    RemoteNodeResponseType_.accept_colleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.accept_colleague)
  return RemoteNodeResponseType_.accept_colleague_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_accept_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.accept_colleague)
  if (has_accept_colleague()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.accept_colleague_;
    RemoteNodeResponseType_.accept_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_accept_colleague(::iop::locnet::BuildNetworkResponse* accept_colleague) {
  clear_RemoteNodeResponseType();
  if (accept_colleague) {
    set_has_accept_colleague();
    RemoteNodeResponseType_.accept_colleague_ = accept_colleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.accept_colleague)
}

// optional .iop.locnet.BuildNetworkResponse renew_colleague = 2;
inline bool RemoteNodeResponse::has_renew_colleague() const {
  return RemoteNodeResponseType_case() == kRenewColleague;
}
inline void RemoteNodeResponse::set_has_renew_colleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeResponse::clear_renew_colleague() {
  if (has_renew_colleague()) {
    delete RemoteNodeResponseType_.renew_colleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renew_colleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renew_colleague)
  return has_renew_colleague()
      ? *RemoteNodeResponseType_.renew_colleague_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renew_colleague() {
  if (!has_renew_colleague()) {
    clear_RemoteNodeResponseType();
    set_has_renew_colleague();
    RemoteNodeResponseType_.renew_colleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renew_colleague)
  return RemoteNodeResponseType_.renew_colleague_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renew_colleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renew_colleague)
  if (has_renew_colleague()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renew_colleague_;
    RemoteNodeResponseType_.renew_colleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_renew_colleague(::iop::locnet::BuildNetworkResponse* renew_colleague) {
  clear_RemoteNodeResponseType();
  if (renew_colleague) {
    set_has_renew_colleague();
    RemoteNodeResponseType_.renew_colleague_ = renew_colleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.renew_colleague)
}

// optional .iop.locnet.BuildNetworkResponse accept_neighbour = 3;
inline bool RemoteNodeResponse::has_accept_neighbour() const {
  return RemoteNodeResponseType_case() == kAcceptNeighbour;
}
inline void RemoteNodeResponse::set_has_accept_neighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeResponse::clear_accept_neighbour() {
  if (has_accept_neighbour()) {
    delete RemoteNodeResponseType_.accept_neighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::accept_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.accept_neighbour)
  return has_accept_neighbour()
      ? *RemoteNodeResponseType_.accept_neighbour_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_accept_neighbour() {
  if (!has_accept_neighbour()) {
    clear_RemoteNodeResponseType();
    set_has_accept_neighbour();
    RemoteNodeResponseType_.accept_neighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.accept_neighbour)
  return RemoteNodeResponseType_.accept_neighbour_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_accept_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.accept_neighbour)
  if (has_accept_neighbour()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.accept_neighbour_;
    RemoteNodeResponseType_.accept_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_accept_neighbour(::iop::locnet::BuildNetworkResponse* accept_neighbour) {
  clear_RemoteNodeResponseType();
  if (accept_neighbour) {
    set_has_accept_neighbour();
    RemoteNodeResponseType_.accept_neighbour_ = accept_neighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.accept_neighbour)
}

// optional .iop.locnet.BuildNetworkResponse renew_neighbour = 4;
inline bool RemoteNodeResponse::has_renew_neighbour() const {
  return RemoteNodeResponseType_case() == kRenewNeighbour;
}
inline void RemoteNodeResponse::set_has_renew_neighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeResponse::clear_renew_neighbour() {
  if (has_renew_neighbour()) {
    delete RemoteNodeResponseType_.renew_neighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renew_neighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renew_neighbour)
  return has_renew_neighbour()
      ? *RemoteNodeResponseType_.renew_neighbour_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renew_neighbour() {
  if (!has_renew_neighbour()) {
    clear_RemoteNodeResponseType();
    set_has_renew_neighbour();
    RemoteNodeResponseType_.renew_neighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renew_neighbour)
  return RemoteNodeResponseType_.renew_neighbour_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renew_neighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renew_neighbour)
  if (has_renew_neighbour()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renew_neighbour_;
    RemoteNodeResponseType_.renew_neighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_renew_neighbour(::iop::locnet::BuildNetworkResponse* renew_neighbour) {
  clear_RemoteNodeResponseType();
  if (renew_neighbour) {
    set_has_renew_neighbour();
    RemoteNodeResponseType_.renew_neighbour_ = renew_neighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.renew_neighbour)
}

// optional .iop.locnet.GetNodeCountResponse get_node_count = 5;
inline bool RemoteNodeResponse::has_get_node_count() const {
  return RemoteNodeResponseType_case() == kGetNodeCount;
}
inline void RemoteNodeResponse::set_has_get_node_count() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeResponse::clear_get_node_count() {
  if (has_get_node_count()) {
    delete RemoteNodeResponseType_.get_node_count_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetNodeCountResponse& RemoteNodeResponse::get_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_node_count)
  return has_get_node_count()
      ? *RemoteNodeResponseType_.get_node_count_
      : ::iop::locnet::GetNodeCountResponse::default_instance();
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::mutable_get_node_count() {
  if (!has_get_node_count()) {
    clear_RemoteNodeResponseType();
    set_has_get_node_count();
    RemoteNodeResponseType_.get_node_count_ = new ::iop::locnet::GetNodeCountResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_node_count)
  return RemoteNodeResponseType_.get_node_count_;
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::release_get_node_count() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_node_count)
  if (has_get_node_count()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetNodeCountResponse* temp = RemoteNodeResponseType_.get_node_count_;
    RemoteNodeResponseType_.get_node_count_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_get_node_count(::iop::locnet::GetNodeCountResponse* get_node_count) {
  clear_RemoteNodeResponseType();
  if (get_node_count) {
    set_has_get_node_count();
    RemoteNodeResponseType_.get_node_count_ = get_node_count;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.get_node_count)
}

// optional .iop.locnet.GetRandomNodesResponse get_random_nodes = 6;
inline bool RemoteNodeResponse::has_get_random_nodes() const {
  return RemoteNodeResponseType_case() == kGetRandomNodes;
}
inline void RemoteNodeResponse::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeResponse::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete RemoteNodeResponseType_.get_random_nodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetRandomNodesResponse& RemoteNodeResponse::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_random_nodes)
  return has_get_random_nodes()
      ? *RemoteNodeResponseType_.get_random_nodes_
      : ::iop::locnet::GetRandomNodesResponse::default_instance();
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_RemoteNodeResponseType();
    set_has_get_random_nodes();
    RemoteNodeResponseType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_random_nodes)
  return RemoteNodeResponseType_.get_random_nodes_;
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetRandomNodesResponse* temp = RemoteNodeResponseType_.get_random_nodes_;
    RemoteNodeResponseType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes) {
  clear_RemoteNodeResponseType();
  if (get_random_nodes) {
    set_has_get_random_nodes();
    RemoteNodeResponseType_.get_random_nodes_ = get_random_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.get_random_nodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 7;
inline bool RemoteNodeResponse::has_get_closest_nodes() const {
  return RemoteNodeResponseType_case() == kGetClosestNodes;
}
inline void RemoteNodeResponse::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeResponse::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete RemoteNodeResponseType_.get_closest_nodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceResponse& RemoteNodeResponse::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  return has_get_closest_nodes()
      ? *RemoteNodeResponseType_.get_closest_nodes_
      : ::iop::locnet::GetClosestNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_RemoteNodeResponseType();
    set_has_get_closest_nodes();
    RemoteNodeResponseType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  return RemoteNodeResponseType_.get_closest_nodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetClosestNodesByDistanceResponse* temp = RemoteNodeResponseType_.get_closest_nodes_;
    RemoteNodeResponseType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes) {
  clear_RemoteNodeResponseType();
  if (get_closest_nodes) {
    set_has_get_closest_nodes();
    RemoteNodeResponseType_.get_closest_nodes_ = get_closest_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.get_closest_nodes)
}

// optional .iop.locnet.GetNodeInfoResponse get_node_info = 8;
inline bool RemoteNodeResponse::has_get_node_info() const {
  return RemoteNodeResponseType_case() == kGetNodeInfo;
}
inline void RemoteNodeResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete RemoteNodeResponseType_.get_node_info_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetNodeInfoResponse& RemoteNodeResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.get_node_info)
  return has_get_node_info()
      ? *RemoteNodeResponseType_.get_node_info_
      : ::iop::locnet::GetNodeInfoResponse::default_instance();
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_RemoteNodeResponseType();
    set_has_get_node_info();
    RemoteNodeResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.get_node_info)
  return RemoteNodeResponseType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetNodeInfoResponse* temp = RemoteNodeResponseType_.get_node_info_;
    RemoteNodeResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info) {
  clear_RemoteNodeResponseType();
  if (get_node_info) {
    set_has_get_node_info();
    RemoteNodeResponseType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.get_node_info)
}

inline bool RemoteNodeResponse::has_RemoteNodeResponseType() const {
  return RemoteNodeResponseType_case() != REMOTENODERESPONSETYPE_NOT_SET;
}
inline void RemoteNodeResponse::clear_has_RemoteNodeResponseType() {
  _oneof_case_[0] = REMOTENODERESPONSETYPE_NOT_SET;
}
inline RemoteNodeResponse::RemoteNodeResponseTypeCase RemoteNodeResponse::RemoteNodeResponseType_case() const {
  return RemoteNodeResponse::RemoteNodeResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BuildNetworkRequest

// optional .iop.locnet.NodeInfo requestor_node_info = 1;
inline bool BuildNetworkRequest::has_requestor_node_info() const {
  return !_is_default_instance_ && requestor_node_info_ != NULL;
}
inline void BuildNetworkRequest::clear_requestor_node_info() {
  if (GetArenaNoVirtual() == NULL && requestor_node_info_ != NULL) delete requestor_node_info_;
  requestor_node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkRequest::requestor_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkRequest.requestor_node_info)
  return requestor_node_info_ != NULL ? *requestor_node_info_ : *default_instance_->requestor_node_info_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::mutable_requestor_node_info() {
  
  if (requestor_node_info_ == NULL) {
    requestor_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkRequest.requestor_node_info)
  return requestor_node_info_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::release_requestor_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkRequest.requestor_node_info)
  
  ::iop::locnet::NodeInfo* temp = requestor_node_info_;
  requestor_node_info_ = NULL;
  return temp;
}
inline void BuildNetworkRequest::set_allocated_requestor_node_info(::iop::locnet::NodeInfo* requestor_node_info) {
  delete requestor_node_info_;
  requestor_node_info_ = requestor_node_info;
  if (requestor_node_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkRequest.requestor_node_info)
}

// -------------------------------------------------------------------

// BuildNetworkResponse

// optional bool accepted = 1;
inline void BuildNetworkResponse::clear_accepted() {
  accepted_ = false;
}
inline bool BuildNetworkResponse::accepted() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.accepted)
  return accepted_;
}
inline void BuildNetworkResponse::set_accepted(bool value) {
  
  accepted_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.accepted)
}

// optional .iop.locnet.NodeInfo acceptor_node_info = 2;
inline bool BuildNetworkResponse::has_acceptor_node_info() const {
  return !_is_default_instance_ && acceptor_node_info_ != NULL;
}
inline void BuildNetworkResponse::clear_acceptor_node_info() {
  if (GetArenaNoVirtual() == NULL && acceptor_node_info_ != NULL) delete acceptor_node_info_;
  acceptor_node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkResponse::acceptor_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  return acceptor_node_info_ != NULL ? *acceptor_node_info_ : *default_instance_->acceptor_node_info_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::mutable_acceptor_node_info() {
  
  if (acceptor_node_info_ == NULL) {
    acceptor_node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  return acceptor_node_info_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::release_acceptor_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.acceptor_node_info)
  
  ::iop::locnet::NodeInfo* temp = acceptor_node_info_;
  acceptor_node_info_ = NULL;
  return temp;
}
inline void BuildNetworkResponse::set_allocated_acceptor_node_info(::iop::locnet::NodeInfo* acceptor_node_info) {
  delete acceptor_node_info_;
  acceptor_node_info_ = acceptor_node_info;
  if (acceptor_node_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.acceptor_node_info)
}

// optional bytes remote_ip_address = 3;
inline void BuildNetworkResponse::clear_remote_ip_address() {
  remote_ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildNetworkResponse::remote_ip_address() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.remote_ip_address)
  return remote_ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildNetworkResponse::set_remote_ip_address(const ::std::string& value) {
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
inline void BuildNetworkResponse::set_remote_ip_address(const char* value) {
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
inline void BuildNetworkResponse::set_remote_ip_address(const void* value, size_t size) {
  
  remote_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.BuildNetworkResponse.remote_ip_address)
}
inline ::std::string* BuildNetworkResponse::mutable_remote_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.remote_ip_address)
  return remote_ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildNetworkResponse::release_remote_ip_address() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.remote_ip_address)
  
  return remote_ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildNetworkResponse::set_allocated_remote_ip_address(::std::string* remote_ip_address) {
  if (remote_ip_address != NULL) {
    
  } else {
    
  }
  remote_ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip_address);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.remote_ip_address)
}

// -------------------------------------------------------------------

// GetNodeCountRequest

// -------------------------------------------------------------------

// GetNodeCountResponse

// optional uint32 node_count = 1;
inline void GetNodeCountResponse::clear_node_count() {
  node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeCountResponse::node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeCountResponse.node_count)
  return node_count_;
}
inline void GetNodeCountResponse::set_node_count(::google::protobuf::uint32 value) {
  
  node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNodeCountResponse.node_count)
}

// -------------------------------------------------------------------

// GetRandomNodesRequest

// optional uint32 max_node_count = 1;
inline void GetRandomNodesRequest::clear_max_node_count() {
  max_node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetRandomNodesRequest::max_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.max_node_count)
  return max_node_count_;
}
inline void GetRandomNodesRequest::set_max_node_count(::google::protobuf::uint32 value) {
  
  max_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.max_node_count)
}

// optional bool include_neighbours = 2;
inline void GetRandomNodesRequest::clear_include_neighbours() {
  include_neighbours_ = false;
}
inline bool GetRandomNodesRequest::include_neighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.include_neighbours)
  return include_neighbours_;
}
inline void GetRandomNodesRequest::set_include_neighbours(bool value) {
  
  include_neighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.include_neighbours)
}

// -------------------------------------------------------------------

// GetRandomNodesResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetRandomNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetRandomNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetRandomNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetRandomNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetRandomNodesResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetRandomNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceRequest

// optional .iop.locnet.GpsLocation location = 1;
inline bool GetClosestNodesByDistanceRequest::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void GetClosestNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& GetClosestNodesByDistanceRequest::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetClosestNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void GetClosestNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetClosestNodesByDistanceRequest.location)
}

// optional float max_radius_km = 2;
inline void GetClosestNodesByDistanceRequest::clear_max_radius_km() {
  max_radius_km_ = 0;
}
inline float GetClosestNodesByDistanceRequest::max_radius_km() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.max_radius_km)
  return max_radius_km_;
}
inline void GetClosestNodesByDistanceRequest::set_max_radius_km(float value) {
  
  max_radius_km_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.max_radius_km)
}

// optional uint32 max_node_count = 3;
inline void GetClosestNodesByDistanceRequest::clear_max_node_count() {
  max_node_count_ = 0u;
}
inline ::google::protobuf::uint32 GetClosestNodesByDistanceRequest::max_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.max_node_count)
  return max_node_count_;
}
inline void GetClosestNodesByDistanceRequest::set_max_node_count(::google::protobuf::uint32 value) {
  
  max_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.max_node_count)
}

// optional bool include_neighbours = 4;
inline void GetClosestNodesByDistanceRequest::clear_include_neighbours() {
  include_neighbours_ = false;
}
inline bool GetClosestNodesByDistanceRequest::include_neighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.include_neighbours)
  return include_neighbours_;
}
inline void GetClosestNodesByDistanceRequest::set_include_neighbours(bool value) {
  
  include_neighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.include_neighbours)
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetClosestNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetClosestNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetClosestNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetClosestNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetClosestNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// ClientRequest

// optional .iop.locnet.GetNodeInfoRequest get_node_info = 1;
inline bool ClientRequest::has_get_node_info() const {
  return ClientRequestType_case() == kGetNodeInfo;
}
inline void ClientRequest::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientRequest::clear_get_node_info() {
  if (has_get_node_info()) {
    delete ClientRequestType_.get_node_info_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetNodeInfoRequest& ClientRequest::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_node_info)
  return has_get_node_info()
      ? *ClientRequestType_.get_node_info_
      : ::iop::locnet::GetNodeInfoRequest::default_instance();
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_ClientRequestType();
    set_has_get_node_info();
    ClientRequestType_.get_node_info_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_node_info)
  return ClientRequestType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_node_info)
  if (has_get_node_info()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetNodeInfoRequest* temp = ClientRequestType_.get_node_info_;
    ClientRequestType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_get_node_info(::iop::locnet::GetNodeInfoRequest* get_node_info) {
  clear_ClientRequestType();
  if (get_node_info) {
    set_has_get_node_info();
    ClientRequestType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.get_node_info)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceClientRequest get_neighbour_nodes = 2;
inline bool ClientRequest::has_get_neighbour_nodes() const {
  return ClientRequestType_case() == kGetNeighbourNodes;
}
inline void ClientRequest::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientRequest::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete ClientRequestType_.get_neighbour_nodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& ClientRequest::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *ClientRequestType_.get_neighbour_nodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceClientRequest::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_ClientRequestType();
    set_has_get_neighbour_nodes();
    ClientRequestType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_neighbour_nodes)
  return ClientRequestType_.get_neighbour_nodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* temp = ClientRequestType_.get_neighbour_nodes_;
    ClientRequestType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceClientRequest* get_neighbour_nodes) {
  clear_ClientRequestType();
  if (get_neighbour_nodes) {
    set_has_get_neighbour_nodes();
    ClientRequestType_.get_neighbour_nodes_ = get_neighbour_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.get_neighbour_nodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceRequest get_closest_nodes = 3;
inline bool ClientRequest::has_get_closest_nodes() const {
  return ClientRequestType_case() == kGetClosestNodes;
}
inline void ClientRequest::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientRequest::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete ClientRequestType_.get_closest_nodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceRequest& ClientRequest::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_closest_nodes)
  return has_get_closest_nodes()
      ? *ClientRequestType_.get_closest_nodes_
      : ::iop::locnet::GetClosestNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_ClientRequestType();
    set_has_get_closest_nodes();
    ClientRequestType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_closest_nodes)
  return ClientRequestType_.get_closest_nodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetClosestNodesByDistanceRequest* temp = ClientRequestType_.get_closest_nodes_;
    ClientRequestType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceRequest* get_closest_nodes) {
  clear_ClientRequestType();
  if (get_closest_nodes) {
    set_has_get_closest_nodes();
    ClientRequestType_.get_closest_nodes_ = get_closest_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.get_closest_nodes)
}

// optional .iop.locnet.ExploreNetworkNodesByDistanceRequest explore_nodes = 4;
inline bool ClientRequest::has_explore_nodes() const {
  return ClientRequestType_case() == kExploreNodes;
}
inline void ClientRequest::set_has_explore_nodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientRequest::clear_explore_nodes() {
  if (has_explore_nodes()) {
    delete ClientRequestType_.explore_nodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& ClientRequest::explore_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.explore_nodes)
  return has_explore_nodes()
      ? *ClientRequestType_.explore_nodes_
      : ::iop::locnet::ExploreNetworkNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::mutable_explore_nodes() {
  if (!has_explore_nodes()) {
    clear_ClientRequestType();
    set_has_explore_nodes();
    ClientRequestType_.explore_nodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.explore_nodes)
  return ClientRequestType_.explore_nodes_;
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::release_explore_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.explore_nodes)
  if (has_explore_nodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::ExploreNetworkNodesByDistanceRequest* temp = ClientRequestType_.explore_nodes_;
    ClientRequestType_.explore_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceRequest* explore_nodes) {
  clear_ClientRequestType();
  if (explore_nodes) {
    set_has_explore_nodes();
    ClientRequestType_.explore_nodes_ = explore_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.explore_nodes)
}

// optional .iop.locnet.GetRandomNodesRequest get_random_nodes = 5;
inline bool ClientRequest::has_get_random_nodes() const {
  return ClientRequestType_case() == kGetRandomNodes;
}
inline void ClientRequest::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void ClientRequest::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete ClientRequestType_.get_random_nodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetRandomNodesRequest& ClientRequest::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.get_random_nodes)
  return has_get_random_nodes()
      ? *ClientRequestType_.get_random_nodes_
      : ::iop::locnet::GetRandomNodesRequest::default_instance();
}
inline ::iop::locnet::GetRandomNodesRequest* ClientRequest::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_ClientRequestType();
    set_has_get_random_nodes();
    ClientRequestType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.get_random_nodes)
  return ClientRequestType_.get_random_nodes_;
}
inline ::iop::locnet::GetRandomNodesRequest* ClientRequest::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetRandomNodesRequest* temp = ClientRequestType_.get_random_nodes_;
    ClientRequestType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesRequest* get_random_nodes) {
  clear_ClientRequestType();
  if (get_random_nodes) {
    set_has_get_random_nodes();
    ClientRequestType_.get_random_nodes_ = get_random_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.get_random_nodes)
}

inline bool ClientRequest::has_ClientRequestType() const {
  return ClientRequestType_case() != CLIENTREQUESTTYPE_NOT_SET;
}
inline void ClientRequest::clear_has_ClientRequestType() {
  _oneof_case_[0] = CLIENTREQUESTTYPE_NOT_SET;
}
inline ClientRequest::ClientRequestTypeCase ClientRequest::ClientRequestType_case() const {
  return ClientRequest::ClientRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientResponse

// optional .iop.locnet.GetNodeInfoResponse get_node_info = 1;
inline bool ClientResponse::has_get_node_info() const {
  return ClientResponseType_case() == kGetNodeInfo;
}
inline void ClientResponse::set_has_get_node_info() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientResponse::clear_get_node_info() {
  if (has_get_node_info()) {
    delete ClientResponseType_.get_node_info_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetNodeInfoResponse& ClientResponse::get_node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_node_info)
  return has_get_node_info()
      ? *ClientResponseType_.get_node_info_
      : ::iop::locnet::GetNodeInfoResponse::default_instance();
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::mutable_get_node_info() {
  if (!has_get_node_info()) {
    clear_ClientResponseType();
    set_has_get_node_info();
    ClientResponseType_.get_node_info_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_node_info)
  return ClientResponseType_.get_node_info_;
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::release_get_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_node_info)
  if (has_get_node_info()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetNodeInfoResponse* temp = ClientResponseType_.get_node_info_;
    ClientResponseType_.get_node_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_get_node_info(::iop::locnet::GetNodeInfoResponse* get_node_info) {
  clear_ClientResponseType();
  if (get_node_info) {
    set_has_get_node_info();
    ClientResponseType_.get_node_info_ = get_node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.get_node_info)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceResponse get_neighbour_nodes = 2;
inline bool ClientResponse::has_get_neighbour_nodes() const {
  return ClientResponseType_case() == kGetNeighbourNodes;
}
inline void ClientResponse::set_has_get_neighbour_nodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientResponse::clear_get_neighbour_nodes() {
  if (has_get_neighbour_nodes()) {
    delete ClientResponseType_.get_neighbour_nodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& ClientResponse::get_neighbour_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_neighbour_nodes)
  return has_get_neighbour_nodes()
      ? *ClientResponseType_.get_neighbour_nodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::mutable_get_neighbour_nodes() {
  if (!has_get_neighbour_nodes()) {
    clear_ClientResponseType();
    set_has_get_neighbour_nodes();
    ClientResponseType_.get_neighbour_nodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_neighbour_nodes)
  return ClientResponseType_.get_neighbour_nodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::release_get_neighbour_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_neighbour_nodes)
  if (has_get_neighbour_nodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = ClientResponseType_.get_neighbour_nodes_;
    ClientResponseType_.get_neighbour_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_get_neighbour_nodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* get_neighbour_nodes) {
  clear_ClientResponseType();
  if (get_neighbour_nodes) {
    set_has_get_neighbour_nodes();
    ClientResponseType_.get_neighbour_nodes_ = get_neighbour_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.get_neighbour_nodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceResponse get_closest_nodes = 3;
inline bool ClientResponse::has_get_closest_nodes() const {
  return ClientResponseType_case() == kGetClosestNodes;
}
inline void ClientResponse::set_has_get_closest_nodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientResponse::clear_get_closest_nodes() {
  if (has_get_closest_nodes()) {
    delete ClientResponseType_.get_closest_nodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceResponse& ClientResponse::get_closest_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_closest_nodes)
  return has_get_closest_nodes()
      ? *ClientResponseType_.get_closest_nodes_
      : ::iop::locnet::GetClosestNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::mutable_get_closest_nodes() {
  if (!has_get_closest_nodes()) {
    clear_ClientResponseType();
    set_has_get_closest_nodes();
    ClientResponseType_.get_closest_nodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_closest_nodes)
  return ClientResponseType_.get_closest_nodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::release_get_closest_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_closest_nodes)
  if (has_get_closest_nodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetClosestNodesByDistanceResponse* temp = ClientResponseType_.get_closest_nodes_;
    ClientResponseType_.get_closest_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_get_closest_nodes(::iop::locnet::GetClosestNodesByDistanceResponse* get_closest_nodes) {
  clear_ClientResponseType();
  if (get_closest_nodes) {
    set_has_get_closest_nodes();
    ClientResponseType_.get_closest_nodes_ = get_closest_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.get_closest_nodes)
}

// optional .iop.locnet.ExploreNetworkNodesByDistanceResponse explore_nodes = 4;
inline bool ClientResponse::has_explore_nodes() const {
  return ClientResponseType_case() == kExploreNodes;
}
inline void ClientResponse::set_has_explore_nodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientResponse::clear_explore_nodes() {
  if (has_explore_nodes()) {
    delete ClientResponseType_.explore_nodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& ClientResponse::explore_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.explore_nodes)
  return has_explore_nodes()
      ? *ClientResponseType_.explore_nodes_
      : ::iop::locnet::ExploreNetworkNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::mutable_explore_nodes() {
  if (!has_explore_nodes()) {
    clear_ClientResponseType();
    set_has_explore_nodes();
    ClientResponseType_.explore_nodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.explore_nodes)
  return ClientResponseType_.explore_nodes_;
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::release_explore_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.explore_nodes)
  if (has_explore_nodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::ExploreNetworkNodesByDistanceResponse* temp = ClientResponseType_.explore_nodes_;
    ClientResponseType_.explore_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_explore_nodes(::iop::locnet::ExploreNetworkNodesByDistanceResponse* explore_nodes) {
  clear_ClientResponseType();
  if (explore_nodes) {
    set_has_explore_nodes();
    ClientResponseType_.explore_nodes_ = explore_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.explore_nodes)
}

// optional .iop.locnet.GetRandomNodesResponse get_random_nodes = 5;
inline bool ClientResponse::has_get_random_nodes() const {
  return ClientResponseType_case() == kGetRandomNodes;
}
inline void ClientResponse::set_has_get_random_nodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void ClientResponse::clear_get_random_nodes() {
  if (has_get_random_nodes()) {
    delete ClientResponseType_.get_random_nodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetRandomNodesResponse& ClientResponse::get_random_nodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.get_random_nodes)
  return has_get_random_nodes()
      ? *ClientResponseType_.get_random_nodes_
      : ::iop::locnet::GetRandomNodesResponse::default_instance();
}
inline ::iop::locnet::GetRandomNodesResponse* ClientResponse::mutable_get_random_nodes() {
  if (!has_get_random_nodes()) {
    clear_ClientResponseType();
    set_has_get_random_nodes();
    ClientResponseType_.get_random_nodes_ = new ::iop::locnet::GetRandomNodesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.get_random_nodes)
  return ClientResponseType_.get_random_nodes_;
}
inline ::iop::locnet::GetRandomNodesResponse* ClientResponse::release_get_random_nodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.get_random_nodes)
  if (has_get_random_nodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetRandomNodesResponse* temp = ClientResponseType_.get_random_nodes_;
    ClientResponseType_.get_random_nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_get_random_nodes(::iop::locnet::GetRandomNodesResponse* get_random_nodes) {
  clear_ClientResponseType();
  if (get_random_nodes) {
    set_has_get_random_nodes();
    ClientResponseType_.get_random_nodes_ = get_random_nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.get_random_nodes)
}

inline bool ClientResponse::has_ClientResponseType() const {
  return ClientResponseType_case() != CLIENTRESPONSETYPE_NOT_SET;
}
inline void ClientResponse::clear_has_ClientResponseType() {
  _oneof_case_[0] = CLIENTRESPONSETYPE_NOT_SET;
}
inline ClientResponse::ClientResponseTypeCase ClientResponse::ClientResponseType_case() const {
  return ClientResponse::ClientResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetNodeInfoRequest

// -------------------------------------------------------------------

// GetNodeInfoResponse

// optional .iop.locnet.NodeInfo node_info = 1;
inline bool GetNodeInfoResponse::has_node_info() const {
  return !_is_default_instance_ && node_info_ != NULL;
}
inline void GetNodeInfoResponse::clear_node_info() {
  if (GetArenaNoVirtual() == NULL && node_info_ != NULL) delete node_info_;
  node_info_ = NULL;
}
inline const ::iop::locnet::NodeInfo& GetNodeInfoResponse::node_info() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeInfoResponse.node_info)
  return node_info_ != NULL ? *node_info_ : *default_instance_->node_info_;
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::mutable_node_info() {
  
  if (node_info_ == NULL) {
    node_info_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNodeInfoResponse.node_info)
  return node_info_;
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::release_node_info() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetNodeInfoResponse.node_info)
  
  ::iop::locnet::NodeInfo* temp = node_info_;
  node_info_ = NULL;
  return temp;
}
inline void GetNodeInfoResponse::set_allocated_node_info(::iop::locnet::NodeInfo* node_info) {
  delete node_info_;
  node_info_ = node_info;
  if (node_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetNodeInfoResponse.node_info)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceClientRequest

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceRequest

// optional .iop.locnet.GpsLocation location = 1;
inline bool ExploreNetworkNodesByDistanceRequest::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void ExploreNetworkNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& ExploreNetworkNodesByDistanceRequest::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void ExploreNetworkNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
}

// optional uint32 target_node_count = 2;
inline void ExploreNetworkNodesByDistanceRequest::clear_target_node_count() {
  target_node_count_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::target_node_count() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.target_node_count)
  return target_node_count_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_target_node_count(::google::protobuf::uint32 value) {
  
  target_node_count_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.target_node_count)
}

// optional uint32 max_node_hops = 3;
inline void ExploreNetworkNodesByDistanceRequest::clear_max_node_hops() {
  max_node_hops_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::max_node_hops() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.max_node_hops)
  return max_node_hops_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_max_node_hops(::google::protobuf::uint32 value) {
  
  max_node_hops_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.max_node_hops)
}

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo closest_nodes = 1;
inline int ExploreNetworkNodesByDistanceResponse::closest_nodes_size() const {
  return closest_nodes_.size();
}
inline void ExploreNetworkNodesByDistanceResponse::clear_closest_nodes() {
  closest_nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& ExploreNetworkNodesByDistanceResponse::closest_nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::mutable_closest_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::add_closest_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
ExploreNetworkNodesByDistanceResponse::mutable_closest_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return &closest_nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
ExploreNetworkNodesByDistanceResponse::closest_nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closest_nodes)
  return closest_nodes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace locnet
}  // namespace iop

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::iop::locnet::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iop::locnet::Status>() {
  return ::iop::locnet::Status_descriptor();
}
template <> struct is_proto_enum< ::iop::locnet::ServiceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iop::locnet::ServiceType>() {
  return ::iop::locnet::ServiceType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IopLocNet_2eproto__INCLUDED
