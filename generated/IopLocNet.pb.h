// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IopLocNet.proto

#ifndef PROTOBUF_IopLocNet_2eproto__INCLUDED
#define PROTOBUF_IopLocNet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace iop {
namespace locnet {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_IopLocNet_2eproto();
void protobuf_AssignDesc_IopLocNet_2eproto();
void protobuf_ShutdownFile_IopLocNet_2eproto();

class BuildNetworkRequest;
class BuildNetworkResponse;
class ClientRequest;
class ClientResponse;
class DeregisterServiceRequest;
class DeregisterServiceResponse;
class ExploreNetworkNodesByDistanceRequest;
class ExploreNetworkNodesByDistanceResponse;
class GetClosestNodesByDistanceRequest;
class GetClosestNodesByDistanceResponse;
class GetNeighbourNodesByDistanceClientRequest;
class GetNeighbourNodesByDistanceLocalRequest;
class GetNeighbourNodesByDistanceResponse;
class GetNodeCountRequest;
class GetNodeCountResponse;
class GetNodeInfoRequest;
class GetNodeInfoResponse;
class GetRandomNodesRequest;
class GetRandomNodesResponse;
class GpsLocation;
class LocalServiceRequest;
class LocalServiceResponse;
class Message;
class MessageWithHeader;
class NeighbourhoodChange;
class NeighbourhoodChangedNotificationRequest;
class NeighbourhoodChangedNotificationResponse;
class NodeContact;
class NodeInfo;
class RegisterServiceRequest;
class RegisterServiceResponse;
class RemoteNodeRequest;
class RemoteNodeResponse;
class Request;
class Response;
class ServiceInfo;

enum Status {
  STATUS_OK = 0,
  ERROR_PROTOCOL_VIOLATION = 1,
  ERROR_UNSUPPORTED = 2,
  ERROR_INTERNAL = 8,
  ERROR_INVALID_VALUE = 54,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Status_IsValid(int value);
const Status Status_MIN = STATUS_OK;
const Status Status_MAX = ERROR_INVALID_VALUE;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum ServiceType {
  Unstructured = 0,
  Content = 1,
  Latency = 2,
  Location = 3,
  Token = 10,
  Profile = 11,
  Proximity = 12,
  Relay = 13,
  Reputation = 14,
  Minting = 15,
  ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceType_IsValid(int value);
const ServiceType ServiceType_MIN = Unstructured;
const ServiceType ServiceType_MAX = Minting;
const int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceType_descriptor();
inline const ::std::string& ServiceType_Name(ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceType_descriptor(), value);
}
inline bool ServiceType_Parse(
    const ::std::string& name, ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
// ===================================================================

class ServiceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ServiceInfo) */ {
 public:
  ServiceInfo();
  virtual ~ServiceInfo();

  ServiceInfo(const ServiceInfo& from);

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceInfo& default_instance();

  void Swap(ServiceInfo* other);

  // implements Message ----------------------------------------------

  inline ServiceInfo* New() const { return New(NULL); }

  ServiceInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceInfo& from);
  void MergeFrom(const ServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::iop::locnet::ServiceType type() const;
  void set_type(::iop::locnet::ServiceType value);

  // optional uint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional bytes serviceData = 3;
  void clear_servicedata();
  static const int kServiceDataFieldNumber = 3;
  const ::std::string& servicedata() const;
  void set_servicedata(const ::std::string& value);
  void set_servicedata(const char* value);
  void set_servicedata(const void* value, size_t size);
  ::std::string* mutable_servicedata();
  ::std::string* release_servicedata();
  void set_allocated_servicedata(::std::string* servicedata);

  // @@protoc_insertion_point(class_scope:iop.locnet.ServiceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::internal::ArenaStringPtr servicedata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GpsLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GpsLocation) */ {
 public:
  GpsLocation();
  virtual ~GpsLocation();

  GpsLocation(const GpsLocation& from);

  inline GpsLocation& operator=(const GpsLocation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsLocation& default_instance();

  void Swap(GpsLocation* other);

  // implements Message ----------------------------------------------

  inline GpsLocation* New() const { return New(NULL); }

  GpsLocation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsLocation& from);
  void MergeFrom(const GpsLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpsLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // optional sfixed32 longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GpsLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GpsLocation* default_instance_;
};
// -------------------------------------------------------------------

class NodeContact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeContact) */ {
 public:
  NodeContact();
  virtual ~NodeContact();

  NodeContact(const NodeContact& from);

  inline NodeContact& operator=(const NodeContact& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeContact& default_instance();

  void Swap(NodeContact* other);

  // implements Message ----------------------------------------------

  inline NodeContact* New() const { return New(NULL); }

  NodeContact* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeContact& from);
  void MergeFrom(const NodeContact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeContact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ipAddress = 1;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const void* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // optional uint32 nodePort = 2;
  void clear_nodeport();
  static const int kNodePortFieldNumber = 2;
  ::google::protobuf::uint32 nodeport() const;
  void set_nodeport(::google::protobuf::uint32 value);

  // optional uint32 clientPort = 3;
  void clear_clientport();
  static const int kClientPortFieldNumber = 3;
  ::google::protobuf::uint32 clientport() const;
  void set_clientport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeContact)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::uint32 nodeport_;
  ::google::protobuf::uint32 clientport_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NodeContact* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  void Swap(NodeInfo* other);

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const { return New(NULL); }

  NodeInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes nodeId = 1;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  void set_nodeid(const char* value);
  void set_nodeid(const void* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // optional .iop.locnet.NodeContact contact = 2;
  bool has_contact() const;
  void clear_contact();
  static const int kContactFieldNumber = 2;
  const ::iop::locnet::NodeContact& contact() const;
  ::iop::locnet::NodeContact* mutable_contact();
  ::iop::locnet::NodeContact* release_contact();
  void set_allocated_contact(::iop::locnet::NodeContact* contact);

  // optional .iop.locnet.GpsLocation location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // repeated .iop.locnet.ServiceInfo services = 32;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 32;
  const ::iop::locnet::ServiceInfo& services(int index) const;
  ::iop::locnet::ServiceInfo* mutable_services(int index);
  ::iop::locnet::ServiceInfo* add_services();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
      services() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::iop::locnet::NodeContact* contact_;
  ::iop::locnet::GpsLocation* location_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo > services_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MessageWithHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.MessageWithHeader) */ {
 public:
  MessageWithHeader();
  virtual ~MessageWithHeader();

  MessageWithHeader(const MessageWithHeader& from);

  inline MessageWithHeader& operator=(const MessageWithHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWithHeader& default_instance();

  void Swap(MessageWithHeader* other);

  // implements Message ----------------------------------------------

  inline MessageWithHeader* New() const { return New(NULL); }

  MessageWithHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageWithHeader& from);
  void MergeFrom(const MessageWithHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageWithHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 header = 1;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  ::google::protobuf::uint32 header() const;
  void set_header(::google::protobuf::uint32 value);

  // optional .iop.locnet.Message body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::iop::locnet::Message& body() const;
  ::iop::locnet::Message* mutable_body();
  ::iop::locnet::Message* release_body();
  void set_allocated_body(::iop::locnet::Message* body);

  // @@protoc_insertion_point(class_scope:iop.locnet.MessageWithHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::Message* body_;
  ::google::protobuf::uint32 header_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static MessageWithHeader* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MessageTypeCase {
    kRequest = 2,
    kResponse = 3,
    MESSAGETYPE_NOT_SET = 0,
  };

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional .iop.locnet.Request request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::iop::locnet::Request& request() const;
  ::iop::locnet::Request* mutable_request();
  ::iop::locnet::Request* release_request();
  void set_allocated_request(::iop::locnet::Request* request);

  // optional .iop.locnet.Response response = 3;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 3;
  const ::iop::locnet::Response& response() const;
  ::iop::locnet::Response* mutable_response();
  ::iop::locnet::Response* release_response();
  void set_allocated_response(::iop::locnet::Response* response);

  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Message)
 private:
  inline void set_has_request();
  inline void set_has_response();

  inline bool has_MessageType() const;
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 id_;
  union MessageTypeUnion {
    MessageTypeUnion() {}
    ::iop::locnet::Request* request_;
    ::iop::locnet::Response* response_;
  } MessageType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestTypeCase {
    kLocalService = 2,
    kRemoteNode = 3,
    kClient = 4,
    REQUESTTYPE_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional .iop.locnet.LocalServiceRequest localService = 2;
  bool has_localservice() const;
  void clear_localservice();
  static const int kLocalServiceFieldNumber = 2;
  const ::iop::locnet::LocalServiceRequest& localservice() const;
  ::iop::locnet::LocalServiceRequest* mutable_localservice();
  ::iop::locnet::LocalServiceRequest* release_localservice();
  void set_allocated_localservice(::iop::locnet::LocalServiceRequest* localservice);

  // optional .iop.locnet.RemoteNodeRequest remoteNode = 3;
  bool has_remotenode() const;
  void clear_remotenode();
  static const int kRemoteNodeFieldNumber = 3;
  const ::iop::locnet::RemoteNodeRequest& remotenode() const;
  ::iop::locnet::RemoteNodeRequest* mutable_remotenode();
  ::iop::locnet::RemoteNodeRequest* release_remotenode();
  void set_allocated_remotenode(::iop::locnet::RemoteNodeRequest* remotenode);

  // optional .iop.locnet.ClientRequest client = 4;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 4;
  const ::iop::locnet::ClientRequest& client() const;
  ::iop::locnet::ClientRequest* mutable_client();
  ::iop::locnet::ClientRequest* release_client();
  void set_allocated_client(::iop::locnet::ClientRequest* client);

  RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Request)
 private:
  inline void set_has_localservice();
  inline void set_has_remotenode();
  inline void set_has_client();

  inline bool has_RequestType() const;
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::iop::locnet::LocalServiceRequest* localservice_;
    ::iop::locnet::RemoteNodeRequest* remotenode_;
    ::iop::locnet::ClientRequest* client_;
  } RequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseTypeCase {
    kLocalService = 4,
    kRemoteNode = 5,
    kClient = 6,
    RESPONSETYPE_NOT_SET = 0,
  };

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::iop::locnet::Status status() const;
  void set_status(::iop::locnet::Status value);

  // optional sint64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional string details = 3;
  void clear_details();
  static const int kDetailsFieldNumber = 3;
  const ::std::string& details() const;
  void set_details(const ::std::string& value);
  void set_details(const char* value);
  void set_details(const char* value, size_t size);
  ::std::string* mutable_details();
  ::std::string* release_details();
  void set_allocated_details(::std::string* details);

  // optional .iop.locnet.LocalServiceResponse localService = 4;
  bool has_localservice() const;
  void clear_localservice();
  static const int kLocalServiceFieldNumber = 4;
  const ::iop::locnet::LocalServiceResponse& localservice() const;
  ::iop::locnet::LocalServiceResponse* mutable_localservice();
  ::iop::locnet::LocalServiceResponse* release_localservice();
  void set_allocated_localservice(::iop::locnet::LocalServiceResponse* localservice);

  // optional .iop.locnet.RemoteNodeResponse remoteNode = 5;
  bool has_remotenode() const;
  void clear_remotenode();
  static const int kRemoteNodeFieldNumber = 5;
  const ::iop::locnet::RemoteNodeResponse& remotenode() const;
  ::iop::locnet::RemoteNodeResponse* mutable_remotenode();
  ::iop::locnet::RemoteNodeResponse* release_remotenode();
  void set_allocated_remotenode(::iop::locnet::RemoteNodeResponse* remotenode);

  // optional .iop.locnet.ClientResponse client = 6;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 6;
  const ::iop::locnet::ClientResponse& client() const;
  ::iop::locnet::ClientResponse* mutable_client();
  ::iop::locnet::ClientResponse* release_client();
  void set_allocated_client(::iop::locnet::ClientResponse* client);

  ResponseTypeCase ResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.Response)
 private:
  inline void set_has_localservice();
  inline void set_has_remotenode();
  inline void set_has_client();

  inline bool has_ResponseType() const;
  void clear_ResponseType();
  inline void clear_has_ResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::internal::ArenaStringPtr details_;
  int status_;
  union ResponseTypeUnion {
    ResponseTypeUnion() {}
    ::iop::locnet::LocalServiceResponse* localservice_;
    ::iop::locnet::RemoteNodeResponse* remotenode_;
    ::iop::locnet::ClientResponse* client_;
  } ResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class LocalServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceRequest) */ {
 public:
  LocalServiceRequest();
  virtual ~LocalServiceRequest();

  LocalServiceRequest(const LocalServiceRequest& from);

  inline LocalServiceRequest& operator=(const LocalServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceRequest& default_instance();

  enum LocalServiceRequestTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodChanged = 4,
    LOCALSERVICEREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(LocalServiceRequest* other);

  // implements Message ----------------------------------------------

  inline LocalServiceRequest* New() const { return New(NULL); }

  LocalServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalServiceRequest& from);
  void MergeFrom(const LocalServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.RegisterServiceRequest registerService = 1;
  bool has_registerservice() const;
  void clear_registerservice();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceRequest& registerservice() const;
  ::iop::locnet::RegisterServiceRequest* mutable_registerservice();
  ::iop::locnet::RegisterServiceRequest* release_registerservice();
  void set_allocated_registerservice(::iop::locnet::RegisterServiceRequest* registerservice);

  // optional .iop.locnet.DeregisterServiceRequest deregisterService = 2;
  bool has_deregisterservice() const;
  void clear_deregisterservice();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceRequest& deregisterservice() const;
  ::iop::locnet::DeregisterServiceRequest* mutable_deregisterservice();
  ::iop::locnet::DeregisterServiceRequest* release_deregisterservice();
  void set_allocated_deregisterservice(::iop::locnet::DeregisterServiceRequest* deregisterservice);

  // optional .iop.locnet.GetNeighbourNodesByDistanceLocalRequest getNeighbourNodes = 3;
  bool has_getneighbournodes() const;
  void clear_getneighbournodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& getneighbournodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* mutable_getneighbournodes();
  ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* release_getneighbournodes();
  void set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* getneighbournodes);

  // optional .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhoodChanged = 4;
  bool has_neighbourhoodchanged() const;
  void clear_neighbourhoodchanged();
  static const int kNeighbourhoodChangedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationRequest& neighbourhoodchanged() const;
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* mutable_neighbourhoodchanged();
  ::iop::locnet::NeighbourhoodChangedNotificationRequest* release_neighbourhoodchanged();
  void set_allocated_neighbourhoodchanged(::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhoodchanged);

  LocalServiceRequestTypeCase LocalServiceRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceRequest)
 private:
  inline void set_has_registerservice();
  inline void set_has_deregisterservice();
  inline void set_has_getneighbournodes();
  inline void set_has_neighbourhoodchanged();

  inline bool has_LocalServiceRequestType() const;
  void clear_LocalServiceRequestType();
  inline void clear_has_LocalServiceRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union LocalServiceRequestTypeUnion {
    LocalServiceRequestTypeUnion() {}
    ::iop::locnet::RegisterServiceRequest* registerservice_;
    ::iop::locnet::DeregisterServiceRequest* deregisterservice_;
    ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* getneighbournodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhoodchanged_;
  } LocalServiceRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static LocalServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class LocalServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.LocalServiceResponse) */ {
 public:
  LocalServiceResponse();
  virtual ~LocalServiceResponse();

  LocalServiceResponse(const LocalServiceResponse& from);

  inline LocalServiceResponse& operator=(const LocalServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalServiceResponse& default_instance();

  enum LocalServiceResponseTypeCase {
    kRegisterService = 1,
    kDeregisterService = 2,
    kGetNeighbourNodes = 3,
    kNeighbourhoodUpdated = 4,
    LOCALSERVICERESPONSETYPE_NOT_SET = 0,
  };

  void Swap(LocalServiceResponse* other);

  // implements Message ----------------------------------------------

  inline LocalServiceResponse* New() const { return New(NULL); }

  LocalServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalServiceResponse& from);
  void MergeFrom(const LocalServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.RegisterServiceResponse registerService = 1;
  bool has_registerservice() const;
  void clear_registerservice();
  static const int kRegisterServiceFieldNumber = 1;
  const ::iop::locnet::RegisterServiceResponse& registerservice() const;
  ::iop::locnet::RegisterServiceResponse* mutable_registerservice();
  ::iop::locnet::RegisterServiceResponse* release_registerservice();
  void set_allocated_registerservice(::iop::locnet::RegisterServiceResponse* registerservice);

  // optional .iop.locnet.DeregisterServiceResponse deregisterService = 2;
  bool has_deregisterservice() const;
  void clear_deregisterservice();
  static const int kDeregisterServiceFieldNumber = 2;
  const ::iop::locnet::DeregisterServiceResponse& deregisterservice() const;
  ::iop::locnet::DeregisterServiceResponse* mutable_deregisterservice();
  ::iop::locnet::DeregisterServiceResponse* release_deregisterservice();
  void set_allocated_deregisterservice(::iop::locnet::DeregisterServiceResponse* deregisterservice);

  // optional .iop.locnet.GetNeighbourNodesByDistanceResponse getNeighbourNodes = 3;
  bool has_getneighbournodes() const;
  void clear_getneighbournodes();
  static const int kGetNeighbourNodesFieldNumber = 3;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& getneighbournodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_getneighbournodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_getneighbournodes();
  void set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes);

  // optional .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhoodUpdated = 4;
  bool has_neighbourhoodupdated() const;
  void clear_neighbourhoodupdated();
  static const int kNeighbourhoodUpdatedFieldNumber = 4;
  const ::iop::locnet::NeighbourhoodChangedNotificationResponse& neighbourhoodupdated() const;
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* mutable_neighbourhoodupdated();
  ::iop::locnet::NeighbourhoodChangedNotificationResponse* release_neighbourhoodupdated();
  void set_allocated_neighbourhoodupdated(::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhoodupdated);

  LocalServiceResponseTypeCase LocalServiceResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.LocalServiceResponse)
 private:
  inline void set_has_registerservice();
  inline void set_has_deregisterservice();
  inline void set_has_getneighbournodes();
  inline void set_has_neighbourhoodupdated();

  inline bool has_LocalServiceResponseType() const;
  void clear_LocalServiceResponseType();
  inline void clear_has_LocalServiceResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union LocalServiceResponseTypeUnion {
    LocalServiceResponseTypeUnion() {}
    ::iop::locnet::RegisterServiceResponse* registerservice_;
    ::iop::locnet::DeregisterServiceResponse* deregisterservice_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes_;
    ::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhoodupdated_;
  } LocalServiceResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static LocalServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceRequest) */ {
 public:
  RegisterServiceRequest();
  virtual ~RegisterServiceRequest();

  RegisterServiceRequest(const RegisterServiceRequest& from);

  inline RegisterServiceRequest& operator=(const RegisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceRequest& default_instance();

  void Swap(RegisterServiceRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterServiceRequest* New() const { return New(NULL); }

  RegisterServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServiceRequest& from);
  void MergeFrom(const RegisterServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceInfo service = 1;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::iop::locnet::ServiceInfo& service() const;
  ::iop::locnet::ServiceInfo* mutable_service();
  ::iop::locnet::ServiceInfo* release_service();
  void set_allocated_service(::iop::locnet::ServiceInfo* service);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::ServiceInfo* service_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RegisterServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RegisterServiceResponse) */ {
 public:
  RegisterServiceResponse();
  virtual ~RegisterServiceResponse();

  RegisterServiceResponse(const RegisterServiceResponse& from);

  inline RegisterServiceResponse& operator=(const RegisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServiceResponse& default_instance();

  void Swap(RegisterServiceResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterServiceResponse* New() const { return New(NULL); }

  RegisterServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServiceResponse& from);
  void MergeFrom(const RegisterServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // @@protoc_insertion_point(class_scope:iop.locnet.RegisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RegisterServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeregisterServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceRequest) */ {
 public:
  DeregisterServiceRequest();
  virtual ~DeregisterServiceRequest();

  DeregisterServiceRequest(const DeregisterServiceRequest& from);

  inline DeregisterServiceRequest& operator=(const DeregisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceRequest& default_instance();

  void Swap(DeregisterServiceRequest* other);

  // implements Message ----------------------------------------------

  inline DeregisterServiceRequest* New() const { return New(NULL); }

  DeregisterServiceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterServiceRequest& from);
  void MergeFrom(const DeregisterServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.ServiceType serviceType = 1;
  void clear_servicetype();
  static const int kServiceTypeFieldNumber = 1;
  ::iop::locnet::ServiceType servicetype() const;
  void set_servicetype(::iop::locnet::ServiceType value);

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int servicetype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static DeregisterServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeregisterServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.DeregisterServiceResponse) */ {
 public:
  DeregisterServiceResponse();
  virtual ~DeregisterServiceResponse();

  DeregisterServiceResponse(const DeregisterServiceResponse& from);

  inline DeregisterServiceResponse& operator=(const DeregisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeregisterServiceResponse& default_instance();

  void Swap(DeregisterServiceResponse* other);

  // implements Message ----------------------------------------------

  inline DeregisterServiceResponse* New() const { return New(NULL); }

  DeregisterServiceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeregisterServiceResponse& from);
  void MergeFrom(const DeregisterServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeregisterServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.DeregisterServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static DeregisterServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceLocalRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceLocalRequest) */ {
 public:
  GetNeighbourNodesByDistanceLocalRequest();
  virtual ~GetNeighbourNodesByDistanceLocalRequest();

  GetNeighbourNodesByDistanceLocalRequest(const GetNeighbourNodesByDistanceLocalRequest& from);

  inline GetNeighbourNodesByDistanceLocalRequest& operator=(const GetNeighbourNodesByDistanceLocalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceLocalRequest& default_instance();

  void Swap(GetNeighbourNodesByDistanceLocalRequest* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceLocalRequest* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceLocalRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceLocalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceLocalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool keepAliveAndSendUpdates = 1;
  void clear_keepaliveandsendupdates();
  static const int kKeepAliveAndSendUpdatesFieldNumber = 1;
  bool keepaliveandsendupdates() const;
  void set_keepaliveandsendupdates(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceLocalRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool keepaliveandsendupdates_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceLocalRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceResponse) */ {
 public:
  GetNeighbourNodesByDistanceResponse();
  virtual ~GetNeighbourNodesByDistanceResponse();

  GetNeighbourNodesByDistanceResponse(const GetNeighbourNodesByDistanceResponse& from);

  inline GetNeighbourNodesByDistanceResponse& operator=(const GetNeighbourNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceResponse& default_instance();

  void Swap(GetNeighbourNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceResponse* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceResponse& from);
  void MergeFrom(const GetNeighbourNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChange) */ {
 public:
  NeighbourhoodChange();
  virtual ~NeighbourhoodChange();

  NeighbourhoodChange(const NeighbourhoodChange& from);

  inline NeighbourhoodChange& operator=(const NeighbourhoodChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChange& default_instance();

  enum ChangeTypeCase {
    kAddedNodeInfo = 1,
    kUpdatedNodeInfo = 2,
    kRemovedNodeId = 3,
    CHANGETYPE_NOT_SET = 0,
  };

  void Swap(NeighbourhoodChange* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChange* New() const { return New(NULL); }

  NeighbourhoodChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChange& from);
  void MergeFrom(const NeighbourhoodChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo addedNodeInfo = 1;
  bool has_addednodeinfo() const;
  void clear_addednodeinfo();
  static const int kAddedNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& addednodeinfo() const;
  ::iop::locnet::NodeInfo* mutable_addednodeinfo();
  ::iop::locnet::NodeInfo* release_addednodeinfo();
  void set_allocated_addednodeinfo(::iop::locnet::NodeInfo* addednodeinfo);

  // optional .iop.locnet.NodeInfo updatedNodeInfo = 2;
  bool has_updatednodeinfo() const;
  void clear_updatednodeinfo();
  static const int kUpdatedNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& updatednodeinfo() const;
  ::iop::locnet::NodeInfo* mutable_updatednodeinfo();
  ::iop::locnet::NodeInfo* release_updatednodeinfo();
  void set_allocated_updatednodeinfo(::iop::locnet::NodeInfo* updatednodeinfo);

  // optional bytes removedNodeId = 3;
  private:
  bool has_removednodeid() const;
  public:
  void clear_removednodeid();
  static const int kRemovedNodeIdFieldNumber = 3;
  const ::std::string& removednodeid() const;
  void set_removednodeid(const ::std::string& value);
  void set_removednodeid(const char* value);
  void set_removednodeid(const void* value, size_t size);
  ::std::string* mutable_removednodeid();
  ::std::string* release_removednodeid();
  void set_allocated_removednodeid(::std::string* removednodeid);

  ChangeTypeCase ChangeType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChange)
 private:
  inline void set_has_addednodeinfo();
  inline void set_has_updatednodeinfo();
  inline void set_has_removednodeid();

  inline bool has_ChangeType() const;
  void clear_ChangeType();
  inline void clear_has_ChangeType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ChangeTypeUnion {
    ChangeTypeUnion() {}
    ::iop::locnet::NodeInfo* addednodeinfo_;
    ::iop::locnet::NodeInfo* updatednodeinfo_;
    ::google::protobuf::internal::ArenaStringPtr removednodeid_;
  } ChangeType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChange* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationRequest) */ {
 public:
  NeighbourhoodChangedNotificationRequest();
  virtual ~NeighbourhoodChangedNotificationRequest();

  NeighbourhoodChangedNotificationRequest(const NeighbourhoodChangedNotificationRequest& from);

  inline NeighbourhoodChangedNotificationRequest& operator=(const NeighbourhoodChangedNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationRequest& default_instance();

  void Swap(NeighbourhoodChangedNotificationRequest* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationRequest* New() const { return New(NULL); }

  NeighbourhoodChangedNotificationRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChangedNotificationRequest& from);
  void MergeFrom(const NeighbourhoodChangedNotificationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChangedNotificationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NeighbourhoodChange changes = 1;
  int changes_size() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  const ::iop::locnet::NeighbourhoodChange& changes(int index) const;
  ::iop::locnet::NeighbourhoodChange* mutable_changes(int index);
  ::iop::locnet::NeighbourhoodChange* add_changes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
      mutable_changes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
      changes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange > changes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChangedNotificationRequest* default_instance_;
};
// -------------------------------------------------------------------

class NeighbourhoodChangedNotificationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.NeighbourhoodChangedNotificationResponse) */ {
 public:
  NeighbourhoodChangedNotificationResponse();
  virtual ~NeighbourhoodChangedNotificationResponse();

  NeighbourhoodChangedNotificationResponse(const NeighbourhoodChangedNotificationResponse& from);

  inline NeighbourhoodChangedNotificationResponse& operator=(const NeighbourhoodChangedNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighbourhoodChangedNotificationResponse& default_instance();

  void Swap(NeighbourhoodChangedNotificationResponse* other);

  // implements Message ----------------------------------------------

  inline NeighbourhoodChangedNotificationResponse* New() const { return New(NULL); }

  NeighbourhoodChangedNotificationResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeighbourhoodChangedNotificationResponse& from);
  void MergeFrom(const NeighbourhoodChangedNotificationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeighbourhoodChangedNotificationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.NeighbourhoodChangedNotificationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static NeighbourhoodChangedNotificationResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoteNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeRequest) */ {
 public:
  RemoteNodeRequest();
  virtual ~RemoteNodeRequest();

  RemoteNodeRequest(const RemoteNodeRequest& from);

  inline RemoteNodeRequest& operator=(const RemoteNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeRequest& default_instance();

  enum RemoteNodeRequestTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODEREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(RemoteNodeRequest* other);

  // implements Message ----------------------------------------------

  inline RemoteNodeRequest* New() const { return New(NULL); }

  RemoteNodeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteNodeRequest& from);
  void MergeFrom(const RemoteNodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.BuildNetworkRequest acceptColleague = 1;
  bool has_acceptcolleague() const;
  void clear_acceptcolleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkRequest& acceptcolleague() const;
  ::iop::locnet::BuildNetworkRequest* mutable_acceptcolleague();
  ::iop::locnet::BuildNetworkRequest* release_acceptcolleague();
  void set_allocated_acceptcolleague(::iop::locnet::BuildNetworkRequest* acceptcolleague);

  // optional .iop.locnet.BuildNetworkRequest renewColleague = 2;
  bool has_renewcolleague() const;
  void clear_renewcolleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkRequest& renewcolleague() const;
  ::iop::locnet::BuildNetworkRequest* mutable_renewcolleague();
  ::iop::locnet::BuildNetworkRequest* release_renewcolleague();
  void set_allocated_renewcolleague(::iop::locnet::BuildNetworkRequest* renewcolleague);

  // optional .iop.locnet.BuildNetworkRequest acceptNeighbour = 3;
  bool has_acceptneighbour() const;
  void clear_acceptneighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkRequest& acceptneighbour() const;
  ::iop::locnet::BuildNetworkRequest* mutable_acceptneighbour();
  ::iop::locnet::BuildNetworkRequest* release_acceptneighbour();
  void set_allocated_acceptneighbour(::iop::locnet::BuildNetworkRequest* acceptneighbour);

  // optional .iop.locnet.BuildNetworkRequest renewNeighbour = 4;
  bool has_renewneighbour() const;
  void clear_renewneighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkRequest& renewneighbour() const;
  ::iop::locnet::BuildNetworkRequest* mutable_renewneighbour();
  ::iop::locnet::BuildNetworkRequest* release_renewneighbour();
  void set_allocated_renewneighbour(::iop::locnet::BuildNetworkRequest* renewneighbour);

  // optional .iop.locnet.GetNodeCountRequest getNodeCount = 5;
  bool has_getnodecount() const;
  void clear_getnodecount();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountRequest& getnodecount() const;
  ::iop::locnet::GetNodeCountRequest* mutable_getnodecount();
  ::iop::locnet::GetNodeCountRequest* release_getnodecount();
  void set_allocated_getnodecount(::iop::locnet::GetNodeCountRequest* getnodecount);

  // optional .iop.locnet.GetRandomNodesRequest getRandomNodes = 6;
  bool has_getrandomnodes() const;
  void clear_getrandomnodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesRequest& getrandomnodes() const;
  ::iop::locnet::GetRandomNodesRequest* mutable_getrandomnodes();
  ::iop::locnet::GetRandomNodesRequest* release_getrandomnodes();
  void set_allocated_getrandomnodes(::iop::locnet::GetRandomNodesRequest* getrandomnodes);

  // optional .iop.locnet.GetClosestNodesByDistanceRequest getClosestNodes = 7;
  bool has_getclosestnodes() const;
  void clear_getclosestnodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& getclosestnodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_getclosestnodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_getclosestnodes();
  void set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes);

  // optional .iop.locnet.GetNodeInfoRequest getNodeInfo = 8;
  bool has_getnodeinfo() const;
  void clear_getnodeinfo();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoRequest& getnodeinfo() const;
  ::iop::locnet::GetNodeInfoRequest* mutable_getnodeinfo();
  ::iop::locnet::GetNodeInfoRequest* release_getnodeinfo();
  void set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoRequest* getnodeinfo);

  RemoteNodeRequestTypeCase RemoteNodeRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeRequest)
 private:
  inline void set_has_acceptcolleague();
  inline void set_has_renewcolleague();
  inline void set_has_acceptneighbour();
  inline void set_has_renewneighbour();
  inline void set_has_getnodecount();
  inline void set_has_getrandomnodes();
  inline void set_has_getclosestnodes();
  inline void set_has_getnodeinfo();

  inline bool has_RemoteNodeRequestType() const;
  void clear_RemoteNodeRequestType();
  inline void clear_has_RemoteNodeRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union RemoteNodeRequestTypeUnion {
    RemoteNodeRequestTypeUnion() {}
    ::iop::locnet::BuildNetworkRequest* acceptcolleague_;
    ::iop::locnet::BuildNetworkRequest* renewcolleague_;
    ::iop::locnet::BuildNetworkRequest* acceptneighbour_;
    ::iop::locnet::BuildNetworkRequest* renewneighbour_;
    ::iop::locnet::GetNodeCountRequest* getnodecount_;
    ::iop::locnet::GetRandomNodesRequest* getrandomnodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes_;
    ::iop::locnet::GetNodeInfoRequest* getnodeinfo_;
  } RemoteNodeRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RemoteNodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoteNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.RemoteNodeResponse) */ {
 public:
  RemoteNodeResponse();
  virtual ~RemoteNodeResponse();

  RemoteNodeResponse(const RemoteNodeResponse& from);

  inline RemoteNodeResponse& operator=(const RemoteNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteNodeResponse& default_instance();

  enum RemoteNodeResponseTypeCase {
    kAcceptColleague = 1,
    kRenewColleague = 2,
    kAcceptNeighbour = 3,
    kRenewNeighbour = 4,
    kGetNodeCount = 5,
    kGetRandomNodes = 6,
    kGetClosestNodes = 7,
    kGetNodeInfo = 8,
    REMOTENODERESPONSETYPE_NOT_SET = 0,
  };

  void Swap(RemoteNodeResponse* other);

  // implements Message ----------------------------------------------

  inline RemoteNodeResponse* New() const { return New(NULL); }

  RemoteNodeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteNodeResponse& from);
  void MergeFrom(const RemoteNodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.BuildNetworkResponse acceptColleague = 1;
  bool has_acceptcolleague() const;
  void clear_acceptcolleague();
  static const int kAcceptColleagueFieldNumber = 1;
  const ::iop::locnet::BuildNetworkResponse& acceptcolleague() const;
  ::iop::locnet::BuildNetworkResponse* mutable_acceptcolleague();
  ::iop::locnet::BuildNetworkResponse* release_acceptcolleague();
  void set_allocated_acceptcolleague(::iop::locnet::BuildNetworkResponse* acceptcolleague);

  // optional .iop.locnet.BuildNetworkResponse renewColleague = 2;
  bool has_renewcolleague() const;
  void clear_renewcolleague();
  static const int kRenewColleagueFieldNumber = 2;
  const ::iop::locnet::BuildNetworkResponse& renewcolleague() const;
  ::iop::locnet::BuildNetworkResponse* mutable_renewcolleague();
  ::iop::locnet::BuildNetworkResponse* release_renewcolleague();
  void set_allocated_renewcolleague(::iop::locnet::BuildNetworkResponse* renewcolleague);

  // optional .iop.locnet.BuildNetworkResponse acceptNeighbour = 3;
  bool has_acceptneighbour() const;
  void clear_acceptneighbour();
  static const int kAcceptNeighbourFieldNumber = 3;
  const ::iop::locnet::BuildNetworkResponse& acceptneighbour() const;
  ::iop::locnet::BuildNetworkResponse* mutable_acceptneighbour();
  ::iop::locnet::BuildNetworkResponse* release_acceptneighbour();
  void set_allocated_acceptneighbour(::iop::locnet::BuildNetworkResponse* acceptneighbour);

  // optional .iop.locnet.BuildNetworkResponse renewNeighbour = 4;
  bool has_renewneighbour() const;
  void clear_renewneighbour();
  static const int kRenewNeighbourFieldNumber = 4;
  const ::iop::locnet::BuildNetworkResponse& renewneighbour() const;
  ::iop::locnet::BuildNetworkResponse* mutable_renewneighbour();
  ::iop::locnet::BuildNetworkResponse* release_renewneighbour();
  void set_allocated_renewneighbour(::iop::locnet::BuildNetworkResponse* renewneighbour);

  // optional .iop.locnet.GetNodeCountResponse getNodeCount = 5;
  bool has_getnodecount() const;
  void clear_getnodecount();
  static const int kGetNodeCountFieldNumber = 5;
  const ::iop::locnet::GetNodeCountResponse& getnodecount() const;
  ::iop::locnet::GetNodeCountResponse* mutable_getnodecount();
  ::iop::locnet::GetNodeCountResponse* release_getnodecount();
  void set_allocated_getnodecount(::iop::locnet::GetNodeCountResponse* getnodecount);

  // optional .iop.locnet.GetRandomNodesResponse getRandomNodes = 6;
  bool has_getrandomnodes() const;
  void clear_getrandomnodes();
  static const int kGetRandomNodesFieldNumber = 6;
  const ::iop::locnet::GetRandomNodesResponse& getrandomnodes() const;
  ::iop::locnet::GetRandomNodesResponse* mutable_getrandomnodes();
  ::iop::locnet::GetRandomNodesResponse* release_getrandomnodes();
  void set_allocated_getrandomnodes(::iop::locnet::GetRandomNodesResponse* getrandomnodes);

  // optional .iop.locnet.GetClosestNodesByDistanceResponse getClosestNodes = 7;
  bool has_getclosestnodes() const;
  void clear_getclosestnodes();
  static const int kGetClosestNodesFieldNumber = 7;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& getclosestnodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_getclosestnodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_getclosestnodes();
  void set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes);

  // optional .iop.locnet.GetNodeInfoResponse getNodeInfo = 8;
  bool has_getnodeinfo() const;
  void clear_getnodeinfo();
  static const int kGetNodeInfoFieldNumber = 8;
  const ::iop::locnet::GetNodeInfoResponse& getnodeinfo() const;
  ::iop::locnet::GetNodeInfoResponse* mutable_getnodeinfo();
  ::iop::locnet::GetNodeInfoResponse* release_getnodeinfo();
  void set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoResponse* getnodeinfo);

  RemoteNodeResponseTypeCase RemoteNodeResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.RemoteNodeResponse)
 private:
  inline void set_has_acceptcolleague();
  inline void set_has_renewcolleague();
  inline void set_has_acceptneighbour();
  inline void set_has_renewneighbour();
  inline void set_has_getnodecount();
  inline void set_has_getrandomnodes();
  inline void set_has_getclosestnodes();
  inline void set_has_getnodeinfo();

  inline bool has_RemoteNodeResponseType() const;
  void clear_RemoteNodeResponseType();
  inline void clear_has_RemoteNodeResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union RemoteNodeResponseTypeUnion {
    RemoteNodeResponseTypeUnion() {}
    ::iop::locnet::BuildNetworkResponse* acceptcolleague_;
    ::iop::locnet::BuildNetworkResponse* renewcolleague_;
    ::iop::locnet::BuildNetworkResponse* acceptneighbour_;
    ::iop::locnet::BuildNetworkResponse* renewneighbour_;
    ::iop::locnet::GetNodeCountResponse* getnodecount_;
    ::iop::locnet::GetRandomNodesResponse* getrandomnodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes_;
    ::iop::locnet::GetNodeInfoResponse* getnodeinfo_;
  } RemoteNodeResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static RemoteNodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class BuildNetworkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkRequest) */ {
 public:
  BuildNetworkRequest();
  virtual ~BuildNetworkRequest();

  BuildNetworkRequest(const BuildNetworkRequest& from);

  inline BuildNetworkRequest& operator=(const BuildNetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkRequest& default_instance();

  void Swap(BuildNetworkRequest* other);

  // implements Message ----------------------------------------------

  inline BuildNetworkRequest* New() const { return New(NULL); }

  BuildNetworkRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildNetworkRequest& from);
  void MergeFrom(const BuildNetworkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildNetworkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo requestorNodeInfo = 1;
  bool has_requestornodeinfo() const;
  void clear_requestornodeinfo();
  static const int kRequestorNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& requestornodeinfo() const;
  ::iop::locnet::NodeInfo* mutable_requestornodeinfo();
  ::iop::locnet::NodeInfo* release_requestornodeinfo();
  void set_allocated_requestornodeinfo(::iop::locnet::NodeInfo* requestornodeinfo);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* requestornodeinfo_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static BuildNetworkRequest* default_instance_;
};
// -------------------------------------------------------------------

class BuildNetworkResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.BuildNetworkResponse) */ {
 public:
  BuildNetworkResponse();
  virtual ~BuildNetworkResponse();

  BuildNetworkResponse(const BuildNetworkResponse& from);

  inline BuildNetworkResponse& operator=(const BuildNetworkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildNetworkResponse& default_instance();

  void Swap(BuildNetworkResponse* other);

  // implements Message ----------------------------------------------

  inline BuildNetworkResponse* New() const { return New(NULL); }

  BuildNetworkResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildNetworkResponse& from);
  void MergeFrom(const BuildNetworkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildNetworkResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool accepted = 1;
  void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  bool accepted() const;
  void set_accepted(bool value);

  // optional .iop.locnet.NodeInfo acceptorNodeInfo = 2;
  bool has_acceptornodeinfo() const;
  void clear_acceptornodeinfo();
  static const int kAcceptorNodeInfoFieldNumber = 2;
  const ::iop::locnet::NodeInfo& acceptornodeinfo() const;
  ::iop::locnet::NodeInfo* mutable_acceptornodeinfo();
  ::iop::locnet::NodeInfo* release_acceptornodeinfo();
  void set_allocated_acceptornodeinfo(::iop::locnet::NodeInfo* acceptornodeinfo);

  // optional bytes remoteIpAddress = 3;
  void clear_remoteipaddress();
  static const int kRemoteIpAddressFieldNumber = 3;
  const ::std::string& remoteipaddress() const;
  void set_remoteipaddress(const ::std::string& value);
  void set_remoteipaddress(const char* value);
  void set_remoteipaddress(const void* value, size_t size);
  ::std::string* mutable_remoteipaddress();
  ::std::string* release_remoteipaddress();
  void set_allocated_remoteipaddress(::std::string* remoteipaddress);

  // @@protoc_insertion_point(class_scope:iop.locnet.BuildNetworkResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* acceptornodeinfo_;
  ::google::protobuf::internal::ArenaStringPtr remoteipaddress_;
  bool accepted_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static BuildNetworkResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeCountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountRequest) */ {
 public:
  GetNodeCountRequest();
  virtual ~GetNodeCountRequest();

  GetNodeCountRequest(const GetNodeCountRequest& from);

  inline GetNodeCountRequest& operator=(const GetNodeCountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountRequest& default_instance();

  void Swap(GetNodeCountRequest* other);

  // implements Message ----------------------------------------------

  inline GetNodeCountRequest* New() const { return New(NULL); }

  GetNodeCountRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeCountRequest& from);
  void MergeFrom(const GetNodeCountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeCountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeCountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeCountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeCountResponse) */ {
 public:
  GetNodeCountResponse();
  virtual ~GetNodeCountResponse();

  GetNodeCountResponse(const GetNodeCountResponse& from);

  inline GetNodeCountResponse& operator=(const GetNodeCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeCountResponse& default_instance();

  void Swap(GetNodeCountResponse* other);

  // implements Message ----------------------------------------------

  inline GetNodeCountResponse* New() const { return New(NULL); }

  GetNodeCountResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeCountResponse& from);
  void MergeFrom(const GetNodeCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeCountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nodeCount = 1;
  void clear_nodecount();
  static const int kNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 nodecount() const;
  void set_nodecount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeCountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 nodecount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesRequest) */ {
 public:
  GetRandomNodesRequest();
  virtual ~GetRandomNodesRequest();

  GetRandomNodesRequest(const GetRandomNodesRequest& from);

  inline GetRandomNodesRequest& operator=(const GetRandomNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesRequest& default_instance();

  void Swap(GetRandomNodesRequest* other);

  // implements Message ----------------------------------------------

  inline GetRandomNodesRequest* New() const { return New(NULL); }

  GetRandomNodesRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRandomNodesRequest& from);
  void MergeFrom(const GetRandomNodesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRandomNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 maxNodeCount = 1;
  void clear_maxnodecount();
  static const int kMaxNodeCountFieldNumber = 1;
  ::google::protobuf::uint32 maxnodecount() const;
  void set_maxnodecount(::google::protobuf::uint32 value);

  // optional bool includeNeighbours = 2;
  void clear_includeneighbours();
  static const int kIncludeNeighboursFieldNumber = 2;
  bool includeneighbours() const;
  void set_includeneighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 maxnodecount_;
  bool includeneighbours_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetRandomNodesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetRandomNodesResponse) */ {
 public:
  GetRandomNodesResponse();
  virtual ~GetRandomNodesResponse();

  GetRandomNodesResponse(const GetRandomNodesResponse& from);

  inline GetRandomNodesResponse& operator=(const GetRandomNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRandomNodesResponse& default_instance();

  void Swap(GetRandomNodesResponse* other);

  // implements Message ----------------------------------------------

  inline GetRandomNodesResponse* New() const { return New(NULL); }

  GetRandomNodesResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRandomNodesResponse& from);
  void MergeFrom(const GetRandomNodesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRandomNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetRandomNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetRandomNodesResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceRequest) */ {
 public:
  GetClosestNodesByDistanceRequest();
  virtual ~GetClosestNodesByDistanceRequest();

  GetClosestNodesByDistanceRequest(const GetClosestNodesByDistanceRequest& from);

  inline GetClosestNodesByDistanceRequest& operator=(const GetClosestNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceRequest& default_instance();

  void Swap(GetClosestNodesByDistanceRequest* other);

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceRequest* New() const { return New(NULL); }

  GetClosestNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClosestNodesByDistanceRequest& from);
  void MergeFrom(const GetClosestNodesByDistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetClosestNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // optional float maxRadiusKm = 2;
  void clear_maxradiuskm();
  static const int kMaxRadiusKmFieldNumber = 2;
  float maxradiuskm() const;
  void set_maxradiuskm(float value);

  // optional uint32 maxNodeCount = 3;
  void clear_maxnodecount();
  static const int kMaxNodeCountFieldNumber = 3;
  ::google::protobuf::uint32 maxnodecount() const;
  void set_maxnodecount(::google::protobuf::uint32 value);

  // optional bool includeNeighbours = 4;
  void clear_includeneighbours();
  static const int kIncludeNeighboursFieldNumber = 4;
  bool includeneighbours() const;
  void set_includeneighbours(bool value);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  float maxradiuskm_;
  ::google::protobuf::uint32 maxnodecount_;
  bool includeneighbours_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetClosestNodesByDistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetClosestNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetClosestNodesByDistanceResponse) */ {
 public:
  GetClosestNodesByDistanceResponse();
  virtual ~GetClosestNodesByDistanceResponse();

  GetClosestNodesByDistanceResponse(const GetClosestNodesByDistanceResponse& from);

  inline GetClosestNodesByDistanceResponse& operator=(const GetClosestNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClosestNodesByDistanceResponse& default_instance();

  void Swap(GetClosestNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline GetClosestNodesByDistanceResponse* New() const { return New(NULL); }

  GetClosestNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClosestNodesByDistanceResponse& from);
  void MergeFrom(const GetClosestNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetClosestNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_nodes(int index);
  ::iop::locnet::NodeInfo* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.GetClosestNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetClosestNodesByDistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientRequest) */ {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();

  enum ClientRequestTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    CLIENTREQUESTTYPE_NOT_SET = 0,
  };

  void Swap(ClientRequest* other);

  // implements Message ----------------------------------------------

  inline ClientRequest* New() const { return New(NULL); }

  ClientRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GetNodeInfoRequest getNodeInfo = 1;
  bool has_getnodeinfo() const;
  void clear_getnodeinfo();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoRequest& getnodeinfo() const;
  ::iop::locnet::GetNodeInfoRequest* mutable_getnodeinfo();
  ::iop::locnet::GetNodeInfoRequest* release_getnodeinfo();
  void set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoRequest* getnodeinfo);

  // optional .iop.locnet.GetNeighbourNodesByDistanceClientRequest getNeighbourNodes = 2;
  bool has_getneighbournodes() const;
  void clear_getneighbournodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& getneighbournodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* mutable_getneighbournodes();
  ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* release_getneighbournodes();
  void set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceClientRequest* getneighbournodes);

  // optional .iop.locnet.GetClosestNodesByDistanceRequest getClosestNodes = 3;
  bool has_getclosestnodes() const;
  void clear_getclosestnodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceRequest& getclosestnodes() const;
  ::iop::locnet::GetClosestNodesByDistanceRequest* mutable_getclosestnodes();
  ::iop::locnet::GetClosestNodesByDistanceRequest* release_getclosestnodes();
  void set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes);

  // optional .iop.locnet.ExploreNetworkNodesByDistanceRequest exploreNodes = 4;
  bool has_explorenodes() const;
  void clear_explorenodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& explorenodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* mutable_explorenodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceRequest* release_explorenodes();
  void set_allocated_explorenodes(::iop::locnet::ExploreNetworkNodesByDistanceRequest* explorenodes);

  ClientRequestTypeCase ClientRequestType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientRequest)
 private:
  inline void set_has_getnodeinfo();
  inline void set_has_getneighbournodes();
  inline void set_has_getclosestnodes();
  inline void set_has_explorenodes();

  inline bool has_ClientRequestType() const;
  void clear_ClientRequestType();
  inline void clear_has_ClientRequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ClientRequestTypeUnion {
    ClientRequestTypeUnion() {}
    ::iop::locnet::GetNodeInfoRequest* getnodeinfo_;
    ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* getneighbournodes_;
    ::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceRequest* explorenodes_;
  } ClientRequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ClientResponse) */ {
 public:
  ClientResponse();
  virtual ~ClientResponse();

  ClientResponse(const ClientResponse& from);

  inline ClientResponse& operator=(const ClientResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientResponse& default_instance();

  enum ClientResponseTypeCase {
    kGetNodeInfo = 1,
    kGetNeighbourNodes = 2,
    kGetClosestNodes = 3,
    kExploreNodes = 4,
    CLIENTRESPONSETYPE_NOT_SET = 0,
  };

  void Swap(ClientResponse* other);

  // implements Message ----------------------------------------------

  inline ClientResponse* New() const { return New(NULL); }

  ClientResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientResponse& from);
  void MergeFrom(const ClientResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GetNodeInfoResponse getNodeInfo = 1;
  bool has_getnodeinfo() const;
  void clear_getnodeinfo();
  static const int kGetNodeInfoFieldNumber = 1;
  const ::iop::locnet::GetNodeInfoResponse& getnodeinfo() const;
  ::iop::locnet::GetNodeInfoResponse* mutable_getnodeinfo();
  ::iop::locnet::GetNodeInfoResponse* release_getnodeinfo();
  void set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoResponse* getnodeinfo);

  // optional .iop.locnet.GetNeighbourNodesByDistanceResponse getNeighbourNodes = 2;
  bool has_getneighbournodes() const;
  void clear_getneighbournodes();
  static const int kGetNeighbourNodesFieldNumber = 2;
  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& getneighbournodes() const;
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* mutable_getneighbournodes();
  ::iop::locnet::GetNeighbourNodesByDistanceResponse* release_getneighbournodes();
  void set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes);

  // optional .iop.locnet.GetClosestNodesByDistanceResponse getClosestNodes = 3;
  bool has_getclosestnodes() const;
  void clear_getclosestnodes();
  static const int kGetClosestNodesFieldNumber = 3;
  const ::iop::locnet::GetClosestNodesByDistanceResponse& getclosestnodes() const;
  ::iop::locnet::GetClosestNodesByDistanceResponse* mutable_getclosestnodes();
  ::iop::locnet::GetClosestNodesByDistanceResponse* release_getclosestnodes();
  void set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes);

  // optional .iop.locnet.ExploreNetworkNodesByDistanceResponse exploreNodes = 4;
  bool has_explorenodes() const;
  void clear_explorenodes();
  static const int kExploreNodesFieldNumber = 4;
  const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& explorenodes() const;
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* mutable_explorenodes();
  ::iop::locnet::ExploreNetworkNodesByDistanceResponse* release_explorenodes();
  void set_allocated_explorenodes(::iop::locnet::ExploreNetworkNodesByDistanceResponse* explorenodes);

  ClientResponseTypeCase ClientResponseType_case() const;
  // @@protoc_insertion_point(class_scope:iop.locnet.ClientResponse)
 private:
  inline void set_has_getnodeinfo();
  inline void set_has_getneighbournodes();
  inline void set_has_getclosestnodes();
  inline void set_has_explorenodes();

  inline bool has_ClientResponseType() const;
  void clear_ClientResponseType();
  inline void clear_has_ClientResponseType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ClientResponseTypeUnion {
    ClientResponseTypeUnion() {}
    ::iop::locnet::GetNodeInfoResponse* getnodeinfo_;
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes_;
    ::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes_;
    ::iop::locnet::ExploreNetworkNodesByDistanceResponse* explorenodes_;
  } ClientResponseType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ClientResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoRequest) */ {
 public:
  GetNodeInfoRequest();
  virtual ~GetNodeInfoRequest();

  GetNodeInfoRequest(const GetNodeInfoRequest& from);

  inline GetNodeInfoRequest& operator=(const GetNodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoRequest& default_instance();

  void Swap(GetNodeInfoRequest* other);

  // implements Message ----------------------------------------------

  inline GetNodeInfoRequest* New() const { return New(NULL); }

  GetNodeInfoRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeInfoRequest& from);
  void MergeFrom(const GetNodeInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNodeInfoResponse) */ {
 public:
  GetNodeInfoResponse();
  virtual ~GetNodeInfoResponse();

  GetNodeInfoResponse(const GetNodeInfoResponse& from);

  inline GetNodeInfoResponse& operator=(const GetNodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoResponse& default_instance();

  void Swap(GetNodeInfoResponse* other);

  // implements Message ----------------------------------------------

  inline GetNodeInfoResponse* New() const { return New(NULL); }

  GetNodeInfoResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeInfoResponse& from);
  void MergeFrom(const GetNodeInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNodeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.NodeInfo nodeInfo = 1;
  bool has_nodeinfo() const;
  void clear_nodeinfo();
  static const int kNodeInfoFieldNumber = 1;
  const ::iop::locnet::NodeInfo& nodeinfo() const;
  ::iop::locnet::NodeInfo* mutable_nodeinfo();
  ::iop::locnet::NodeInfo* release_nodeinfo();
  void set_allocated_nodeinfo(::iop::locnet::NodeInfo* nodeinfo);

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNodeInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::NodeInfo* nodeinfo_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNodeInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNeighbourNodesByDistanceClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.GetNeighbourNodesByDistanceClientRequest) */ {
 public:
  GetNeighbourNodesByDistanceClientRequest();
  virtual ~GetNeighbourNodesByDistanceClientRequest();

  GetNeighbourNodesByDistanceClientRequest(const GetNeighbourNodesByDistanceClientRequest& from);

  inline GetNeighbourNodesByDistanceClientRequest& operator=(const GetNeighbourNodesByDistanceClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNeighbourNodesByDistanceClientRequest& default_instance();

  void Swap(GetNeighbourNodesByDistanceClientRequest* other);

  // implements Message ----------------------------------------------

  inline GetNeighbourNodesByDistanceClientRequest* New() const { return New(NULL); }

  GetNeighbourNodesByDistanceClientRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void MergeFrom(const GetNeighbourNodesByDistanceClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetNeighbourNodesByDistanceClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iop.locnet.GetNeighbourNodesByDistanceClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static GetNeighbourNodesByDistanceClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceRequest) */ {
 public:
  ExploreNetworkNodesByDistanceRequest();
  virtual ~ExploreNetworkNodesByDistanceRequest();

  ExploreNetworkNodesByDistanceRequest(const ExploreNetworkNodesByDistanceRequest& from);

  inline ExploreNetworkNodesByDistanceRequest& operator=(const ExploreNetworkNodesByDistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceRequest& default_instance();

  void Swap(ExploreNetworkNodesByDistanceRequest* other);

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceRequest* New() const { return New(NULL); }

  ExploreNetworkNodesByDistanceRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExploreNetworkNodesByDistanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .iop.locnet.GpsLocation location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::iop::locnet::GpsLocation& location() const;
  ::iop::locnet::GpsLocation* mutable_location();
  ::iop::locnet::GpsLocation* release_location();
  void set_allocated_location(::iop::locnet::GpsLocation* location);

  // optional uint32 targetNodeCount = 2;
  void clear_targetnodecount();
  static const int kTargetNodeCountFieldNumber = 2;
  ::google::protobuf::uint32 targetnodecount() const;
  void set_targetnodecount(::google::protobuf::uint32 value);

  // optional uint32 maxNodeHops = 3;
  void clear_maxnodehops();
  static const int kMaxNodeHopsFieldNumber = 3;
  ::google::protobuf::uint32 maxnodehops() const;
  void set_maxnodehops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::iop::locnet::GpsLocation* location_;
  ::google::protobuf::uint32 targetnodecount_;
  ::google::protobuf::uint32 maxnodehops_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ExploreNetworkNodesByDistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExploreNetworkNodesByDistanceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iop.locnet.ExploreNetworkNodesByDistanceResponse) */ {
 public:
  ExploreNetworkNodesByDistanceResponse();
  virtual ~ExploreNetworkNodesByDistanceResponse();

  ExploreNetworkNodesByDistanceResponse(const ExploreNetworkNodesByDistanceResponse& from);

  inline ExploreNetworkNodesByDistanceResponse& operator=(const ExploreNetworkNodesByDistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreNetworkNodesByDistanceResponse& default_instance();

  void Swap(ExploreNetworkNodesByDistanceResponse* other);

  // implements Message ----------------------------------------------

  inline ExploreNetworkNodesByDistanceResponse* New() const { return New(NULL); }

  ExploreNetworkNodesByDistanceResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void MergeFrom(const ExploreNetworkNodesByDistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExploreNetworkNodesByDistanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iop.locnet.NodeInfo closestNodes = 1;
  int closestnodes_size() const;
  void clear_closestnodes();
  static const int kClosestNodesFieldNumber = 1;
  const ::iop::locnet::NodeInfo& closestnodes(int index) const;
  ::iop::locnet::NodeInfo* mutable_closestnodes(int index);
  ::iop::locnet::NodeInfo* add_closestnodes();
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
      mutable_closestnodes();
  const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
      closestnodes() const;

  // @@protoc_insertion_point(class_scope:iop.locnet.ExploreNetworkNodesByDistanceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo > closestnodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_IopLocNet_2eproto();
  friend void protobuf_AssignDesc_IopLocNet_2eproto();
  friend void protobuf_ShutdownFile_IopLocNet_2eproto();

  void InitAsDefaultInstance();
  static ExploreNetworkNodesByDistanceResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ServiceInfo

// optional .iop.locnet.ServiceType type = 1;
inline void ServiceInfo::clear_type() {
  type_ = 0;
}
inline ::iop::locnet::ServiceType ServiceInfo::type() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.type)
  return static_cast< ::iop::locnet::ServiceType >(type_);
}
inline void ServiceInfo::set_type(::iop::locnet::ServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.type)
}

// optional uint32 port = 2;
inline void ServiceInfo::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 ServiceInfo::port() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.port)
  return port_;
}
inline void ServiceInfo::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.port)
}

// optional bytes serviceData = 3;
inline void ServiceInfo::clear_servicedata() {
  servicedata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServiceInfo::servicedata() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ServiceInfo.serviceData)
  return servicedata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_servicedata(const ::std::string& value) {
  
  servicedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.ServiceInfo.serviceData)
}
inline void ServiceInfo::set_servicedata(const char* value) {
  
  servicedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.ServiceInfo.serviceData)
}
inline void ServiceInfo::set_servicedata(const void* value, size_t size) {
  
  servicedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.ServiceInfo.serviceData)
}
inline ::std::string* ServiceInfo::mutable_servicedata() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.ServiceInfo.serviceData)
  return servicedata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceInfo::release_servicedata() {
  // @@protoc_insertion_point(field_release:iop.locnet.ServiceInfo.serviceData)
  
  return servicedata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceInfo::set_allocated_servicedata(::std::string* servicedata) {
  if (servicedata != NULL) {
    
  } else {
    
  }
  servicedata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servicedata);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ServiceInfo.serviceData)
}

// -------------------------------------------------------------------

// GpsLocation

// optional sfixed32 latitude = 1;
inline void GpsLocation::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::latitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.latitude)
  return latitude_;
}
inline void GpsLocation::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.latitude)
}

// optional sfixed32 longitude = 2;
inline void GpsLocation::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 GpsLocation::longitude() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GpsLocation.longitude)
  return longitude_;
}
inline void GpsLocation::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GpsLocation.longitude)
}

// -------------------------------------------------------------------

// NodeContact

// optional bytes ipAddress = 1;
inline void NodeContact::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeContact::ipaddress() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.ipAddress)
  return ipaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeContact::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.ipAddress)
}
inline void NodeContact::set_ipaddress(const char* value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeContact.ipAddress)
}
inline void NodeContact::set_ipaddress(const void* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeContact.ipAddress)
}
inline ::std::string* NodeContact::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeContact.ipAddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeContact::release_ipaddress() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeContact.ipAddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeContact::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeContact.ipAddress)
}

// optional uint32 nodePort = 2;
inline void NodeContact::clear_nodeport() {
  nodeport_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::nodeport() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.nodePort)
  return nodeport_;
}
inline void NodeContact::set_nodeport(::google::protobuf::uint32 value) {
  
  nodeport_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.nodePort)
}

// optional uint32 clientPort = 3;
inline void NodeContact::clear_clientport() {
  clientport_ = 0u;
}
inline ::google::protobuf::uint32 NodeContact::clientport() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeContact.clientPort)
  return clientport_;
}
inline void NodeContact::set_clientport(::google::protobuf::uint32 value) {
  
  clientport_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.NodeContact.clientPort)
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes nodeId = 1;
inline void NodeInfo::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::nodeid() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.nodeId)
  return nodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NodeInfo.nodeId)
}
inline void NodeInfo::set_nodeid(const char* value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NodeInfo.nodeId)
}
inline void NodeInfo::set_nodeid(const void* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NodeInfo.nodeId)
}
inline ::std::string* NodeInfo::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_nodeid() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.nodeId)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.nodeId)
}

// optional .iop.locnet.NodeContact contact = 2;
inline bool NodeInfo::has_contact() const {
  return !_is_default_instance_ && contact_ != NULL;
}
inline void NodeInfo::clear_contact() {
  if (GetArenaNoVirtual() == NULL && contact_ != NULL) delete contact_;
  contact_ = NULL;
}
inline const ::iop::locnet::NodeContact& NodeInfo::contact() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.contact)
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
}
inline ::iop::locnet::NodeContact* NodeInfo::mutable_contact() {
  
  if (contact_ == NULL) {
    contact_ = new ::iop::locnet::NodeContact;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.contact)
  return contact_;
}
inline ::iop::locnet::NodeContact* NodeInfo::release_contact() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.contact)
  
  ::iop::locnet::NodeContact* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_contact(::iop::locnet::NodeContact* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.contact)
}

// optional .iop.locnet.GpsLocation location = 3;
inline bool NodeInfo::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void NodeInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& NodeInfo::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* NodeInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* NodeInfo::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.NodeInfo.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void NodeInfo::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NodeInfo.location)
}

// repeated .iop.locnet.ServiceInfo services = 32;
inline int NodeInfo::services_size() const {
  return services_.size();
}
inline void NodeInfo::clear_services() {
  services_.Clear();
}
inline const ::iop::locnet::ServiceInfo& NodeInfo::services(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NodeInfo.services)
  return services_.Get(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NodeInfo.services)
  return services_.Mutable(index);
}
inline ::iop::locnet::ServiceInfo* NodeInfo::add_services() {
  // @@protoc_insertion_point(field_add:iop.locnet.NodeInfo.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >*
NodeInfo::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NodeInfo.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::ServiceInfo >&
NodeInfo::services() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NodeInfo.services)
  return services_;
}

// -------------------------------------------------------------------

// MessageWithHeader

// optional fixed32 header = 1;
inline void MessageWithHeader::clear_header() {
  header_ = 0u;
}
inline ::google::protobuf::uint32 MessageWithHeader::header() const {
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.header)
  return header_;
}
inline void MessageWithHeader::set_header(::google::protobuf::uint32 value) {
  
  header_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.MessageWithHeader.header)
}

// optional .iop.locnet.Message body = 2;
inline bool MessageWithHeader::has_body() const {
  return !_is_default_instance_ && body_ != NULL;
}
inline void MessageWithHeader::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) delete body_;
  body_ = NULL;
}
inline const ::iop::locnet::Message& MessageWithHeader::body() const {
  // @@protoc_insertion_point(field_get:iop.locnet.MessageWithHeader.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::iop::locnet::Message* MessageWithHeader::mutable_body() {
  
  if (body_ == NULL) {
    body_ = new ::iop::locnet::Message;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.MessageWithHeader.body)
  return body_;
}
inline ::iop::locnet::Message* MessageWithHeader::release_body() {
  // @@protoc_insertion_point(field_release:iop.locnet.MessageWithHeader.body)
  
  ::iop::locnet::Message* temp = body_;
  body_ = NULL;
  return temp;
}
inline void MessageWithHeader::set_allocated_body(::iop::locnet::Message* body) {
  delete body_;
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.MessageWithHeader.body)
}

// -------------------------------------------------------------------

// Message

// optional uint32 id = 1;
inline void Message::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Message::id() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.id)
  return id_;
}
inline void Message::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Message.id)
}

// optional .iop.locnet.Request request = 2;
inline bool Message::has_request() const {
  return MessageType_case() == kRequest;
}
inline void Message::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void Message::clear_request() {
  if (has_request()) {
    delete MessageType_.request_;
    clear_has_MessageType();
  }
}
inline  const ::iop::locnet::Request& Message::request() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.request)
  return has_request()
      ? *MessageType_.request_
      : ::iop::locnet::Request::default_instance();
}
inline ::iop::locnet::Request* Message::mutable_request() {
  if (!has_request()) {
    clear_MessageType();
    set_has_request();
    MessageType_.request_ = new ::iop::locnet::Request;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.request)
  return MessageType_.request_;
}
inline ::iop::locnet::Request* Message::release_request() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.request)
  if (has_request()) {
    clear_has_MessageType();
    ::iop::locnet::Request* temp = MessageType_.request_;
    MessageType_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_request(::iop::locnet::Request* request) {
  clear_MessageType();
  if (request) {
    set_has_request();
    MessageType_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Message.request)
}

// optional .iop.locnet.Response response = 3;
inline bool Message::has_response() const {
  return MessageType_case() == kResponse;
}
inline void Message::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void Message::clear_response() {
  if (has_response()) {
    delete MessageType_.response_;
    clear_has_MessageType();
  }
}
inline  const ::iop::locnet::Response& Message::response() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Message.response)
  return has_response()
      ? *MessageType_.response_
      : ::iop::locnet::Response::default_instance();
}
inline ::iop::locnet::Response* Message::mutable_response() {
  if (!has_response()) {
    clear_MessageType();
    set_has_response();
    MessageType_.response_ = new ::iop::locnet::Response;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Message.response)
  return MessageType_.response_;
}
inline ::iop::locnet::Response* Message::release_response() {
  // @@protoc_insertion_point(field_release:iop.locnet.Message.response)
  if (has_response()) {
    clear_has_MessageType();
    ::iop::locnet::Response* temp = MessageType_.response_;
    MessageType_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_response(::iop::locnet::Response* response) {
  clear_MessageType();
  if (response) {
    set_has_response();
    MessageType_.response_ = response;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Message.response)
}

inline bool Message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void Message::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline Message::MessageTypeCase Message::MessageType_case() const {
  return Message::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// optional bytes version = 1;
inline void Request::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request::version() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Request.version)
}
inline void Request::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Request.version)
}
inline void Request::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Request.version)
}
inline ::std::string* Request::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_version() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.version)
}

// optional .iop.locnet.LocalServiceRequest localService = 2;
inline bool Request::has_localservice() const {
  return RequestType_case() == kLocalService;
}
inline void Request::set_has_localservice() {
  _oneof_case_[0] = kLocalService;
}
inline void Request::clear_localservice() {
  if (has_localservice()) {
    delete RequestType_.localservice_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::LocalServiceRequest& Request::localservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.localService)
  return has_localservice()
      ? *RequestType_.localservice_
      : ::iop::locnet::LocalServiceRequest::default_instance();
}
inline ::iop::locnet::LocalServiceRequest* Request::mutable_localservice() {
  if (!has_localservice()) {
    clear_RequestType();
    set_has_localservice();
    RequestType_.localservice_ = new ::iop::locnet::LocalServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.localService)
  return RequestType_.localservice_;
}
inline ::iop::locnet::LocalServiceRequest* Request::release_localservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.localService)
  if (has_localservice()) {
    clear_has_RequestType();
    ::iop::locnet::LocalServiceRequest* temp = RequestType_.localservice_;
    RequestType_.localservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_localservice(::iop::locnet::LocalServiceRequest* localservice) {
  clear_RequestType();
  if (localservice) {
    set_has_localservice();
    RequestType_.localservice_ = localservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.localService)
}

// optional .iop.locnet.RemoteNodeRequest remoteNode = 3;
inline bool Request::has_remotenode() const {
  return RequestType_case() == kRemoteNode;
}
inline void Request::set_has_remotenode() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Request::clear_remotenode() {
  if (has_remotenode()) {
    delete RequestType_.remotenode_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::RemoteNodeRequest& Request::remotenode() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.remoteNode)
  return has_remotenode()
      ? *RequestType_.remotenode_
      : ::iop::locnet::RemoteNodeRequest::default_instance();
}
inline ::iop::locnet::RemoteNodeRequest* Request::mutable_remotenode() {
  if (!has_remotenode()) {
    clear_RequestType();
    set_has_remotenode();
    RequestType_.remotenode_ = new ::iop::locnet::RemoteNodeRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.remoteNode)
  return RequestType_.remotenode_;
}
inline ::iop::locnet::RemoteNodeRequest* Request::release_remotenode() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.remoteNode)
  if (has_remotenode()) {
    clear_has_RequestType();
    ::iop::locnet::RemoteNodeRequest* temp = RequestType_.remotenode_;
    RequestType_.remotenode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_remotenode(::iop::locnet::RemoteNodeRequest* remotenode) {
  clear_RequestType();
  if (remotenode) {
    set_has_remotenode();
    RequestType_.remotenode_ = remotenode;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.remoteNode)
}

// optional .iop.locnet.ClientRequest client = 4;
inline bool Request::has_client() const {
  return RequestType_case() == kClient;
}
inline void Request::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Request::clear_client() {
  if (has_client()) {
    delete RequestType_.client_;
    clear_has_RequestType();
  }
}
inline  const ::iop::locnet::ClientRequest& Request::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Request.client)
  return has_client()
      ? *RequestType_.client_
      : ::iop::locnet::ClientRequest::default_instance();
}
inline ::iop::locnet::ClientRequest* Request::mutable_client() {
  if (!has_client()) {
    clear_RequestType();
    set_has_client();
    RequestType_.client_ = new ::iop::locnet::ClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Request.client)
  return RequestType_.client_;
}
inline ::iop::locnet::ClientRequest* Request::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Request.client)
  if (has_client()) {
    clear_has_RequestType();
    ::iop::locnet::ClientRequest* temp = RequestType_.client_;
    RequestType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_client(::iop::locnet::ClientRequest* client) {
  clear_RequestType();
  if (client) {
    set_has_client();
    RequestType_.client_ = client;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Request.client)
}

inline bool Request::has_RequestType() const {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void Request::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::RequestType_case() const {
  return Request::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .iop.locnet.Status status = 1;
inline void Response::clear_status() {
  status_ = 0;
}
inline ::iop::locnet::Status Response::status() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.status)
  return static_cast< ::iop::locnet::Status >(status_);
}
inline void Response::set_status(::iop::locnet::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.status)
}

// optional sint64 timestamp = 2;
inline void Response::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Response::timestamp() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.timestamp)
  return timestamp_;
}
inline void Response::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.Response.timestamp)
}

// optional string details = 3;
inline void Response::clear_details() {
  details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::details() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.details)
  return details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_details(const ::std::string& value) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.Response.details)
}
inline void Response::set_details(const char* value) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.Response.details)
}
inline void Response::set_details(const char* value, size_t size) {
  
  details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.Response.details)
}
inline ::std::string* Response::mutable_details() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.details)
  return details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_details() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.details)
  
  return details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_details(::std::string* details) {
  if (details != NULL) {
    
  } else {
    
  }
  details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), details);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.details)
}

// optional .iop.locnet.LocalServiceResponse localService = 4;
inline bool Response::has_localservice() const {
  return ResponseType_case() == kLocalService;
}
inline void Response::set_has_localservice() {
  _oneof_case_[0] = kLocalService;
}
inline void Response::clear_localservice() {
  if (has_localservice()) {
    delete ResponseType_.localservice_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::LocalServiceResponse& Response::localservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.localService)
  return has_localservice()
      ? *ResponseType_.localservice_
      : ::iop::locnet::LocalServiceResponse::default_instance();
}
inline ::iop::locnet::LocalServiceResponse* Response::mutable_localservice() {
  if (!has_localservice()) {
    clear_ResponseType();
    set_has_localservice();
    ResponseType_.localservice_ = new ::iop::locnet::LocalServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.localService)
  return ResponseType_.localservice_;
}
inline ::iop::locnet::LocalServiceResponse* Response::release_localservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.localService)
  if (has_localservice()) {
    clear_has_ResponseType();
    ::iop::locnet::LocalServiceResponse* temp = ResponseType_.localservice_;
    ResponseType_.localservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_localservice(::iop::locnet::LocalServiceResponse* localservice) {
  clear_ResponseType();
  if (localservice) {
    set_has_localservice();
    ResponseType_.localservice_ = localservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.localService)
}

// optional .iop.locnet.RemoteNodeResponse remoteNode = 5;
inline bool Response::has_remotenode() const {
  return ResponseType_case() == kRemoteNode;
}
inline void Response::set_has_remotenode() {
  _oneof_case_[0] = kRemoteNode;
}
inline void Response::clear_remotenode() {
  if (has_remotenode()) {
    delete ResponseType_.remotenode_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::RemoteNodeResponse& Response::remotenode() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.remoteNode)
  return has_remotenode()
      ? *ResponseType_.remotenode_
      : ::iop::locnet::RemoteNodeResponse::default_instance();
}
inline ::iop::locnet::RemoteNodeResponse* Response::mutable_remotenode() {
  if (!has_remotenode()) {
    clear_ResponseType();
    set_has_remotenode();
    ResponseType_.remotenode_ = new ::iop::locnet::RemoteNodeResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.remoteNode)
  return ResponseType_.remotenode_;
}
inline ::iop::locnet::RemoteNodeResponse* Response::release_remotenode() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.remoteNode)
  if (has_remotenode()) {
    clear_has_ResponseType();
    ::iop::locnet::RemoteNodeResponse* temp = ResponseType_.remotenode_;
    ResponseType_.remotenode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_remotenode(::iop::locnet::RemoteNodeResponse* remotenode) {
  clear_ResponseType();
  if (remotenode) {
    set_has_remotenode();
    ResponseType_.remotenode_ = remotenode;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.remoteNode)
}

// optional .iop.locnet.ClientResponse client = 6;
inline bool Response::has_client() const {
  return ResponseType_case() == kClient;
}
inline void Response::set_has_client() {
  _oneof_case_[0] = kClient;
}
inline void Response::clear_client() {
  if (has_client()) {
    delete ResponseType_.client_;
    clear_has_ResponseType();
  }
}
inline  const ::iop::locnet::ClientResponse& Response::client() const {
  // @@protoc_insertion_point(field_get:iop.locnet.Response.client)
  return has_client()
      ? *ResponseType_.client_
      : ::iop::locnet::ClientResponse::default_instance();
}
inline ::iop::locnet::ClientResponse* Response::mutable_client() {
  if (!has_client()) {
    clear_ResponseType();
    set_has_client();
    ResponseType_.client_ = new ::iop::locnet::ClientResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.Response.client)
  return ResponseType_.client_;
}
inline ::iop::locnet::ClientResponse* Response::release_client() {
  // @@protoc_insertion_point(field_release:iop.locnet.Response.client)
  if (has_client()) {
    clear_has_ResponseType();
    ::iop::locnet::ClientResponse* temp = ResponseType_.client_;
    ResponseType_.client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_client(::iop::locnet::ClientResponse* client) {
  clear_ResponseType();
  if (client) {
    set_has_client();
    ResponseType_.client_ = client;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.Response.client)
}

inline bool Response::has_ResponseType() const {
  return ResponseType_case() != RESPONSETYPE_NOT_SET;
}
inline void Response::clear_has_ResponseType() {
  _oneof_case_[0] = RESPONSETYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::ResponseType_case() const {
  return Response::ResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceRequest

// optional .iop.locnet.RegisterServiceRequest registerService = 1;
inline bool LocalServiceRequest::has_registerservice() const {
  return LocalServiceRequestType_case() == kRegisterService;
}
inline void LocalServiceRequest::set_has_registerservice() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceRequest::clear_registerservice() {
  if (has_registerservice()) {
    delete LocalServiceRequestType_.registerservice_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::RegisterServiceRequest& LocalServiceRequest::registerservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.registerService)
  return has_registerservice()
      ? *LocalServiceRequestType_.registerservice_
      : ::iop::locnet::RegisterServiceRequest::default_instance();
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::mutable_registerservice() {
  if (!has_registerservice()) {
    clear_LocalServiceRequestType();
    set_has_registerservice();
    LocalServiceRequestType_.registerservice_ = new ::iop::locnet::RegisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.registerService)
  return LocalServiceRequestType_.registerservice_;
}
inline ::iop::locnet::RegisterServiceRequest* LocalServiceRequest::release_registerservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.registerService)
  if (has_registerservice()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::RegisterServiceRequest* temp = LocalServiceRequestType_.registerservice_;
    LocalServiceRequestType_.registerservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_registerservice(::iop::locnet::RegisterServiceRequest* registerservice) {
  clear_LocalServiceRequestType();
  if (registerservice) {
    set_has_registerservice();
    LocalServiceRequestType_.registerservice_ = registerservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.registerService)
}

// optional .iop.locnet.DeregisterServiceRequest deregisterService = 2;
inline bool LocalServiceRequest::has_deregisterservice() const {
  return LocalServiceRequestType_case() == kDeregisterService;
}
inline void LocalServiceRequest::set_has_deregisterservice() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceRequest::clear_deregisterservice() {
  if (has_deregisterservice()) {
    delete LocalServiceRequestType_.deregisterservice_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::DeregisterServiceRequest& LocalServiceRequest::deregisterservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.deregisterService)
  return has_deregisterservice()
      ? *LocalServiceRequestType_.deregisterservice_
      : ::iop::locnet::DeregisterServiceRequest::default_instance();
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::mutable_deregisterservice() {
  if (!has_deregisterservice()) {
    clear_LocalServiceRequestType();
    set_has_deregisterservice();
    LocalServiceRequestType_.deregisterservice_ = new ::iop::locnet::DeregisterServiceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.deregisterService)
  return LocalServiceRequestType_.deregisterservice_;
}
inline ::iop::locnet::DeregisterServiceRequest* LocalServiceRequest::release_deregisterservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.deregisterService)
  if (has_deregisterservice()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::DeregisterServiceRequest* temp = LocalServiceRequestType_.deregisterservice_;
    LocalServiceRequestType_.deregisterservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_deregisterservice(::iop::locnet::DeregisterServiceRequest* deregisterservice) {
  clear_LocalServiceRequestType();
  if (deregisterservice) {
    set_has_deregisterservice();
    LocalServiceRequestType_.deregisterservice_ = deregisterservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.deregisterService)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceLocalRequest getNeighbourNodes = 3;
inline bool LocalServiceRequest::has_getneighbournodes() const {
  return LocalServiceRequestType_case() == kGetNeighbourNodes;
}
inline void LocalServiceRequest::set_has_getneighbournodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceRequest::clear_getneighbournodes() {
  if (has_getneighbournodes()) {
    delete LocalServiceRequestType_.getneighbournodes_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest& LocalServiceRequest::getneighbournodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.getNeighbourNodes)
  return has_getneighbournodes()
      ? *LocalServiceRequestType_.getneighbournodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::mutable_getneighbournodes() {
  if (!has_getneighbournodes()) {
    clear_LocalServiceRequestType();
    set_has_getneighbournodes();
    LocalServiceRequestType_.getneighbournodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.getNeighbourNodes)
  return LocalServiceRequestType_.getneighbournodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* LocalServiceRequest::release_getneighbournodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.getNeighbourNodes)
  if (has_getneighbournodes()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* temp = LocalServiceRequestType_.getneighbournodes_;
    LocalServiceRequestType_.getneighbournodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceLocalRequest* getneighbournodes) {
  clear_LocalServiceRequestType();
  if (getneighbournodes) {
    set_has_getneighbournodes();
    LocalServiceRequestType_.getneighbournodes_ = getneighbournodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.getNeighbourNodes)
}

// optional .iop.locnet.NeighbourhoodChangedNotificationRequest neighbourhoodChanged = 4;
inline bool LocalServiceRequest::has_neighbourhoodchanged() const {
  return LocalServiceRequestType_case() == kNeighbourhoodChanged;
}
inline void LocalServiceRequest::set_has_neighbourhoodchanged() {
  _oneof_case_[0] = kNeighbourhoodChanged;
}
inline void LocalServiceRequest::clear_neighbourhoodchanged() {
  if (has_neighbourhoodchanged()) {
    delete LocalServiceRequestType_.neighbourhoodchanged_;
    clear_has_LocalServiceRequestType();
  }
}
inline  const ::iop::locnet::NeighbourhoodChangedNotificationRequest& LocalServiceRequest::neighbourhoodchanged() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceRequest.neighbourhoodChanged)
  return has_neighbourhoodchanged()
      ? *LocalServiceRequestType_.neighbourhoodchanged_
      : ::iop::locnet::NeighbourhoodChangedNotificationRequest::default_instance();
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::mutable_neighbourhoodchanged() {
  if (!has_neighbourhoodchanged()) {
    clear_LocalServiceRequestType();
    set_has_neighbourhoodchanged();
    LocalServiceRequestType_.neighbourhoodchanged_ = new ::iop::locnet::NeighbourhoodChangedNotificationRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceRequest.neighbourhoodChanged)
  return LocalServiceRequestType_.neighbourhoodchanged_;
}
inline ::iop::locnet::NeighbourhoodChangedNotificationRequest* LocalServiceRequest::release_neighbourhoodchanged() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceRequest.neighbourhoodChanged)
  if (has_neighbourhoodchanged()) {
    clear_has_LocalServiceRequestType();
    ::iop::locnet::NeighbourhoodChangedNotificationRequest* temp = LocalServiceRequestType_.neighbourhoodchanged_;
    LocalServiceRequestType_.neighbourhoodchanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceRequest::set_allocated_neighbourhoodchanged(::iop::locnet::NeighbourhoodChangedNotificationRequest* neighbourhoodchanged) {
  clear_LocalServiceRequestType();
  if (neighbourhoodchanged) {
    set_has_neighbourhoodchanged();
    LocalServiceRequestType_.neighbourhoodchanged_ = neighbourhoodchanged;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceRequest.neighbourhoodChanged)
}

inline bool LocalServiceRequest::has_LocalServiceRequestType() const {
  return LocalServiceRequestType_case() != LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline void LocalServiceRequest::clear_has_LocalServiceRequestType() {
  _oneof_case_[0] = LOCALSERVICEREQUESTTYPE_NOT_SET;
}
inline LocalServiceRequest::LocalServiceRequestTypeCase LocalServiceRequest::LocalServiceRequestType_case() const {
  return LocalServiceRequest::LocalServiceRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalServiceResponse

// optional .iop.locnet.RegisterServiceResponse registerService = 1;
inline bool LocalServiceResponse::has_registerservice() const {
  return LocalServiceResponseType_case() == kRegisterService;
}
inline void LocalServiceResponse::set_has_registerservice() {
  _oneof_case_[0] = kRegisterService;
}
inline void LocalServiceResponse::clear_registerservice() {
  if (has_registerservice()) {
    delete LocalServiceResponseType_.registerservice_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::RegisterServiceResponse& LocalServiceResponse::registerservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.registerService)
  return has_registerservice()
      ? *LocalServiceResponseType_.registerservice_
      : ::iop::locnet::RegisterServiceResponse::default_instance();
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::mutable_registerservice() {
  if (!has_registerservice()) {
    clear_LocalServiceResponseType();
    set_has_registerservice();
    LocalServiceResponseType_.registerservice_ = new ::iop::locnet::RegisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.registerService)
  return LocalServiceResponseType_.registerservice_;
}
inline ::iop::locnet::RegisterServiceResponse* LocalServiceResponse::release_registerservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.registerService)
  if (has_registerservice()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::RegisterServiceResponse* temp = LocalServiceResponseType_.registerservice_;
    LocalServiceResponseType_.registerservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_registerservice(::iop::locnet::RegisterServiceResponse* registerservice) {
  clear_LocalServiceResponseType();
  if (registerservice) {
    set_has_registerservice();
    LocalServiceResponseType_.registerservice_ = registerservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.registerService)
}

// optional .iop.locnet.DeregisterServiceResponse deregisterService = 2;
inline bool LocalServiceResponse::has_deregisterservice() const {
  return LocalServiceResponseType_case() == kDeregisterService;
}
inline void LocalServiceResponse::set_has_deregisterservice() {
  _oneof_case_[0] = kDeregisterService;
}
inline void LocalServiceResponse::clear_deregisterservice() {
  if (has_deregisterservice()) {
    delete LocalServiceResponseType_.deregisterservice_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::DeregisterServiceResponse& LocalServiceResponse::deregisterservice() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.deregisterService)
  return has_deregisterservice()
      ? *LocalServiceResponseType_.deregisterservice_
      : ::iop::locnet::DeregisterServiceResponse::default_instance();
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::mutable_deregisterservice() {
  if (!has_deregisterservice()) {
    clear_LocalServiceResponseType();
    set_has_deregisterservice();
    LocalServiceResponseType_.deregisterservice_ = new ::iop::locnet::DeregisterServiceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.deregisterService)
  return LocalServiceResponseType_.deregisterservice_;
}
inline ::iop::locnet::DeregisterServiceResponse* LocalServiceResponse::release_deregisterservice() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.deregisterService)
  if (has_deregisterservice()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::DeregisterServiceResponse* temp = LocalServiceResponseType_.deregisterservice_;
    LocalServiceResponseType_.deregisterservice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_deregisterservice(::iop::locnet::DeregisterServiceResponse* deregisterservice) {
  clear_LocalServiceResponseType();
  if (deregisterservice) {
    set_has_deregisterservice();
    LocalServiceResponseType_.deregisterservice_ = deregisterservice;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.deregisterService)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceResponse getNeighbourNodes = 3;
inline bool LocalServiceResponse::has_getneighbournodes() const {
  return LocalServiceResponseType_case() == kGetNeighbourNodes;
}
inline void LocalServiceResponse::set_has_getneighbournodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void LocalServiceResponse::clear_getneighbournodes() {
  if (has_getneighbournodes()) {
    delete LocalServiceResponseType_.getneighbournodes_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& LocalServiceResponse::getneighbournodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.getNeighbourNodes)
  return has_getneighbournodes()
      ? *LocalServiceResponseType_.getneighbournodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::mutable_getneighbournodes() {
  if (!has_getneighbournodes()) {
    clear_LocalServiceResponseType();
    set_has_getneighbournodes();
    LocalServiceResponseType_.getneighbournodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.getNeighbourNodes)
  return LocalServiceResponseType_.getneighbournodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* LocalServiceResponse::release_getneighbournodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.getNeighbourNodes)
  if (has_getneighbournodes()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = LocalServiceResponseType_.getneighbournodes_;
    LocalServiceResponseType_.getneighbournodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes) {
  clear_LocalServiceResponseType();
  if (getneighbournodes) {
    set_has_getneighbournodes();
    LocalServiceResponseType_.getneighbournodes_ = getneighbournodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.getNeighbourNodes)
}

// optional .iop.locnet.NeighbourhoodChangedNotificationResponse neighbourhoodUpdated = 4;
inline bool LocalServiceResponse::has_neighbourhoodupdated() const {
  return LocalServiceResponseType_case() == kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::set_has_neighbourhoodupdated() {
  _oneof_case_[0] = kNeighbourhoodUpdated;
}
inline void LocalServiceResponse::clear_neighbourhoodupdated() {
  if (has_neighbourhoodupdated()) {
    delete LocalServiceResponseType_.neighbourhoodupdated_;
    clear_has_LocalServiceResponseType();
  }
}
inline  const ::iop::locnet::NeighbourhoodChangedNotificationResponse& LocalServiceResponse::neighbourhoodupdated() const {
  // @@protoc_insertion_point(field_get:iop.locnet.LocalServiceResponse.neighbourhoodUpdated)
  return has_neighbourhoodupdated()
      ? *LocalServiceResponseType_.neighbourhoodupdated_
      : ::iop::locnet::NeighbourhoodChangedNotificationResponse::default_instance();
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::mutable_neighbourhoodupdated() {
  if (!has_neighbourhoodupdated()) {
    clear_LocalServiceResponseType();
    set_has_neighbourhoodupdated();
    LocalServiceResponseType_.neighbourhoodupdated_ = new ::iop::locnet::NeighbourhoodChangedNotificationResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.LocalServiceResponse.neighbourhoodUpdated)
  return LocalServiceResponseType_.neighbourhoodupdated_;
}
inline ::iop::locnet::NeighbourhoodChangedNotificationResponse* LocalServiceResponse::release_neighbourhoodupdated() {
  // @@protoc_insertion_point(field_release:iop.locnet.LocalServiceResponse.neighbourhoodUpdated)
  if (has_neighbourhoodupdated()) {
    clear_has_LocalServiceResponseType();
    ::iop::locnet::NeighbourhoodChangedNotificationResponse* temp = LocalServiceResponseType_.neighbourhoodupdated_;
    LocalServiceResponseType_.neighbourhoodupdated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocalServiceResponse::set_allocated_neighbourhoodupdated(::iop::locnet::NeighbourhoodChangedNotificationResponse* neighbourhoodupdated) {
  clear_LocalServiceResponseType();
  if (neighbourhoodupdated) {
    set_has_neighbourhoodupdated();
    LocalServiceResponseType_.neighbourhoodupdated_ = neighbourhoodupdated;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.LocalServiceResponse.neighbourhoodUpdated)
}

inline bool LocalServiceResponse::has_LocalServiceResponseType() const {
  return LocalServiceResponseType_case() != LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline void LocalServiceResponse::clear_has_LocalServiceResponseType() {
  _oneof_case_[0] = LOCALSERVICERESPONSETYPE_NOT_SET;
}
inline LocalServiceResponse::LocalServiceResponseTypeCase LocalServiceResponse::LocalServiceResponseType_case() const {
  return LocalServiceResponse::LocalServiceResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterServiceRequest

// optional .iop.locnet.ServiceInfo service = 1;
inline bool RegisterServiceRequest::has_service() const {
  return !_is_default_instance_ && service_ != NULL;
}
inline void RegisterServiceRequest::clear_service() {
  if (GetArenaNoVirtual() == NULL && service_ != NULL) delete service_;
  service_ = NULL;
}
inline const ::iop::locnet::ServiceInfo& RegisterServiceRequest::service() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceRequest.service)
  return service_ != NULL ? *service_ : *default_instance_->service_;
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::mutable_service() {
  
  if (service_ == NULL) {
    service_ = new ::iop::locnet::ServiceInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceRequest.service)
  return service_;
}
inline ::iop::locnet::ServiceInfo* RegisterServiceRequest::release_service() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceRequest.service)
  
  ::iop::locnet::ServiceInfo* temp = service_;
  service_ = NULL;
  return temp;
}
inline void RegisterServiceRequest::set_allocated_service(::iop::locnet::ServiceInfo* service) {
  delete service_;
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceRequest.service)
}

// -------------------------------------------------------------------

// RegisterServiceResponse

// optional .iop.locnet.GpsLocation location = 1;
inline bool RegisterServiceResponse::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void RegisterServiceResponse::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& RegisterServiceResponse::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RegisterServiceResponse.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RegisterServiceResponse.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* RegisterServiceResponse::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.RegisterServiceResponse.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RegisterServiceResponse::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RegisterServiceResponse.location)
}

// -------------------------------------------------------------------

// DeregisterServiceRequest

// optional .iop.locnet.ServiceType serviceType = 1;
inline void DeregisterServiceRequest::clear_servicetype() {
  servicetype_ = 0;
}
inline ::iop::locnet::ServiceType DeregisterServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:iop.locnet.DeregisterServiceRequest.serviceType)
  return static_cast< ::iop::locnet::ServiceType >(servicetype_);
}
inline void DeregisterServiceRequest::set_servicetype(::iop::locnet::ServiceType value) {
  
  servicetype_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.DeregisterServiceRequest.serviceType)
}

// -------------------------------------------------------------------

// DeregisterServiceResponse

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceLocalRequest

// optional bool keepAliveAndSendUpdates = 1;
inline void GetNeighbourNodesByDistanceLocalRequest::clear_keepaliveandsendupdates() {
  keepaliveandsendupdates_ = false;
}
inline bool GetNeighbourNodesByDistanceLocalRequest::keepaliveandsendupdates() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keepAliveAndSendUpdates)
  return keepaliveandsendupdates_;
}
inline void GetNeighbourNodesByDistanceLocalRequest::set_keepaliveandsendupdates(bool value) {
  
  keepaliveandsendupdates_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNeighbourNodesByDistanceLocalRequest.keepAliveAndSendUpdates)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetNeighbourNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetNeighbourNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetNeighbourNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetNeighbourNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetNeighbourNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetNeighbourNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetNeighbourNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChange

// optional .iop.locnet.NodeInfo addedNodeInfo = 1;
inline bool NeighbourhoodChange::has_addednodeinfo() const {
  return ChangeType_case() == kAddedNodeInfo;
}
inline void NeighbourhoodChange::set_has_addednodeinfo() {
  _oneof_case_[0] = kAddedNodeInfo;
}
inline void NeighbourhoodChange::clear_addednodeinfo() {
  if (has_addednodeinfo()) {
    delete ChangeType_.addednodeinfo_;
    clear_has_ChangeType();
  }
}
inline  const ::iop::locnet::NodeInfo& NeighbourhoodChange::addednodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.addedNodeInfo)
  return has_addednodeinfo()
      ? *ChangeType_.addednodeinfo_
      : ::iop::locnet::NodeInfo::default_instance();
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_addednodeinfo() {
  if (!has_addednodeinfo()) {
    clear_ChangeType();
    set_has_addednodeinfo();
    ChangeType_.addednodeinfo_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.addedNodeInfo)
  return ChangeType_.addednodeinfo_;
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_addednodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.addedNodeInfo)
  if (has_addednodeinfo()) {
    clear_has_ChangeType();
    ::iop::locnet::NodeInfo* temp = ChangeType_.addednodeinfo_;
    ChangeType_.addednodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_addednodeinfo(::iop::locnet::NodeInfo* addednodeinfo) {
  clear_ChangeType();
  if (addednodeinfo) {
    set_has_addednodeinfo();
    ChangeType_.addednodeinfo_ = addednodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.addedNodeInfo)
}

// optional .iop.locnet.NodeInfo updatedNodeInfo = 2;
inline bool NeighbourhoodChange::has_updatednodeinfo() const {
  return ChangeType_case() == kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::set_has_updatednodeinfo() {
  _oneof_case_[0] = kUpdatedNodeInfo;
}
inline void NeighbourhoodChange::clear_updatednodeinfo() {
  if (has_updatednodeinfo()) {
    delete ChangeType_.updatednodeinfo_;
    clear_has_ChangeType();
  }
}
inline  const ::iop::locnet::NodeInfo& NeighbourhoodChange::updatednodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.updatedNodeInfo)
  return has_updatednodeinfo()
      ? *ChangeType_.updatednodeinfo_
      : ::iop::locnet::NodeInfo::default_instance();
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::mutable_updatednodeinfo() {
  if (!has_updatednodeinfo()) {
    clear_ChangeType();
    set_has_updatednodeinfo();
    ChangeType_.updatednodeinfo_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.updatedNodeInfo)
  return ChangeType_.updatednodeinfo_;
}
inline ::iop::locnet::NodeInfo* NeighbourhoodChange::release_updatednodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.updatedNodeInfo)
  if (has_updatednodeinfo()) {
    clear_has_ChangeType();
    ::iop::locnet::NodeInfo* temp = ChangeType_.updatednodeinfo_;
    ChangeType_.updatednodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_updatednodeinfo(::iop::locnet::NodeInfo* updatednodeinfo) {
  clear_ChangeType();
  if (updatednodeinfo) {
    set_has_updatednodeinfo();
    ChangeType_.updatednodeinfo_ = updatednodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.updatedNodeInfo)
}

// optional bytes removedNodeId = 3;
inline bool NeighbourhoodChange::has_removednodeid() const {
  return ChangeType_case() == kRemovedNodeId;
}
inline void NeighbourhoodChange::set_has_removednodeid() {
  _oneof_case_[0] = kRemovedNodeId;
}
inline void NeighbourhoodChange::clear_removednodeid() {
  if (has_removednodeid()) {
    ChangeType_.removednodeid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ChangeType();
  }
}
inline const ::std::string& NeighbourhoodChange::removednodeid() const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChange.removedNodeId)
  if (has_removednodeid()) {
    return ChangeType_.removednodeid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void NeighbourhoodChange::set_removednodeid(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removedNodeId)
  if (!has_removednodeid()) {
    clear_ChangeType();
    set_has_removednodeid();
    ChangeType_.removednodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removednodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.NeighbourhoodChange.removedNodeId)
}
inline void NeighbourhoodChange::set_removednodeid(const char* value) {
  if (!has_removednodeid()) {
    clear_ChangeType();
    set_has_removednodeid();
    ChangeType_.removednodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removednodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.NeighbourhoodChange.removedNodeId)
}
inline void NeighbourhoodChange::set_removednodeid(const void* value, size_t size) {
  if (!has_removednodeid()) {
    clear_ChangeType();
    set_has_removednodeid();
    ChangeType_.removednodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ChangeType_.removednodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.NeighbourhoodChange.removedNodeId)
}
inline ::std::string* NeighbourhoodChange::mutable_removednodeid() {
  if (!has_removednodeid()) {
    clear_ChangeType();
    set_has_removednodeid();
    ChangeType_.removednodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChange.removedNodeId)
  return ChangeType_.removednodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeighbourhoodChange::release_removednodeid() {
  // @@protoc_insertion_point(field_release:iop.locnet.NeighbourhoodChange.removedNodeId)
  if (has_removednodeid()) {
    clear_has_ChangeType();
    return ChangeType_.removednodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void NeighbourhoodChange::set_allocated_removednodeid(::std::string* removednodeid) {
  if (!has_removednodeid()) {
    ChangeType_.removednodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_ChangeType();
  if (removednodeid != NULL) {
    set_has_removednodeid();
    ChangeType_.removednodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        removednodeid);
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.NeighbourhoodChange.removedNodeId)
}

inline bool NeighbourhoodChange::has_ChangeType() const {
  return ChangeType_case() != CHANGETYPE_NOT_SET;
}
inline void NeighbourhoodChange::clear_has_ChangeType() {
  _oneof_case_[0] = CHANGETYPE_NOT_SET;
}
inline NeighbourhoodChange::ChangeTypeCase NeighbourhoodChange::ChangeType_case() const {
  return NeighbourhoodChange::ChangeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationRequest

// repeated .iop.locnet.NeighbourhoodChange changes = 1;
inline int NeighbourhoodChangedNotificationRequest::changes_size() const {
  return changes_.size();
}
inline void NeighbourhoodChangedNotificationRequest::clear_changes() {
  changes_.Clear();
}
inline const ::iop::locnet::NeighbourhoodChange& NeighbourhoodChangedNotificationRequest::changes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Get(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Mutable(index);
}
inline ::iop::locnet::NeighbourhoodChange* NeighbourhoodChangedNotificationRequest::add_changes() {
  // @@protoc_insertion_point(field_add:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >*
NeighbourhoodChangedNotificationRequest::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return &changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NeighbourhoodChange >&
NeighbourhoodChangedNotificationRequest::changes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.NeighbourhoodChangedNotificationRequest.changes)
  return changes_;
}

// -------------------------------------------------------------------

// NeighbourhoodChangedNotificationResponse

// -------------------------------------------------------------------

// RemoteNodeRequest

// optional .iop.locnet.BuildNetworkRequest acceptColleague = 1;
inline bool RemoteNodeRequest::has_acceptcolleague() const {
  return RemoteNodeRequestType_case() == kAcceptColleague;
}
inline void RemoteNodeRequest::set_has_acceptcolleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeRequest::clear_acceptcolleague() {
  if (has_acceptcolleague()) {
    delete RemoteNodeRequestType_.acceptcolleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::acceptcolleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.acceptColleague)
  return has_acceptcolleague()
      ? *RemoteNodeRequestType_.acceptcolleague_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_acceptcolleague() {
  if (!has_acceptcolleague()) {
    clear_RemoteNodeRequestType();
    set_has_acceptcolleague();
    RemoteNodeRequestType_.acceptcolleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.acceptColleague)
  return RemoteNodeRequestType_.acceptcolleague_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_acceptcolleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.acceptColleague)
  if (has_acceptcolleague()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.acceptcolleague_;
    RemoteNodeRequestType_.acceptcolleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_acceptcolleague(::iop::locnet::BuildNetworkRequest* acceptcolleague) {
  clear_RemoteNodeRequestType();
  if (acceptcolleague) {
    set_has_acceptcolleague();
    RemoteNodeRequestType_.acceptcolleague_ = acceptcolleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.acceptColleague)
}

// optional .iop.locnet.BuildNetworkRequest renewColleague = 2;
inline bool RemoteNodeRequest::has_renewcolleague() const {
  return RemoteNodeRequestType_case() == kRenewColleague;
}
inline void RemoteNodeRequest::set_has_renewcolleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeRequest::clear_renewcolleague() {
  if (has_renewcolleague()) {
    delete RemoteNodeRequestType_.renewcolleague_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renewcolleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renewColleague)
  return has_renewcolleague()
      ? *RemoteNodeRequestType_.renewcolleague_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renewcolleague() {
  if (!has_renewcolleague()) {
    clear_RemoteNodeRequestType();
    set_has_renewcolleague();
    RemoteNodeRequestType_.renewcolleague_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renewColleague)
  return RemoteNodeRequestType_.renewcolleague_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renewcolleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renewColleague)
  if (has_renewcolleague()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renewcolleague_;
    RemoteNodeRequestType_.renewcolleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_renewcolleague(::iop::locnet::BuildNetworkRequest* renewcolleague) {
  clear_RemoteNodeRequestType();
  if (renewcolleague) {
    set_has_renewcolleague();
    RemoteNodeRequestType_.renewcolleague_ = renewcolleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.renewColleague)
}

// optional .iop.locnet.BuildNetworkRequest acceptNeighbour = 3;
inline bool RemoteNodeRequest::has_acceptneighbour() const {
  return RemoteNodeRequestType_case() == kAcceptNeighbour;
}
inline void RemoteNodeRequest::set_has_acceptneighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeRequest::clear_acceptneighbour() {
  if (has_acceptneighbour()) {
    delete RemoteNodeRequestType_.acceptneighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::acceptneighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.acceptNeighbour)
  return has_acceptneighbour()
      ? *RemoteNodeRequestType_.acceptneighbour_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_acceptneighbour() {
  if (!has_acceptneighbour()) {
    clear_RemoteNodeRequestType();
    set_has_acceptneighbour();
    RemoteNodeRequestType_.acceptneighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.acceptNeighbour)
  return RemoteNodeRequestType_.acceptneighbour_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_acceptneighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.acceptNeighbour)
  if (has_acceptneighbour()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.acceptneighbour_;
    RemoteNodeRequestType_.acceptneighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_acceptneighbour(::iop::locnet::BuildNetworkRequest* acceptneighbour) {
  clear_RemoteNodeRequestType();
  if (acceptneighbour) {
    set_has_acceptneighbour();
    RemoteNodeRequestType_.acceptneighbour_ = acceptneighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.acceptNeighbour)
}

// optional .iop.locnet.BuildNetworkRequest renewNeighbour = 4;
inline bool RemoteNodeRequest::has_renewneighbour() const {
  return RemoteNodeRequestType_case() == kRenewNeighbour;
}
inline void RemoteNodeRequest::set_has_renewneighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeRequest::clear_renewneighbour() {
  if (has_renewneighbour()) {
    delete RemoteNodeRequestType_.renewneighbour_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::BuildNetworkRequest& RemoteNodeRequest::renewneighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.renewNeighbour)
  return has_renewneighbour()
      ? *RemoteNodeRequestType_.renewneighbour_
      : ::iop::locnet::BuildNetworkRequest::default_instance();
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::mutable_renewneighbour() {
  if (!has_renewneighbour()) {
    clear_RemoteNodeRequestType();
    set_has_renewneighbour();
    RemoteNodeRequestType_.renewneighbour_ = new ::iop::locnet::BuildNetworkRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.renewNeighbour)
  return RemoteNodeRequestType_.renewneighbour_;
}
inline ::iop::locnet::BuildNetworkRequest* RemoteNodeRequest::release_renewneighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.renewNeighbour)
  if (has_renewneighbour()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::BuildNetworkRequest* temp = RemoteNodeRequestType_.renewneighbour_;
    RemoteNodeRequestType_.renewneighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_renewneighbour(::iop::locnet::BuildNetworkRequest* renewneighbour) {
  clear_RemoteNodeRequestType();
  if (renewneighbour) {
    set_has_renewneighbour();
    RemoteNodeRequestType_.renewneighbour_ = renewneighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.renewNeighbour)
}

// optional .iop.locnet.GetNodeCountRequest getNodeCount = 5;
inline bool RemoteNodeRequest::has_getnodecount() const {
  return RemoteNodeRequestType_case() == kGetNodeCount;
}
inline void RemoteNodeRequest::set_has_getnodecount() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeRequest::clear_getnodecount() {
  if (has_getnodecount()) {
    delete RemoteNodeRequestType_.getnodecount_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetNodeCountRequest& RemoteNodeRequest::getnodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.getNodeCount)
  return has_getnodecount()
      ? *RemoteNodeRequestType_.getnodecount_
      : ::iop::locnet::GetNodeCountRequest::default_instance();
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::mutable_getnodecount() {
  if (!has_getnodecount()) {
    clear_RemoteNodeRequestType();
    set_has_getnodecount();
    RemoteNodeRequestType_.getnodecount_ = new ::iop::locnet::GetNodeCountRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.getNodeCount)
  return RemoteNodeRequestType_.getnodecount_;
}
inline ::iop::locnet::GetNodeCountRequest* RemoteNodeRequest::release_getnodecount() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.getNodeCount)
  if (has_getnodecount()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetNodeCountRequest* temp = RemoteNodeRequestType_.getnodecount_;
    RemoteNodeRequestType_.getnodecount_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_getnodecount(::iop::locnet::GetNodeCountRequest* getnodecount) {
  clear_RemoteNodeRequestType();
  if (getnodecount) {
    set_has_getnodecount();
    RemoteNodeRequestType_.getnodecount_ = getnodecount;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.getNodeCount)
}

// optional .iop.locnet.GetRandomNodesRequest getRandomNodes = 6;
inline bool RemoteNodeRequest::has_getrandomnodes() const {
  return RemoteNodeRequestType_case() == kGetRandomNodes;
}
inline void RemoteNodeRequest::set_has_getrandomnodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeRequest::clear_getrandomnodes() {
  if (has_getrandomnodes()) {
    delete RemoteNodeRequestType_.getrandomnodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetRandomNodesRequest& RemoteNodeRequest::getrandomnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.getRandomNodes)
  return has_getrandomnodes()
      ? *RemoteNodeRequestType_.getrandomnodes_
      : ::iop::locnet::GetRandomNodesRequest::default_instance();
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::mutable_getrandomnodes() {
  if (!has_getrandomnodes()) {
    clear_RemoteNodeRequestType();
    set_has_getrandomnodes();
    RemoteNodeRequestType_.getrandomnodes_ = new ::iop::locnet::GetRandomNodesRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.getRandomNodes)
  return RemoteNodeRequestType_.getrandomnodes_;
}
inline ::iop::locnet::GetRandomNodesRequest* RemoteNodeRequest::release_getrandomnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.getRandomNodes)
  if (has_getrandomnodes()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetRandomNodesRequest* temp = RemoteNodeRequestType_.getrandomnodes_;
    RemoteNodeRequestType_.getrandomnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_getrandomnodes(::iop::locnet::GetRandomNodesRequest* getrandomnodes) {
  clear_RemoteNodeRequestType();
  if (getrandomnodes) {
    set_has_getrandomnodes();
    RemoteNodeRequestType_.getrandomnodes_ = getrandomnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.getRandomNodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceRequest getClosestNodes = 7;
inline bool RemoteNodeRequest::has_getclosestnodes() const {
  return RemoteNodeRequestType_case() == kGetClosestNodes;
}
inline void RemoteNodeRequest::set_has_getclosestnodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeRequest::clear_getclosestnodes() {
  if (has_getclosestnodes()) {
    delete RemoteNodeRequestType_.getclosestnodes_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceRequest& RemoteNodeRequest::getclosestnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.getClosestNodes)
  return has_getclosestnodes()
      ? *RemoteNodeRequestType_.getclosestnodes_
      : ::iop::locnet::GetClosestNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::mutable_getclosestnodes() {
  if (!has_getclosestnodes()) {
    clear_RemoteNodeRequestType();
    set_has_getclosestnodes();
    RemoteNodeRequestType_.getclosestnodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.getClosestNodes)
  return RemoteNodeRequestType_.getclosestnodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* RemoteNodeRequest::release_getclosestnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.getClosestNodes)
  if (has_getclosestnodes()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetClosestNodesByDistanceRequest* temp = RemoteNodeRequestType_.getclosestnodes_;
    RemoteNodeRequestType_.getclosestnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes) {
  clear_RemoteNodeRequestType();
  if (getclosestnodes) {
    set_has_getclosestnodes();
    RemoteNodeRequestType_.getclosestnodes_ = getclosestnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.getClosestNodes)
}

// optional .iop.locnet.GetNodeInfoRequest getNodeInfo = 8;
inline bool RemoteNodeRequest::has_getnodeinfo() const {
  return RemoteNodeRequestType_case() == kGetNodeInfo;
}
inline void RemoteNodeRequest::set_has_getnodeinfo() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeRequest::clear_getnodeinfo() {
  if (has_getnodeinfo()) {
    delete RemoteNodeRequestType_.getnodeinfo_;
    clear_has_RemoteNodeRequestType();
  }
}
inline  const ::iop::locnet::GetNodeInfoRequest& RemoteNodeRequest::getnodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeRequest.getNodeInfo)
  return has_getnodeinfo()
      ? *RemoteNodeRequestType_.getnodeinfo_
      : ::iop::locnet::GetNodeInfoRequest::default_instance();
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::mutable_getnodeinfo() {
  if (!has_getnodeinfo()) {
    clear_RemoteNodeRequestType();
    set_has_getnodeinfo();
    RemoteNodeRequestType_.getnodeinfo_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeRequest.getNodeInfo)
  return RemoteNodeRequestType_.getnodeinfo_;
}
inline ::iop::locnet::GetNodeInfoRequest* RemoteNodeRequest::release_getnodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeRequest.getNodeInfo)
  if (has_getnodeinfo()) {
    clear_has_RemoteNodeRequestType();
    ::iop::locnet::GetNodeInfoRequest* temp = RemoteNodeRequestType_.getnodeinfo_;
    RemoteNodeRequestType_.getnodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeRequest::set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoRequest* getnodeinfo) {
  clear_RemoteNodeRequestType();
  if (getnodeinfo) {
    set_has_getnodeinfo();
    RemoteNodeRequestType_.getnodeinfo_ = getnodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeRequest.getNodeInfo)
}

inline bool RemoteNodeRequest::has_RemoteNodeRequestType() const {
  return RemoteNodeRequestType_case() != REMOTENODEREQUESTTYPE_NOT_SET;
}
inline void RemoteNodeRequest::clear_has_RemoteNodeRequestType() {
  _oneof_case_[0] = REMOTENODEREQUESTTYPE_NOT_SET;
}
inline RemoteNodeRequest::RemoteNodeRequestTypeCase RemoteNodeRequest::RemoteNodeRequestType_case() const {
  return RemoteNodeRequest::RemoteNodeRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteNodeResponse

// optional .iop.locnet.BuildNetworkResponse acceptColleague = 1;
inline bool RemoteNodeResponse::has_acceptcolleague() const {
  return RemoteNodeResponseType_case() == kAcceptColleague;
}
inline void RemoteNodeResponse::set_has_acceptcolleague() {
  _oneof_case_[0] = kAcceptColleague;
}
inline void RemoteNodeResponse::clear_acceptcolleague() {
  if (has_acceptcolleague()) {
    delete RemoteNodeResponseType_.acceptcolleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::acceptcolleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.acceptColleague)
  return has_acceptcolleague()
      ? *RemoteNodeResponseType_.acceptcolleague_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_acceptcolleague() {
  if (!has_acceptcolleague()) {
    clear_RemoteNodeResponseType();
    set_has_acceptcolleague();
    RemoteNodeResponseType_.acceptcolleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.acceptColleague)
  return RemoteNodeResponseType_.acceptcolleague_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_acceptcolleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.acceptColleague)
  if (has_acceptcolleague()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.acceptcolleague_;
    RemoteNodeResponseType_.acceptcolleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_acceptcolleague(::iop::locnet::BuildNetworkResponse* acceptcolleague) {
  clear_RemoteNodeResponseType();
  if (acceptcolleague) {
    set_has_acceptcolleague();
    RemoteNodeResponseType_.acceptcolleague_ = acceptcolleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.acceptColleague)
}

// optional .iop.locnet.BuildNetworkResponse renewColleague = 2;
inline bool RemoteNodeResponse::has_renewcolleague() const {
  return RemoteNodeResponseType_case() == kRenewColleague;
}
inline void RemoteNodeResponse::set_has_renewcolleague() {
  _oneof_case_[0] = kRenewColleague;
}
inline void RemoteNodeResponse::clear_renewcolleague() {
  if (has_renewcolleague()) {
    delete RemoteNodeResponseType_.renewcolleague_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renewcolleague() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renewColleague)
  return has_renewcolleague()
      ? *RemoteNodeResponseType_.renewcolleague_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renewcolleague() {
  if (!has_renewcolleague()) {
    clear_RemoteNodeResponseType();
    set_has_renewcolleague();
    RemoteNodeResponseType_.renewcolleague_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renewColleague)
  return RemoteNodeResponseType_.renewcolleague_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renewcolleague() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renewColleague)
  if (has_renewcolleague()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renewcolleague_;
    RemoteNodeResponseType_.renewcolleague_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_renewcolleague(::iop::locnet::BuildNetworkResponse* renewcolleague) {
  clear_RemoteNodeResponseType();
  if (renewcolleague) {
    set_has_renewcolleague();
    RemoteNodeResponseType_.renewcolleague_ = renewcolleague;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.renewColleague)
}

// optional .iop.locnet.BuildNetworkResponse acceptNeighbour = 3;
inline bool RemoteNodeResponse::has_acceptneighbour() const {
  return RemoteNodeResponseType_case() == kAcceptNeighbour;
}
inline void RemoteNodeResponse::set_has_acceptneighbour() {
  _oneof_case_[0] = kAcceptNeighbour;
}
inline void RemoteNodeResponse::clear_acceptneighbour() {
  if (has_acceptneighbour()) {
    delete RemoteNodeResponseType_.acceptneighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::acceptneighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.acceptNeighbour)
  return has_acceptneighbour()
      ? *RemoteNodeResponseType_.acceptneighbour_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_acceptneighbour() {
  if (!has_acceptneighbour()) {
    clear_RemoteNodeResponseType();
    set_has_acceptneighbour();
    RemoteNodeResponseType_.acceptneighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.acceptNeighbour)
  return RemoteNodeResponseType_.acceptneighbour_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_acceptneighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.acceptNeighbour)
  if (has_acceptneighbour()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.acceptneighbour_;
    RemoteNodeResponseType_.acceptneighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_acceptneighbour(::iop::locnet::BuildNetworkResponse* acceptneighbour) {
  clear_RemoteNodeResponseType();
  if (acceptneighbour) {
    set_has_acceptneighbour();
    RemoteNodeResponseType_.acceptneighbour_ = acceptneighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.acceptNeighbour)
}

// optional .iop.locnet.BuildNetworkResponse renewNeighbour = 4;
inline bool RemoteNodeResponse::has_renewneighbour() const {
  return RemoteNodeResponseType_case() == kRenewNeighbour;
}
inline void RemoteNodeResponse::set_has_renewneighbour() {
  _oneof_case_[0] = kRenewNeighbour;
}
inline void RemoteNodeResponse::clear_renewneighbour() {
  if (has_renewneighbour()) {
    delete RemoteNodeResponseType_.renewneighbour_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::BuildNetworkResponse& RemoteNodeResponse::renewneighbour() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.renewNeighbour)
  return has_renewneighbour()
      ? *RemoteNodeResponseType_.renewneighbour_
      : ::iop::locnet::BuildNetworkResponse::default_instance();
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::mutable_renewneighbour() {
  if (!has_renewneighbour()) {
    clear_RemoteNodeResponseType();
    set_has_renewneighbour();
    RemoteNodeResponseType_.renewneighbour_ = new ::iop::locnet::BuildNetworkResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.renewNeighbour)
  return RemoteNodeResponseType_.renewneighbour_;
}
inline ::iop::locnet::BuildNetworkResponse* RemoteNodeResponse::release_renewneighbour() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.renewNeighbour)
  if (has_renewneighbour()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::BuildNetworkResponse* temp = RemoteNodeResponseType_.renewneighbour_;
    RemoteNodeResponseType_.renewneighbour_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_renewneighbour(::iop::locnet::BuildNetworkResponse* renewneighbour) {
  clear_RemoteNodeResponseType();
  if (renewneighbour) {
    set_has_renewneighbour();
    RemoteNodeResponseType_.renewneighbour_ = renewneighbour;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.renewNeighbour)
}

// optional .iop.locnet.GetNodeCountResponse getNodeCount = 5;
inline bool RemoteNodeResponse::has_getnodecount() const {
  return RemoteNodeResponseType_case() == kGetNodeCount;
}
inline void RemoteNodeResponse::set_has_getnodecount() {
  _oneof_case_[0] = kGetNodeCount;
}
inline void RemoteNodeResponse::clear_getnodecount() {
  if (has_getnodecount()) {
    delete RemoteNodeResponseType_.getnodecount_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetNodeCountResponse& RemoteNodeResponse::getnodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.getNodeCount)
  return has_getnodecount()
      ? *RemoteNodeResponseType_.getnodecount_
      : ::iop::locnet::GetNodeCountResponse::default_instance();
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::mutable_getnodecount() {
  if (!has_getnodecount()) {
    clear_RemoteNodeResponseType();
    set_has_getnodecount();
    RemoteNodeResponseType_.getnodecount_ = new ::iop::locnet::GetNodeCountResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.getNodeCount)
  return RemoteNodeResponseType_.getnodecount_;
}
inline ::iop::locnet::GetNodeCountResponse* RemoteNodeResponse::release_getnodecount() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.getNodeCount)
  if (has_getnodecount()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetNodeCountResponse* temp = RemoteNodeResponseType_.getnodecount_;
    RemoteNodeResponseType_.getnodecount_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_getnodecount(::iop::locnet::GetNodeCountResponse* getnodecount) {
  clear_RemoteNodeResponseType();
  if (getnodecount) {
    set_has_getnodecount();
    RemoteNodeResponseType_.getnodecount_ = getnodecount;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.getNodeCount)
}

// optional .iop.locnet.GetRandomNodesResponse getRandomNodes = 6;
inline bool RemoteNodeResponse::has_getrandomnodes() const {
  return RemoteNodeResponseType_case() == kGetRandomNodes;
}
inline void RemoteNodeResponse::set_has_getrandomnodes() {
  _oneof_case_[0] = kGetRandomNodes;
}
inline void RemoteNodeResponse::clear_getrandomnodes() {
  if (has_getrandomnodes()) {
    delete RemoteNodeResponseType_.getrandomnodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetRandomNodesResponse& RemoteNodeResponse::getrandomnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.getRandomNodes)
  return has_getrandomnodes()
      ? *RemoteNodeResponseType_.getrandomnodes_
      : ::iop::locnet::GetRandomNodesResponse::default_instance();
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::mutable_getrandomnodes() {
  if (!has_getrandomnodes()) {
    clear_RemoteNodeResponseType();
    set_has_getrandomnodes();
    RemoteNodeResponseType_.getrandomnodes_ = new ::iop::locnet::GetRandomNodesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.getRandomNodes)
  return RemoteNodeResponseType_.getrandomnodes_;
}
inline ::iop::locnet::GetRandomNodesResponse* RemoteNodeResponse::release_getrandomnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.getRandomNodes)
  if (has_getrandomnodes()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetRandomNodesResponse* temp = RemoteNodeResponseType_.getrandomnodes_;
    RemoteNodeResponseType_.getrandomnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_getrandomnodes(::iop::locnet::GetRandomNodesResponse* getrandomnodes) {
  clear_RemoteNodeResponseType();
  if (getrandomnodes) {
    set_has_getrandomnodes();
    RemoteNodeResponseType_.getrandomnodes_ = getrandomnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.getRandomNodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceResponse getClosestNodes = 7;
inline bool RemoteNodeResponse::has_getclosestnodes() const {
  return RemoteNodeResponseType_case() == kGetClosestNodes;
}
inline void RemoteNodeResponse::set_has_getclosestnodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void RemoteNodeResponse::clear_getclosestnodes() {
  if (has_getclosestnodes()) {
    delete RemoteNodeResponseType_.getclosestnodes_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceResponse& RemoteNodeResponse::getclosestnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.getClosestNodes)
  return has_getclosestnodes()
      ? *RemoteNodeResponseType_.getclosestnodes_
      : ::iop::locnet::GetClosestNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::mutable_getclosestnodes() {
  if (!has_getclosestnodes()) {
    clear_RemoteNodeResponseType();
    set_has_getclosestnodes();
    RemoteNodeResponseType_.getclosestnodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.getClosestNodes)
  return RemoteNodeResponseType_.getclosestnodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* RemoteNodeResponse::release_getclosestnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.getClosestNodes)
  if (has_getclosestnodes()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetClosestNodesByDistanceResponse* temp = RemoteNodeResponseType_.getclosestnodes_;
    RemoteNodeResponseType_.getclosestnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes) {
  clear_RemoteNodeResponseType();
  if (getclosestnodes) {
    set_has_getclosestnodes();
    RemoteNodeResponseType_.getclosestnodes_ = getclosestnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.getClosestNodes)
}

// optional .iop.locnet.GetNodeInfoResponse getNodeInfo = 8;
inline bool RemoteNodeResponse::has_getnodeinfo() const {
  return RemoteNodeResponseType_case() == kGetNodeInfo;
}
inline void RemoteNodeResponse::set_has_getnodeinfo() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void RemoteNodeResponse::clear_getnodeinfo() {
  if (has_getnodeinfo()) {
    delete RemoteNodeResponseType_.getnodeinfo_;
    clear_has_RemoteNodeResponseType();
  }
}
inline  const ::iop::locnet::GetNodeInfoResponse& RemoteNodeResponse::getnodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.RemoteNodeResponse.getNodeInfo)
  return has_getnodeinfo()
      ? *RemoteNodeResponseType_.getnodeinfo_
      : ::iop::locnet::GetNodeInfoResponse::default_instance();
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::mutable_getnodeinfo() {
  if (!has_getnodeinfo()) {
    clear_RemoteNodeResponseType();
    set_has_getnodeinfo();
    RemoteNodeResponseType_.getnodeinfo_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.RemoteNodeResponse.getNodeInfo)
  return RemoteNodeResponseType_.getnodeinfo_;
}
inline ::iop::locnet::GetNodeInfoResponse* RemoteNodeResponse::release_getnodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.RemoteNodeResponse.getNodeInfo)
  if (has_getnodeinfo()) {
    clear_has_RemoteNodeResponseType();
    ::iop::locnet::GetNodeInfoResponse* temp = RemoteNodeResponseType_.getnodeinfo_;
    RemoteNodeResponseType_.getnodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RemoteNodeResponse::set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoResponse* getnodeinfo) {
  clear_RemoteNodeResponseType();
  if (getnodeinfo) {
    set_has_getnodeinfo();
    RemoteNodeResponseType_.getnodeinfo_ = getnodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.RemoteNodeResponse.getNodeInfo)
}

inline bool RemoteNodeResponse::has_RemoteNodeResponseType() const {
  return RemoteNodeResponseType_case() != REMOTENODERESPONSETYPE_NOT_SET;
}
inline void RemoteNodeResponse::clear_has_RemoteNodeResponseType() {
  _oneof_case_[0] = REMOTENODERESPONSETYPE_NOT_SET;
}
inline RemoteNodeResponse::RemoteNodeResponseTypeCase RemoteNodeResponse::RemoteNodeResponseType_case() const {
  return RemoteNodeResponse::RemoteNodeResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BuildNetworkRequest

// optional .iop.locnet.NodeInfo requestorNodeInfo = 1;
inline bool BuildNetworkRequest::has_requestornodeinfo() const {
  return !_is_default_instance_ && requestornodeinfo_ != NULL;
}
inline void BuildNetworkRequest::clear_requestornodeinfo() {
  if (GetArenaNoVirtual() == NULL && requestornodeinfo_ != NULL) delete requestornodeinfo_;
  requestornodeinfo_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkRequest::requestornodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkRequest.requestorNodeInfo)
  return requestornodeinfo_ != NULL ? *requestornodeinfo_ : *default_instance_->requestornodeinfo_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::mutable_requestornodeinfo() {
  
  if (requestornodeinfo_ == NULL) {
    requestornodeinfo_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkRequest.requestorNodeInfo)
  return requestornodeinfo_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkRequest::release_requestornodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkRequest.requestorNodeInfo)
  
  ::iop::locnet::NodeInfo* temp = requestornodeinfo_;
  requestornodeinfo_ = NULL;
  return temp;
}
inline void BuildNetworkRequest::set_allocated_requestornodeinfo(::iop::locnet::NodeInfo* requestornodeinfo) {
  delete requestornodeinfo_;
  requestornodeinfo_ = requestornodeinfo;
  if (requestornodeinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkRequest.requestorNodeInfo)
}

// -------------------------------------------------------------------

// BuildNetworkResponse

// optional bool accepted = 1;
inline void BuildNetworkResponse::clear_accepted() {
  accepted_ = false;
}
inline bool BuildNetworkResponse::accepted() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.accepted)
  return accepted_;
}
inline void BuildNetworkResponse::set_accepted(bool value) {
  
  accepted_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.accepted)
}

// optional .iop.locnet.NodeInfo acceptorNodeInfo = 2;
inline bool BuildNetworkResponse::has_acceptornodeinfo() const {
  return !_is_default_instance_ && acceptornodeinfo_ != NULL;
}
inline void BuildNetworkResponse::clear_acceptornodeinfo() {
  if (GetArenaNoVirtual() == NULL && acceptornodeinfo_ != NULL) delete acceptornodeinfo_;
  acceptornodeinfo_ = NULL;
}
inline const ::iop::locnet::NodeInfo& BuildNetworkResponse::acceptornodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.acceptorNodeInfo)
  return acceptornodeinfo_ != NULL ? *acceptornodeinfo_ : *default_instance_->acceptornodeinfo_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::mutable_acceptornodeinfo() {
  
  if (acceptornodeinfo_ == NULL) {
    acceptornodeinfo_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.acceptorNodeInfo)
  return acceptornodeinfo_;
}
inline ::iop::locnet::NodeInfo* BuildNetworkResponse::release_acceptornodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.acceptorNodeInfo)
  
  ::iop::locnet::NodeInfo* temp = acceptornodeinfo_;
  acceptornodeinfo_ = NULL;
  return temp;
}
inline void BuildNetworkResponse::set_allocated_acceptornodeinfo(::iop::locnet::NodeInfo* acceptornodeinfo) {
  delete acceptornodeinfo_;
  acceptornodeinfo_ = acceptornodeinfo;
  if (acceptornodeinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.acceptorNodeInfo)
}

// optional bytes remoteIpAddress = 3;
inline void BuildNetworkResponse::clear_remoteipaddress() {
  remoteipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildNetworkResponse::remoteipaddress() const {
  // @@protoc_insertion_point(field_get:iop.locnet.BuildNetworkResponse.remoteIpAddress)
  return remoteipaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildNetworkResponse::set_remoteipaddress(const ::std::string& value) {
  
  remoteipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iop.locnet.BuildNetworkResponse.remoteIpAddress)
}
inline void BuildNetworkResponse::set_remoteipaddress(const char* value) {
  
  remoteipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iop.locnet.BuildNetworkResponse.remoteIpAddress)
}
inline void BuildNetworkResponse::set_remoteipaddress(const void* value, size_t size) {
  
  remoteipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iop.locnet.BuildNetworkResponse.remoteIpAddress)
}
inline ::std::string* BuildNetworkResponse::mutable_remoteipaddress() {
  
  // @@protoc_insertion_point(field_mutable:iop.locnet.BuildNetworkResponse.remoteIpAddress)
  return remoteipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildNetworkResponse::release_remoteipaddress() {
  // @@protoc_insertion_point(field_release:iop.locnet.BuildNetworkResponse.remoteIpAddress)
  
  return remoteipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildNetworkResponse::set_allocated_remoteipaddress(::std::string* remoteipaddress) {
  if (remoteipaddress != NULL) {
    
  } else {
    
  }
  remoteipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remoteipaddress);
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.BuildNetworkResponse.remoteIpAddress)
}

// -------------------------------------------------------------------

// GetNodeCountRequest

// -------------------------------------------------------------------

// GetNodeCountResponse

// optional uint32 nodeCount = 1;
inline void GetNodeCountResponse::clear_nodecount() {
  nodecount_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeCountResponse::nodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeCountResponse.nodeCount)
  return nodecount_;
}
inline void GetNodeCountResponse::set_nodecount(::google::protobuf::uint32 value) {
  
  nodecount_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetNodeCountResponse.nodeCount)
}

// -------------------------------------------------------------------

// GetRandomNodesRequest

// optional uint32 maxNodeCount = 1;
inline void GetRandomNodesRequest::clear_maxnodecount() {
  maxnodecount_ = 0u;
}
inline ::google::protobuf::uint32 GetRandomNodesRequest::maxnodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.maxNodeCount)
  return maxnodecount_;
}
inline void GetRandomNodesRequest::set_maxnodecount(::google::protobuf::uint32 value) {
  
  maxnodecount_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.maxNodeCount)
}

// optional bool includeNeighbours = 2;
inline void GetRandomNodesRequest::clear_includeneighbours() {
  includeneighbours_ = false;
}
inline bool GetRandomNodesRequest::includeneighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesRequest.includeNeighbours)
  return includeneighbours_;
}
inline void GetRandomNodesRequest::set_includeneighbours(bool value) {
  
  includeneighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetRandomNodesRequest.includeNeighbours)
}

// -------------------------------------------------------------------

// GetRandomNodesResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetRandomNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetRandomNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetRandomNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetRandomNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetRandomNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetRandomNodesResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetRandomNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetRandomNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceRequest

// optional .iop.locnet.GpsLocation location = 1;
inline bool GetClosestNodesByDistanceRequest::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void GetClosestNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& GetClosestNodesByDistanceRequest::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceRequest.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* GetClosestNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetClosestNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void GetClosestNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetClosestNodesByDistanceRequest.location)
}

// optional float maxRadiusKm = 2;
inline void GetClosestNodesByDistanceRequest::clear_maxradiuskm() {
  maxradiuskm_ = 0;
}
inline float GetClosestNodesByDistanceRequest::maxradiuskm() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.maxRadiusKm)
  return maxradiuskm_;
}
inline void GetClosestNodesByDistanceRequest::set_maxradiuskm(float value) {
  
  maxradiuskm_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.maxRadiusKm)
}

// optional uint32 maxNodeCount = 3;
inline void GetClosestNodesByDistanceRequest::clear_maxnodecount() {
  maxnodecount_ = 0u;
}
inline ::google::protobuf::uint32 GetClosestNodesByDistanceRequest::maxnodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.maxNodeCount)
  return maxnodecount_;
}
inline void GetClosestNodesByDistanceRequest::set_maxnodecount(::google::protobuf::uint32 value) {
  
  maxnodecount_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.maxNodeCount)
}

// optional bool includeNeighbours = 4;
inline void GetClosestNodesByDistanceRequest::clear_includeneighbours() {
  includeneighbours_ = false;
}
inline bool GetClosestNodesByDistanceRequest::includeneighbours() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceRequest.includeNeighbours)
  return includeneighbours_;
}
inline void GetClosestNodesByDistanceRequest::set_includeneighbours(bool value) {
  
  includeneighbours_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.GetClosestNodesByDistanceRequest.includeNeighbours)
}

// -------------------------------------------------------------------

// GetClosestNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo nodes = 1;
inline int GetClosestNodesByDistanceResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetClosestNodesByDistanceResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& GetClosestNodesByDistanceResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* GetClosestNodesByDistanceResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
GetClosestNodesByDistanceResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
GetClosestNodesByDistanceResponse::nodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.GetClosestNodesByDistanceResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// ClientRequest

// optional .iop.locnet.GetNodeInfoRequest getNodeInfo = 1;
inline bool ClientRequest::has_getnodeinfo() const {
  return ClientRequestType_case() == kGetNodeInfo;
}
inline void ClientRequest::set_has_getnodeinfo() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientRequest::clear_getnodeinfo() {
  if (has_getnodeinfo()) {
    delete ClientRequestType_.getnodeinfo_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetNodeInfoRequest& ClientRequest::getnodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.getNodeInfo)
  return has_getnodeinfo()
      ? *ClientRequestType_.getnodeinfo_
      : ::iop::locnet::GetNodeInfoRequest::default_instance();
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::mutable_getnodeinfo() {
  if (!has_getnodeinfo()) {
    clear_ClientRequestType();
    set_has_getnodeinfo();
    ClientRequestType_.getnodeinfo_ = new ::iop::locnet::GetNodeInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.getNodeInfo)
  return ClientRequestType_.getnodeinfo_;
}
inline ::iop::locnet::GetNodeInfoRequest* ClientRequest::release_getnodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.getNodeInfo)
  if (has_getnodeinfo()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetNodeInfoRequest* temp = ClientRequestType_.getnodeinfo_;
    ClientRequestType_.getnodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoRequest* getnodeinfo) {
  clear_ClientRequestType();
  if (getnodeinfo) {
    set_has_getnodeinfo();
    ClientRequestType_.getnodeinfo_ = getnodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.getNodeInfo)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceClientRequest getNeighbourNodes = 2;
inline bool ClientRequest::has_getneighbournodes() const {
  return ClientRequestType_case() == kGetNeighbourNodes;
}
inline void ClientRequest::set_has_getneighbournodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientRequest::clear_getneighbournodes() {
  if (has_getneighbournodes()) {
    delete ClientRequestType_.getneighbournodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceClientRequest& ClientRequest::getneighbournodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.getNeighbourNodes)
  return has_getneighbournodes()
      ? *ClientRequestType_.getneighbournodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceClientRequest::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::mutable_getneighbournodes() {
  if (!has_getneighbournodes()) {
    clear_ClientRequestType();
    set_has_getneighbournodes();
    ClientRequestType_.getneighbournodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceClientRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.getNeighbourNodes)
  return ClientRequestType_.getneighbournodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* ClientRequest::release_getneighbournodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.getNeighbourNodes)
  if (has_getneighbournodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetNeighbourNodesByDistanceClientRequest* temp = ClientRequestType_.getneighbournodes_;
    ClientRequestType_.getneighbournodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceClientRequest* getneighbournodes) {
  clear_ClientRequestType();
  if (getneighbournodes) {
    set_has_getneighbournodes();
    ClientRequestType_.getneighbournodes_ = getneighbournodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.getNeighbourNodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceRequest getClosestNodes = 3;
inline bool ClientRequest::has_getclosestnodes() const {
  return ClientRequestType_case() == kGetClosestNodes;
}
inline void ClientRequest::set_has_getclosestnodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientRequest::clear_getclosestnodes() {
  if (has_getclosestnodes()) {
    delete ClientRequestType_.getclosestnodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceRequest& ClientRequest::getclosestnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.getClosestNodes)
  return has_getclosestnodes()
      ? *ClientRequestType_.getclosestnodes_
      : ::iop::locnet::GetClosestNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::mutable_getclosestnodes() {
  if (!has_getclosestnodes()) {
    clear_ClientRequestType();
    set_has_getclosestnodes();
    ClientRequestType_.getclosestnodes_ = new ::iop::locnet::GetClosestNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.getClosestNodes)
  return ClientRequestType_.getclosestnodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceRequest* ClientRequest::release_getclosestnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.getClosestNodes)
  if (has_getclosestnodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::GetClosestNodesByDistanceRequest* temp = ClientRequestType_.getclosestnodes_;
    ClientRequestType_.getclosestnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceRequest* getclosestnodes) {
  clear_ClientRequestType();
  if (getclosestnodes) {
    set_has_getclosestnodes();
    ClientRequestType_.getclosestnodes_ = getclosestnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.getClosestNodes)
}

// optional .iop.locnet.ExploreNetworkNodesByDistanceRequest exploreNodes = 4;
inline bool ClientRequest::has_explorenodes() const {
  return ClientRequestType_case() == kExploreNodes;
}
inline void ClientRequest::set_has_explorenodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientRequest::clear_explorenodes() {
  if (has_explorenodes()) {
    delete ClientRequestType_.explorenodes_;
    clear_has_ClientRequestType();
  }
}
inline  const ::iop::locnet::ExploreNetworkNodesByDistanceRequest& ClientRequest::explorenodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientRequest.exploreNodes)
  return has_explorenodes()
      ? *ClientRequestType_.explorenodes_
      : ::iop::locnet::ExploreNetworkNodesByDistanceRequest::default_instance();
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::mutable_explorenodes() {
  if (!has_explorenodes()) {
    clear_ClientRequestType();
    set_has_explorenodes();
    ClientRequestType_.explorenodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientRequest.exploreNodes)
  return ClientRequestType_.explorenodes_;
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceRequest* ClientRequest::release_explorenodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientRequest.exploreNodes)
  if (has_explorenodes()) {
    clear_has_ClientRequestType();
    ::iop::locnet::ExploreNetworkNodesByDistanceRequest* temp = ClientRequestType_.explorenodes_;
    ClientRequestType_.explorenodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_explorenodes(::iop::locnet::ExploreNetworkNodesByDistanceRequest* explorenodes) {
  clear_ClientRequestType();
  if (explorenodes) {
    set_has_explorenodes();
    ClientRequestType_.explorenodes_ = explorenodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientRequest.exploreNodes)
}

inline bool ClientRequest::has_ClientRequestType() const {
  return ClientRequestType_case() != CLIENTREQUESTTYPE_NOT_SET;
}
inline void ClientRequest::clear_has_ClientRequestType() {
  _oneof_case_[0] = CLIENTREQUESTTYPE_NOT_SET;
}
inline ClientRequest::ClientRequestTypeCase ClientRequest::ClientRequestType_case() const {
  return ClientRequest::ClientRequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientResponse

// optional .iop.locnet.GetNodeInfoResponse getNodeInfo = 1;
inline bool ClientResponse::has_getnodeinfo() const {
  return ClientResponseType_case() == kGetNodeInfo;
}
inline void ClientResponse::set_has_getnodeinfo() {
  _oneof_case_[0] = kGetNodeInfo;
}
inline void ClientResponse::clear_getnodeinfo() {
  if (has_getnodeinfo()) {
    delete ClientResponseType_.getnodeinfo_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetNodeInfoResponse& ClientResponse::getnodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.getNodeInfo)
  return has_getnodeinfo()
      ? *ClientResponseType_.getnodeinfo_
      : ::iop::locnet::GetNodeInfoResponse::default_instance();
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::mutable_getnodeinfo() {
  if (!has_getnodeinfo()) {
    clear_ClientResponseType();
    set_has_getnodeinfo();
    ClientResponseType_.getnodeinfo_ = new ::iop::locnet::GetNodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.getNodeInfo)
  return ClientResponseType_.getnodeinfo_;
}
inline ::iop::locnet::GetNodeInfoResponse* ClientResponse::release_getnodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.getNodeInfo)
  if (has_getnodeinfo()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetNodeInfoResponse* temp = ClientResponseType_.getnodeinfo_;
    ClientResponseType_.getnodeinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_getnodeinfo(::iop::locnet::GetNodeInfoResponse* getnodeinfo) {
  clear_ClientResponseType();
  if (getnodeinfo) {
    set_has_getnodeinfo();
    ClientResponseType_.getnodeinfo_ = getnodeinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.getNodeInfo)
}

// optional .iop.locnet.GetNeighbourNodesByDistanceResponse getNeighbourNodes = 2;
inline bool ClientResponse::has_getneighbournodes() const {
  return ClientResponseType_case() == kGetNeighbourNodes;
}
inline void ClientResponse::set_has_getneighbournodes() {
  _oneof_case_[0] = kGetNeighbourNodes;
}
inline void ClientResponse::clear_getneighbournodes() {
  if (has_getneighbournodes()) {
    delete ClientResponseType_.getneighbournodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetNeighbourNodesByDistanceResponse& ClientResponse::getneighbournodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.getNeighbourNodes)
  return has_getneighbournodes()
      ? *ClientResponseType_.getneighbournodes_
      : ::iop::locnet::GetNeighbourNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::mutable_getneighbournodes() {
  if (!has_getneighbournodes()) {
    clear_ClientResponseType();
    set_has_getneighbournodes();
    ClientResponseType_.getneighbournodes_ = new ::iop::locnet::GetNeighbourNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.getNeighbourNodes)
  return ClientResponseType_.getneighbournodes_;
}
inline ::iop::locnet::GetNeighbourNodesByDistanceResponse* ClientResponse::release_getneighbournodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.getNeighbourNodes)
  if (has_getneighbournodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetNeighbourNodesByDistanceResponse* temp = ClientResponseType_.getneighbournodes_;
    ClientResponseType_.getneighbournodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_getneighbournodes(::iop::locnet::GetNeighbourNodesByDistanceResponse* getneighbournodes) {
  clear_ClientResponseType();
  if (getneighbournodes) {
    set_has_getneighbournodes();
    ClientResponseType_.getneighbournodes_ = getneighbournodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.getNeighbourNodes)
}

// optional .iop.locnet.GetClosestNodesByDistanceResponse getClosestNodes = 3;
inline bool ClientResponse::has_getclosestnodes() const {
  return ClientResponseType_case() == kGetClosestNodes;
}
inline void ClientResponse::set_has_getclosestnodes() {
  _oneof_case_[0] = kGetClosestNodes;
}
inline void ClientResponse::clear_getclosestnodes() {
  if (has_getclosestnodes()) {
    delete ClientResponseType_.getclosestnodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::GetClosestNodesByDistanceResponse& ClientResponse::getclosestnodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.getClosestNodes)
  return has_getclosestnodes()
      ? *ClientResponseType_.getclosestnodes_
      : ::iop::locnet::GetClosestNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::mutable_getclosestnodes() {
  if (!has_getclosestnodes()) {
    clear_ClientResponseType();
    set_has_getclosestnodes();
    ClientResponseType_.getclosestnodes_ = new ::iop::locnet::GetClosestNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.getClosestNodes)
  return ClientResponseType_.getclosestnodes_;
}
inline ::iop::locnet::GetClosestNodesByDistanceResponse* ClientResponse::release_getclosestnodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.getClosestNodes)
  if (has_getclosestnodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::GetClosestNodesByDistanceResponse* temp = ClientResponseType_.getclosestnodes_;
    ClientResponseType_.getclosestnodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_getclosestnodes(::iop::locnet::GetClosestNodesByDistanceResponse* getclosestnodes) {
  clear_ClientResponseType();
  if (getclosestnodes) {
    set_has_getclosestnodes();
    ClientResponseType_.getclosestnodes_ = getclosestnodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.getClosestNodes)
}

// optional .iop.locnet.ExploreNetworkNodesByDistanceResponse exploreNodes = 4;
inline bool ClientResponse::has_explorenodes() const {
  return ClientResponseType_case() == kExploreNodes;
}
inline void ClientResponse::set_has_explorenodes() {
  _oneof_case_[0] = kExploreNodes;
}
inline void ClientResponse::clear_explorenodes() {
  if (has_explorenodes()) {
    delete ClientResponseType_.explorenodes_;
    clear_has_ClientResponseType();
  }
}
inline  const ::iop::locnet::ExploreNetworkNodesByDistanceResponse& ClientResponse::explorenodes() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ClientResponse.exploreNodes)
  return has_explorenodes()
      ? *ClientResponseType_.explorenodes_
      : ::iop::locnet::ExploreNetworkNodesByDistanceResponse::default_instance();
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::mutable_explorenodes() {
  if (!has_explorenodes()) {
    clear_ClientResponseType();
    set_has_explorenodes();
    ClientResponseType_.explorenodes_ = new ::iop::locnet::ExploreNetworkNodesByDistanceResponse;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ClientResponse.exploreNodes)
  return ClientResponseType_.explorenodes_;
}
inline ::iop::locnet::ExploreNetworkNodesByDistanceResponse* ClientResponse::release_explorenodes() {
  // @@protoc_insertion_point(field_release:iop.locnet.ClientResponse.exploreNodes)
  if (has_explorenodes()) {
    clear_has_ClientResponseType();
    ::iop::locnet::ExploreNetworkNodesByDistanceResponse* temp = ClientResponseType_.explorenodes_;
    ClientResponseType_.explorenodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientResponse::set_allocated_explorenodes(::iop::locnet::ExploreNetworkNodesByDistanceResponse* explorenodes) {
  clear_ClientResponseType();
  if (explorenodes) {
    set_has_explorenodes();
    ClientResponseType_.explorenodes_ = explorenodes;
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ClientResponse.exploreNodes)
}

inline bool ClientResponse::has_ClientResponseType() const {
  return ClientResponseType_case() != CLIENTRESPONSETYPE_NOT_SET;
}
inline void ClientResponse::clear_has_ClientResponseType() {
  _oneof_case_[0] = CLIENTRESPONSETYPE_NOT_SET;
}
inline ClientResponse::ClientResponseTypeCase ClientResponse::ClientResponseType_case() const {
  return ClientResponse::ClientResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetNodeInfoRequest

// -------------------------------------------------------------------

// GetNodeInfoResponse

// optional .iop.locnet.NodeInfo nodeInfo = 1;
inline bool GetNodeInfoResponse::has_nodeinfo() const {
  return !_is_default_instance_ && nodeinfo_ != NULL;
}
inline void GetNodeInfoResponse::clear_nodeinfo() {
  if (GetArenaNoVirtual() == NULL && nodeinfo_ != NULL) delete nodeinfo_;
  nodeinfo_ = NULL;
}
inline const ::iop::locnet::NodeInfo& GetNodeInfoResponse::nodeinfo() const {
  // @@protoc_insertion_point(field_get:iop.locnet.GetNodeInfoResponse.nodeInfo)
  return nodeinfo_ != NULL ? *nodeinfo_ : *default_instance_->nodeinfo_;
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::mutable_nodeinfo() {
  
  if (nodeinfo_ == NULL) {
    nodeinfo_ = new ::iop::locnet::NodeInfo;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.GetNodeInfoResponse.nodeInfo)
  return nodeinfo_;
}
inline ::iop::locnet::NodeInfo* GetNodeInfoResponse::release_nodeinfo() {
  // @@protoc_insertion_point(field_release:iop.locnet.GetNodeInfoResponse.nodeInfo)
  
  ::iop::locnet::NodeInfo* temp = nodeinfo_;
  nodeinfo_ = NULL;
  return temp;
}
inline void GetNodeInfoResponse::set_allocated_nodeinfo(::iop::locnet::NodeInfo* nodeinfo) {
  delete nodeinfo_;
  nodeinfo_ = nodeinfo;
  if (nodeinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.GetNodeInfoResponse.nodeInfo)
}

// -------------------------------------------------------------------

// GetNeighbourNodesByDistanceClientRequest

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceRequest

// optional .iop.locnet.GpsLocation location = 1;
inline bool ExploreNetworkNodesByDistanceRequest::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void ExploreNetworkNodesByDistanceRequest::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::iop::locnet::GpsLocation& ExploreNetworkNodesByDistanceRequest::location() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::iop::locnet::GpsLocation;
  }
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  return location_;
}
inline ::iop::locnet::GpsLocation* ExploreNetworkNodesByDistanceRequest::release_location() {
  // @@protoc_insertion_point(field_release:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
  
  ::iop::locnet::GpsLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void ExploreNetworkNodesByDistanceRequest::set_allocated_location(::iop::locnet::GpsLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iop.locnet.ExploreNetworkNodesByDistanceRequest.location)
}

// optional uint32 targetNodeCount = 2;
inline void ExploreNetworkNodesByDistanceRequest::clear_targetnodecount() {
  targetnodecount_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::targetnodecount() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.targetNodeCount)
  return targetnodecount_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_targetnodecount(::google::protobuf::uint32 value) {
  
  targetnodecount_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.targetNodeCount)
}

// optional uint32 maxNodeHops = 3;
inline void ExploreNetworkNodesByDistanceRequest::clear_maxnodehops() {
  maxnodehops_ = 0u;
}
inline ::google::protobuf::uint32 ExploreNetworkNodesByDistanceRequest::maxnodehops() const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceRequest.maxNodeHops)
  return maxnodehops_;
}
inline void ExploreNetworkNodesByDistanceRequest::set_maxnodehops(::google::protobuf::uint32 value) {
  
  maxnodehops_ = value;
  // @@protoc_insertion_point(field_set:iop.locnet.ExploreNetworkNodesByDistanceRequest.maxNodeHops)
}

// -------------------------------------------------------------------

// ExploreNetworkNodesByDistanceResponse

// repeated .iop.locnet.NodeInfo closestNodes = 1;
inline int ExploreNetworkNodesByDistanceResponse::closestnodes_size() const {
  return closestnodes_.size();
}
inline void ExploreNetworkNodesByDistanceResponse::clear_closestnodes() {
  closestnodes_.Clear();
}
inline const ::iop::locnet::NodeInfo& ExploreNetworkNodesByDistanceResponse::closestnodes(int index) const {
  // @@protoc_insertion_point(field_get:iop.locnet.ExploreNetworkNodesByDistanceResponse.closestNodes)
  return closestnodes_.Get(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::mutable_closestnodes(int index) {
  // @@protoc_insertion_point(field_mutable:iop.locnet.ExploreNetworkNodesByDistanceResponse.closestNodes)
  return closestnodes_.Mutable(index);
}
inline ::iop::locnet::NodeInfo* ExploreNetworkNodesByDistanceResponse::add_closestnodes() {
  // @@protoc_insertion_point(field_add:iop.locnet.ExploreNetworkNodesByDistanceResponse.closestNodes)
  return closestnodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >*
ExploreNetworkNodesByDistanceResponse::mutable_closestnodes() {
  // @@protoc_insertion_point(field_mutable_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closestNodes)
  return &closestnodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iop::locnet::NodeInfo >&
ExploreNetworkNodesByDistanceResponse::closestnodes() const {
  // @@protoc_insertion_point(field_list:iop.locnet.ExploreNetworkNodesByDistanceResponse.closestNodes)
  return closestnodes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace locnet
}  // namespace iop

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::iop::locnet::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iop::locnet::Status>() {
  return ::iop::locnet::Status_descriptor();
}
template <> struct is_proto_enum< ::iop::locnet::ServiceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iop::locnet::ServiceType>() {
  return ::iop::locnet::ServiceType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IopLocNet_2eproto__INCLUDED
